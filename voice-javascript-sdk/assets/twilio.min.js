(function (root) {
  const bundle = (function () {
    function r(e, n, t) {
      function o(i, f) {
        if (!n[i]) {
          if (!e[i]) {
            const c = typeof require === 'function' && require;
            if (!f && c) return c(i, !0);
            if (u) return u(i, !0);
            const a = new Error(`Cannot find module '${i}'`);
            throw ((a.code = 'MODULE_NOT_FOUND'), a);
          }
          const p = (n[i] = { exports: {} });
          e[i][0].call(
            p.exports,
            function (r) {
              const n = e[i][1][r];
              return o(n || r);
            },
            p,
            p.exports,
            r,
            e,
            n,
            t
          );
        }
        return n[i].exports;
      }
      for (
        var u = typeof require === 'function' && require, i = 0;
        i < t.length;
        i++
      )
        o(t[i]);
      return o;
    }
    return r;
  })()(
    {
      1: [
        function (require, module, exports) {
          module.exports = WebSocket;
        },
        {},
      ],
      2: [
        function (require, module, exports) {
          module.exports = { XMLHttpRequest };
        },
        {},
      ],
      3: [
        function (require, module, exports) {
          Object.defineProperty(exports, '__esModule', { value: true });
          const call_1 = require('./twilio/call');
          exports.Call = call_1.default;
          const device_1 = require('./twilio/device');
          exports.Device = device_1.default;
          const TwilioError = require('./twilio/errors');
          exports.TwilioError = TwilioError;
          const log_1 = require('./twilio/log');
          exports.Logger = log_1.Logger;
          const preflight_1 = require('./twilio/preflight/preflight');
          exports.PreflightTest = preflight_1.PreflightTest;
        },
        {
          './twilio/call': 6,
          './twilio/device': 9,
          './twilio/errors': 12,
          './twilio/log': 15,
          './twilio/preflight/preflight': 17,
        },
      ],
      4: [
        function (require, module, exports) {
          const __awaiter =
            (this && this.__awaiter) ||
            function (thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P
                  ? value
                  : new P(function (resolve) {
                      resolve(value);
                    });
              }
              return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator.throw(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step(result) {
                  result.done
                    ? resolve(result.value)
                    : adopt(result.value).then(fulfilled, rejected);
                }
                step(
                  (generator = generator.apply(
                    thisArg,
                    _arguments || []
                  )).next()
                );
              });
            };
          const __generator =
            (this && this.__generator) ||
            function (thisArg, body) {
              let _ = {
                label: 0,
                sent() {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                },
                trys: [],
                ops: [],
              };
              let f;
              let y;
              let t;
              let g;
              return (
                (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                typeof Symbol === 'function' &&
                  (g[Symbol.iterator] = function () {
                    return this;
                  }),
                g
              );
              function verb(n) {
                return function (v) {
                  return step([n, v]);
                };
              }
              function step(op) {
                if (f) throw new TypeError('Generator is already executing.');
                while (_)
                  try {
                    if (
                      ((f = 1),
                      y &&
                        (t =
                          op[0] & 2
                            ? y.return
                            : op[0]
                            ? y.throw || ((t = y.return) && t.call(y), 0)
                            : y.next) &&
                        !(t = t.call(y, op[1])).done)
                    )
                      return t;
                    if (((y = 0), t)) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (
                          !((t = _.trys),
                          (t = t.length > 0 && t[t.length - 1])) &&
                          (op[0] === 6 || op[0] === 2)
                        ) {
                          _ = 0;
                          continue;
                        }
                        if (
                          op[0] === 3 &&
                          (!t || (op[1] > t[0] && op[1] < t[3]))
                        ) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1];
                          t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    op = [6, e];
                    y = 0;
                  } finally {
                    f = t = 0;
                  }
                if (op[0] & 5) throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            };
          Object.defineProperty(exports, '__esModule', { value: true });
          const deferred_1 = require('./deferred');
          const AsyncQueue = (function () {
            function AsyncQueue() {
              this._operations = [];
            }
            AsyncQueue.prototype.enqueue = function (callback) {
              const hasPending = Boolean(this._operations.length);
              const deferred = new deferred_1.default();
              this._operations.push({ deferred, callback });
              if (!hasPending) {
                this._processQueue();
              }
              return deferred.promise;
            };
            AsyncQueue.prototype._processQueue = function () {
              return __awaiter(this, void 0, void 0, function () {
                let _a;
                let deferred;
                let callback;
                let result;
                let error;
                let hasResolved;
                let e_1;
                return __generator(this, function (_b) {
                  switch (_b.label) {
                    case 0:
                      if (!this._operations.length) return [3, 5];
                      (_a = this._operations[0]),
                        (deferred = _a.deferred),
                        (callback = _a.callback);
                      result = void 0;
                      error = void 0;
                      hasResolved = void 0;
                      _b.label = 1;
                    case 1:
                      _b.trys.push([1, 3, , 4]);
                      return [4, callback()];
                    case 2:
                      result = _b.sent();
                      hasResolved = true;
                      return [3, 4];
                    case 3:
                      e_1 = _b.sent();
                      error = e_1;
                      return [3, 4];
                    case 4:
                      this._operations.shift();
                      if (hasResolved) {
                        deferred.resolve(result);
                      } else {
                        deferred.reject(error);
                      }
                      return [3, 0];
                    case 5:
                      return [2];
                  }
                });
              });
            };
            return AsyncQueue;
          })();
          exports.AsyncQueue = AsyncQueue;
        },
        { './deferred': 8 },
      ],
      5: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          Object.defineProperty(exports, '__esModule', { value: true });
          const events_1 = require('events');
          const errors_1 = require('./errors');
          const log_1 = require('./log');
          const outputdevicecollection_1 = require('./outputdevicecollection');
          const defaultMediaDevices = require('./shims/mediadevices');
          const util_1 = require('./util');
          const MediaDeviceInfoShim = require('./shims/mediadeviceinfo');
          const kindAliases = {
            audioinput: 'Audio Input',
            audiooutput: 'Audio Output',
          };
          let AudioHelper = (function (_super) {
            __extends(AudioHelper, _super);
            function AudioHelper(
              onActiveOutputsChanged,
              onActiveInputChanged,
              getUserMedia,
              options
            ) {
              const _this = _super.call(this) || this;
              _this.availableInputDevices = new Map();
              _this.availableOutputDevices = new Map();
              _this._audioConstraints = null;
              _this._inputDevice = null;
              _this._inputStream = null;
              _this._isPollingInputVolume = false;
              _this._log = log_1.default.getInstance();
              _this._unknownDeviceIndexes = { audioinput: {}, audiooutput: {} };
              _this._removeLostInput = function (lostDevice) {
                if (
                  !_this.inputDevice ||
                  _this.inputDevice.deviceId !== lostDevice.deviceId
                ) {
                  return false;
                }
                _this._replaceStream(null);
                _this._inputDevice = null;
                _this._maybeStopPollingVolume();
                const defaultDevice =
                  _this.availableInputDevices.get('default') ||
                  Array.from(_this.availableInputDevices.values())[0];
                if (defaultDevice) {
                  _this.setInputDevice(defaultDevice.deviceId);
                }
                return true;
              };
              _this._removeLostOutput = function (lostDevice) {
                const wasSpeakerLost = _this.speakerDevices.delete(lostDevice);
                const wasRingtoneLost =
                  _this.ringtoneDevices.delete(lostDevice);
                return wasSpeakerLost || wasRingtoneLost;
              };
              _this._updateAvailableDevices = function () {
                if (!_this._mediaDevices) {
                  return Promise.reject('Enumeration not supported');
                }
                return _this._mediaDevices
                  .enumerateDevices()
                  .then(function (devices) {
                    _this._updateDevices(
                      devices.filter(function (d) {
                        return d.kind === 'audiooutput';
                      }),
                      _this.availableOutputDevices,
                      _this._removeLostOutput
                    );
                    _this._updateDevices(
                      devices.filter(function (d) {
                        return d.kind === 'audioinput';
                      }),
                      _this.availableInputDevices,
                      _this._removeLostInput
                    );
                    const defaultDevice =
                      _this.availableOutputDevices.get('default') ||
                      Array.from(_this.availableOutputDevices.values())[0];
                    [_this.speakerDevices, _this.ringtoneDevices].forEach(
                      function (outputDevices) {
                        if (
                          !outputDevices.get().size &&
                          _this.availableOutputDevices.size &&
                          _this.isOutputSelectionSupported
                        ) {
                          outputDevices
                            .set(defaultDevice.deviceId)
                            .catch(function (reason) {
                              _this._log.warn(
                                `Unable to set audio output devices. ${reason}`
                              );
                            });
                        }
                      }
                    );
                  });
              };
              options = {
                AudioContext:
                  typeof AudioContext !== 'undefined' && AudioContext,
                setSinkId:
                  typeof HTMLAudioElement !== 'undefined' &&
                  HTMLAudioElement.prototype.setSinkId,
                ...options,
              };
              _this._getUserMedia = getUserMedia;
              _this._mediaDevices = options.mediaDevices || defaultMediaDevices;
              _this._onActiveInputChanged = onActiveInputChanged;
              const isAudioContextSupported = Boolean(
                options.AudioContext || options.audioContext
              );
              const isEnumerationSupported = Boolean(
                _this._mediaDevices && _this._mediaDevices.enumerateDevices
              );
              const isSetSinkSupported =
                typeof options.setSinkId === 'function';
              _this.isOutputSelectionSupported =
                isEnumerationSupported && isSetSinkSupported;
              _this.isVolumeSupported = isAudioContextSupported;
              if (options.enabledSounds) {
                _this._addEnabledSounds(options.enabledSounds);
              }
              if (_this.isVolumeSupported) {
                _this._audioContext =
                  options.audioContext ||
                  (options.AudioContext && new options.AudioContext());
                if (_this._audioContext) {
                  _this._inputVolumeAnalyser =
                    _this._audioContext.createAnalyser();
                  _this._inputVolumeAnalyser.fftSize = 32;
                  _this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;
                }
              }
              _this.ringtoneDevices = new outputdevicecollection_1.default(
                'ringtone',
                _this.availableOutputDevices,
                onActiveOutputsChanged,
                _this.isOutputSelectionSupported
              );
              _this.speakerDevices = new outputdevicecollection_1.default(
                'speaker',
                _this.availableOutputDevices,
                onActiveOutputsChanged,
                _this.isOutputSelectionSupported
              );
              _this.addListener('newListener', function (eventName) {
                if (eventName === 'inputVolume') {
                  _this._maybeStartPollingVolume();
                }
              });
              _this.addListener('removeListener', function (eventName) {
                if (eventName === 'inputVolume') {
                  _this._maybeStopPollingVolume();
                }
              });
              _this.once('newListener', function () {
                if (!_this.isOutputSelectionSupported) {
                  _this._log.warn(
                    'Warning: This browser does not support audio output selection.'
                  );
                }
                if (!_this.isVolumeSupported) {
                  _this._log.warn(
                    "Warning: This browser does not support Twilio's volume indicator feature."
                  );
                }
              });
              if (isEnumerationSupported) {
                _this._initializeEnumeration();
              }
              return _this;
            }
            Object.defineProperty(AudioHelper.prototype, 'audioConstraints', {
              get() {
                return this._audioConstraints;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(AudioHelper.prototype, 'inputDevice', {
              get() {
                return this._inputDevice;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(AudioHelper.prototype, 'inputStream', {
              get() {
                return this._inputStream;
              },
              enumerable: true,
              configurable: true,
            });
            AudioHelper.prototype._maybeStartPollingVolume = function () {
              const _this = this;
              if (!this.isVolumeSupported || !this._inputStream) {
                return;
              }
              this._updateVolumeSource();
              if (this._isPollingInputVolume || !this._inputVolumeAnalyser) {
                return;
              }
              const bufferLength = this._inputVolumeAnalyser.frequencyBinCount;
              const buffer = new Uint8Array(bufferLength);
              this._isPollingInputVolume = true;
              var emitVolume = function () {
                if (!_this._isPollingInputVolume) {
                  return;
                }
                if (_this._inputVolumeAnalyser) {
                  _this._inputVolumeAnalyser.getByteFrequencyData(buffer);
                  const inputVolume = util_1.average(buffer);
                  _this.emit('inputVolume', inputVolume / 255);
                }
                requestAnimationFrame(emitVolume);
              };
              requestAnimationFrame(emitVolume);
            };
            AudioHelper.prototype._maybeStopPollingVolume = function () {
              if (!this.isVolumeSupported) {
                return;
              }
              if (
                !this._isPollingInputVolume ||
                (this._inputStream && this.listenerCount('inputVolume'))
              ) {
                return;
              }
              if (this._inputVolumeSource) {
                this._inputVolumeSource.disconnect();
                delete this._inputVolumeSource;
              }
              this._isPollingInputVolume = false;
            };
            AudioHelper.prototype._unbind = function () {
              if (!this._mediaDevices) {
                throw new errors_1.NotSupportedError(
                  'Enumeration is not supported'
                );
              }
              if (this._mediaDevices.removeEventListener) {
                this._mediaDevices.removeEventListener(
                  'devicechange',
                  this._updateAvailableDevices
                );
                this._mediaDevices.removeEventListener(
                  'deviceinfochange',
                  this._updateAvailableDevices
                );
              }
            };
            AudioHelper.prototype.setAudioConstraints = function (
              audioConstraints
            ) {
              this._audioConstraints = { ...audioConstraints };
              delete this._audioConstraints.deviceId;
              return this.inputDevice
                ? this._setInputDevice(this.inputDevice.deviceId, true)
                : Promise.resolve();
            };
            AudioHelper.prototype.setInputDevice = function (deviceId) {
              return !util_1.isFirefox()
                ? this._setInputDevice(deviceId, false)
                : Promise.reject(
                    new errors_1.NotSupportedError(
                      'Firefox does not currently support opening multiple ' +
                        'audio input tracks simultaneously, even across different tabs. As a result, ' +
                        'Device.audio.setInputDevice is disabled on Firefox until support is added.\n' +
                        'Related BugZilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'
                    )
                  );
            };
            AudioHelper.prototype.unsetAudioConstraints = function () {
              this._audioConstraints = null;
              return this.inputDevice
                ? this._setInputDevice(this.inputDevice.deviceId, true)
                : Promise.resolve();
            };
            AudioHelper.prototype.unsetInputDevice = function () {
              const _this = this;
              if (!this.inputDevice) {
                return Promise.resolve();
              }
              return this._onActiveInputChanged(null).then(function () {
                _this._replaceStream(null);
                _this._inputDevice = null;
                _this._maybeStopPollingVolume();
              });
            };
            AudioHelper.prototype._addEnabledSounds = function (enabledSounds) {
              const _this = this;
              function setValue(key, value) {
                if (typeof value !== 'undefined') {
                  enabledSounds[key] = value;
                }
                return enabledSounds[key];
              }
              Object.keys(enabledSounds).forEach(function (key) {
                _this[key] = setValue.bind(null, key);
              });
            };
            AudioHelper.prototype._getUnknownDeviceIndex = function (
              mediaDeviceInfo
            ) {
              const id = mediaDeviceInfo.deviceId;
              const { kind } = mediaDeviceInfo;
              let index = this._unknownDeviceIndexes[kind][id];
              if (!index) {
                index =
                  Object.keys(this._unknownDeviceIndexes[kind]).length + 1;
                this._unknownDeviceIndexes[kind][id] = index;
              }
              return index;
            };
            AudioHelper.prototype._initializeEnumeration = function () {
              const _this = this;
              if (!this._mediaDevices) {
                throw new errors_1.NotSupportedError(
                  'Enumeration is not supported'
                );
              }
              if (this._mediaDevices.addEventListener) {
                this._mediaDevices.addEventListener(
                  'devicechange',
                  this._updateAvailableDevices
                );
                this._mediaDevices.addEventListener(
                  'deviceinfochange',
                  this._updateAvailableDevices
                );
              }
              this._updateAvailableDevices().then(function () {
                if (!_this.isOutputSelectionSupported) {
                  return;
                }
                Promise.all([
                  _this.speakerDevices.set('default'),
                  _this.ringtoneDevices.set('default'),
                ]).catch(function (reason) {
                  _this._log.warn(
                    `Warning: Unable to set audio output devices. ${reason}`
                  );
                });
              });
            };
            AudioHelper.prototype._replaceStream = function (stream) {
              if (this._inputStream) {
                this._inputStream.getTracks().forEach(function (track) {
                  track.stop();
                });
              }
              this._inputStream = stream;
            };
            AudioHelper.prototype._setInputDevice = function (
              deviceId,
              forceGetUserMedia
            ) {
              const _this = this;
              if (typeof deviceId !== 'string') {
                return Promise.reject(
                  new errors_1.InvalidArgumentError(
                    'Must specify the device to set'
                  )
                );
              }
              const device = this.availableInputDevices.get(deviceId);
              if (!device) {
                return Promise.reject(
                  new errors_1.InvalidArgumentError(
                    `Device not found: ${deviceId}`
                  )
                );
              }
              if (
                this._inputDevice &&
                this._inputDevice.deviceId === deviceId &&
                this._inputStream
              ) {
                if (!forceGetUserMedia) {
                  return Promise.resolve();
                }
                this._inputStream.getTracks().forEach(function (track) {
                  track.stop();
                });
              }
              const constraints = {
                audio: {
                  deviceId: { exact: deviceId },
                  ...this.audioConstraints,
                },
              };
              return this._getUserMedia(constraints).then(function (stream) {
                return _this._onActiveInputChanged(stream).then(function () {
                  _this._replaceStream(stream);
                  _this._inputDevice = device;
                  _this._maybeStartPollingVolume();
                });
              });
            };
            AudioHelper.prototype._updateDevices = function (
              updatedDevices,
              availableDevices,
              removeLostDevice
            ) {
              const _this = this;
              const updatedDeviceIds = updatedDevices.map(function (d) {
                return d.deviceId;
              });
              const knownDeviceIds = Array.from(availableDevices.values()).map(
                function (d) {
                  return d.deviceId;
                }
              );
              const lostActiveDevices = [];
              const lostDeviceIds = util_1.difference(
                knownDeviceIds,
                updatedDeviceIds
              );
              lostDeviceIds.forEach(function (lostDeviceId) {
                const lostDevice = availableDevices.get(lostDeviceId);
                if (lostDevice) {
                  availableDevices.delete(lostDeviceId);
                  if (removeLostDevice(lostDevice)) {
                    lostActiveDevices.push(lostDevice);
                  }
                }
              });
              let deviceChanged = false;
              updatedDevices.forEach(function (newDevice) {
                const existingDevice = availableDevices.get(newDevice.deviceId);
                const newMediaDeviceInfo =
                  _this._wrapMediaDeviceInfo(newDevice);
                if (
                  !existingDevice ||
                  existingDevice.label !== newMediaDeviceInfo.label
                ) {
                  availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);
                  deviceChanged = true;
                }
              });
              if (deviceChanged || lostDeviceIds.length) {
                if (
                  this.inputDevice !== null &&
                  this.inputDevice.deviceId === 'default'
                ) {
                  this._log.warn(
                    'Calling getUserMedia after device change to ensure that the           tracks of the active device (default) have not gone stale.'
                  );
                  this._setInputDevice(this.inputDevice.deviceId, true);
                }
                this.emit('deviceChange', lostActiveDevices);
              }
            };
            AudioHelper.prototype._updateVolumeSource = function () {
              if (
                !this._inputStream ||
                !this._audioContext ||
                !this._inputVolumeAnalyser
              ) {
                return;
              }
              if (this._inputVolumeSource) {
                this._inputVolumeSource.disconnect();
              }
              this._inputVolumeSource =
                this._audioContext.createMediaStreamSource(this._inputStream);
              this._inputVolumeSource.connect(this._inputVolumeAnalyser);
            };
            AudioHelper.prototype._wrapMediaDeviceInfo = function (
              mediaDeviceInfo
            ) {
              const options = {
                deviceId: mediaDeviceInfo.deviceId,
                groupId: mediaDeviceInfo.groupId,
                kind: mediaDeviceInfo.kind,
                label: mediaDeviceInfo.label,
              };
              if (!options.label) {
                if (options.deviceId === 'default') {
                  options.label = 'Default';
                } else {
                  const index = this._getUnknownDeviceIndex(mediaDeviceInfo);
                  options.label = `Unknown ${
                    kindAliases[options.kind]
                  } Device ${index}`;
                }
              }
              return new MediaDeviceInfoShim(options);
            };
            return AudioHelper;
          })(events_1.EventEmitter);
          (function (AudioHelper) {})(AudioHelper || (AudioHelper = {}));
          exports.default = AudioHelper;
        },
        {
          './errors': 12,
          './log': 15,
          './outputdevicecollection': 16,
          './shims/mediadeviceinfo': 31,
          './shims/mediadevices': 32,
          './util': 35,
          events: 48,
        },
      ],
      6: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          var __assign =
            (this && this.__assign) ||
            function () {
              __assign =
                Object.assign ||
                function (t) {
                  for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (const p in s)
                      if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
                  }
                  return t;
                };
              return __assign.apply(this, arguments);
            };
          Object.defineProperty(exports, '__esModule', { value: true });
          const events_1 = require('events');
          const device_1 = require('./device');
          const errors_1 = require('./errors');
          const log_1 = require('./log');
          const icecandidate_1 = require('./rtc/icecandidate');
          const statsMonitor_1 = require('./statsMonitor');
          const util_1 = require('./util');
          const Backoff = require('backoff');
          const C = require('./constants');
          const { PeerConnection } = require('./rtc');
          const { getPreferredCodecInfo } = require('./rtc/sdp');
          const BACKOFF_CONFIG = {
            factor: 1.1,
            initialDelay: 1,
            maxDelay: 3e4,
            randomisationFactor: 0.5,
          };
          const DTMF_INTER_TONE_GAP = 70;
          const DTMF_PAUSE_DURATION = 500;
          const DTMF_TONE_DURATION = 160;
          const METRICS_BATCH_SIZE = 10;
          const METRICS_DELAY = 5e3;
          const MEDIA_DISCONNECT_ERROR = {
            disconnect: true,
            info: {
              code: 31003,
              message: 'Connection with Twilio was interrupted.',
              twilioError: new errors_1.MediaErrors.ConnectionError(),
            },
          };
          const MULTIPLE_THRESHOLD_WARNING_NAMES = {
            packetsLostFraction: {
              max: 'packet-loss',
              maxAverage: 'packets-lost-fraction',
            },
          };
          const WARNING_NAMES = {
            audioInputLevel: 'audio-input-level',
            audioOutputLevel: 'audio-output-level',
            bytesReceived: 'bytes-received',
            bytesSent: 'bytes-sent',
            jitter: 'jitter',
            mos: 'mos',
            rtt: 'rtt',
          };
          const WARNING_PREFIXES = {
            max: 'high-',
            maxAverage: 'high-',
            maxDuration: 'constant-',
            min: 'low-',
            minStandardDeviation: 'constant-',
          };
          let Call = (function (_super) {
            __extends(Call, _super);
            function Call(config, options) {
              const _this = _super.call(this) || this;
              _this.parameters = {};
              _this._inputVolumeStreak = 0;
              _this._isAnswered = false;
              _this._isCancelled = false;
              _this._latestInputVolume = 0;
              _this._latestOutputVolume = 0;
              _this._log = log_1.default.getInstance();
              _this._metricsSamples = [];
              _this._options = {
                MediaHandler: PeerConnection,
                offerSdp: null,
                shouldPlayDisconnect() {
                  return true;
                },
              };
              _this._outputVolumeStreak = 0;
              _this._shouldSendHangup = true;
              _this._soundcache = new Map();
              _this._status = Call.State.Pending;
              _this.toString = function () {
                return '[Twilio.Call instance]';
              };
              _this._emitWarning = function (
                groupPrefix,
                warningName,
                threshold,
                value,
                wasCleared,
                warningData
              ) {
                const groupSuffix = wasCleared ? '-cleared' : '-raised';
                const groupName = `${groupPrefix}warning${groupSuffix}`;
                if (
                  warningName === 'constant-audio-input-level' &&
                  _this.isMuted()
                ) {
                  return;
                }
                let level = wasCleared ? 'info' : 'warning';
                if (warningName === 'constant-audio-output-level') {
                  level = 'info';
                }
                const payloadData = { threshold };
                if (value) {
                  if (value instanceof Array) {
                    payloadData.values = value.map(function (val) {
                      if (typeof val === 'number') {
                        return Math.round(val * 100) / 100;
                      }
                      return value;
                    });
                  } else {
                    payloadData.value = value;
                  }
                }
                _this._publisher.post(
                  level,
                  groupName,
                  warningName,
                  { data: payloadData },
                  _this
                );
                if (warningName !== 'constant-audio-output-level') {
                  const emitName = wasCleared ? 'warning-cleared' : 'warning';
                  _this.emit(
                    emitName,
                    warningName,
                    warningData && !wasCleared ? warningData : null
                  );
                }
              };
              _this._onAnswer = function (payload) {
                if (_this._isAnswered) {
                  return;
                }
                _this._setCallSid(payload);
                _this._isAnswered = true;
                _this._maybeTransitionToOpen();
              };
              _this._onCancel = function (payload) {
                const { callsid } = payload;
                if (_this.parameters.CallSid === callsid) {
                  _this._isCancelled = true;
                  _this._publisher.info('connection', 'cancel', null, _this);
                  _this._cleanupEventListeners();
                  _this._mediaHandler.close();
                  _this._status = Call.State.Closed;
                  _this.emit('cancel');
                  _this._pstream.removeListener('cancel', _this._onCancel);
                }
              };
              _this._onHangup = function (payload) {
                if (
                  payload.callsid &&
                  (_this.parameters.CallSid || _this.outboundConnectionId)
                ) {
                  if (
                    payload.callsid !== _this.parameters.CallSid &&
                    payload.callsid !== _this.outboundConnectionId
                  ) {
                    return;
                  }
                } else if (payload.callsid) {
                  return;
                }
                _this._log.info('Received HANGUP from gateway');
                if (payload.error) {
                  const error = new errors_1.GeneralErrors.ConnectionError(
                    'Error sent from gateway in HANGUP'
                  );
                  _this._log.error(
                    'Received an error from the gateway:',
                    error
                  );
                  _this.emit('error', error);
                }
                _this._shouldSendHangup = false;
                _this._publisher.info(
                  'connection',
                  'disconnected-by-remote',
                  null,
                  _this
                );
                _this._disconnect(null, true);
                _this._cleanupEventListeners();
              };
              _this._onMediaFailure = function (type) {
                const _a = Call.MediaFailure;
                const { ConnectionDisconnected } = _a;
                const { ConnectionFailed } = _a;
                const { IceGatheringFailed } = _a;
                const { LowBytes } = _a;
                const isEndOfIceCycle =
                  type === ConnectionFailed || type === IceGatheringFailed;
                if (
                  !util_1.isChrome(window, window.navigator) &&
                  type === ConnectionFailed
                ) {
                  return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);
                }
                if (_this._status === Call.State.Reconnecting) {
                  if (isEndOfIceCycle) {
                    if (
                      Date.now() - _this._mediaReconnectStartTime >
                      BACKOFF_CONFIG.maxDelay
                    ) {
                      _this._log.info('Exceeded max ICE retries');
                      return _this._mediaHandler.onerror(
                        MEDIA_DISCONNECT_ERROR
                      );
                    }
                    try {
                      _this._mediaReconnectBackoff.backoff();
                    } catch (error) {
                      if (
                        !(
                          error.message &&
                          error.message === 'Backoff in progress.'
                        )
                      ) {
                        throw error;
                      }
                    }
                  }
                  return;
                }
                const { pc } = _this._mediaHandler.version;
                const isIceDisconnected =
                  pc && pc.iceConnectionState === 'disconnected';
                const hasLowBytesWarning =
                  _this._monitor.hasActiveWarning('bytesSent', 'min') ||
                  _this._monitor.hasActiveWarning('bytesReceived', 'min');
                if (
                  (type === LowBytes && isIceDisconnected) ||
                  (type === ConnectionDisconnected && hasLowBytesWarning) ||
                  isEndOfIceCycle
                ) {
                  const mediaReconnectionError =
                    new errors_1.MediaErrors.ConnectionError(
                      'Media connection failed.'
                    );
                  _this._log.warn('ICE Connection disconnected.');
                  _this._publisher.warn(
                    'connection',
                    'error',
                    mediaReconnectionError,
                    _this
                  );
                  _this._publisher.info(
                    'connection',
                    'reconnecting',
                    null,
                    _this
                  );
                  _this._mediaReconnectStartTime = Date.now();
                  _this._status = Call.State.Reconnecting;
                  _this._mediaReconnectBackoff.reset();
                  _this._mediaReconnectBackoff.backoff();
                  _this.emit('reconnecting', mediaReconnectionError);
                }
              };
              _this._onMediaReconnected = function () {
                if (_this._status !== Call.State.Reconnecting) {
                  return;
                }
                _this._log.info('ICE Connection reestablished.');
                _this._publisher.info('connection', 'reconnected', null, _this);
                _this._status = Call.State.Open;
                _this.emit('reconnected');
              };
              _this._onRinging = function (payload) {
                _this._setCallSid(payload);
                if (
                  _this._status !== Call.State.Connecting &&
                  _this._status !== Call.State.Ringing
                ) {
                  return;
                }
                const hasEarlyMedia = Boolean(payload.sdp);
                _this._status = Call.State.Ringing;
                _this._publisher.info(
                  'connection',
                  'outgoing-ringing',
                  { hasEarlyMedia },
                  _this
                );
                _this.emit('ringing', hasEarlyMedia);
              };
              _this._onRTCSample = function (sample) {
                const callMetrics = {
                  ...sample,
                  inputVolume: _this._latestInputVolume,
                  outputVolume: _this._latestOutputVolume,
                };
                _this._codec = callMetrics.codecName;
                _this._metricsSamples.push(callMetrics);
                if (_this._metricsSamples.length >= METRICS_BATCH_SIZE) {
                  _this._publishMetrics();
                }
                _this.emit('sample', sample);
              };
              _this._onTransportClose = function () {
                _this._log.error('Received transportClose from pstream');
                _this.emit('transportClose');
              };
              _this._reemitWarning = function (warningData, wasCleared) {
                const groupPrefix = /^audio/.test(warningData.name)
                  ? 'audio-level-'
                  : 'network-quality-';
                const warningPrefix =
                  WARNING_PREFIXES[warningData.threshold.name];
                let warningName;
                if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {
                  warningName =
                    MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][
                      warningData.threshold.name
                    ];
                } else if (warningData.name in WARNING_NAMES) {
                  warningName = WARNING_NAMES[warningData.name];
                }
                const warning = warningPrefix + warningName;
                _this._emitWarning(
                  groupPrefix,
                  warning,
                  warningData.threshold.value,
                  warningData.values || warningData.value,
                  wasCleared,
                  warningData
                );
              };
              _this._reemitWarningCleared = function (warningData) {
                _this._reemitWarning(warningData, true);
              };
              _this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;
              _this._soundcache = config.soundcache;
              const message = (options && options.twimlParams) || {};
              _this.customParameters = new Map(
                Object.entries(message).map(function (_a) {
                  const key = _a[0];
                  const val = _a[1];
                  return [key, String(val)];
                })
              );
              Object.assign(_this._options, options);
              if (_this._options.callParameters) {
                _this.parameters = _this._options.callParameters;
              }
              _this._direction = _this.parameters.CallSid
                ? Call.CallDirection.Incoming
                : Call.CallDirection.Outgoing;
              if (
                _this._direction === Call.CallDirection.Incoming &&
                _this.parameters
              ) {
                _this.callerInfo = _this.parameters.StirStatus
                  ? {
                      isVerified:
                        _this.parameters.StirStatus ===
                        'TN-Validation-Passed-A',
                    }
                  : null;
              } else {
                _this.callerInfo = null;
              }
              _this._mediaReconnectBackoff =
                Backoff.exponential(BACKOFF_CONFIG);
              _this._mediaReconnectBackoff.on('ready', function () {
                return _this._mediaHandler.iceRestart();
              });
              _this.outboundConnectionId = generateTempCallSid();
              const publisher = (_this._publisher = config.publisher);
              if (_this._direction === Call.CallDirection.Incoming) {
                publisher.info('connection', 'incoming', null, _this);
              } else {
                publisher.info(
                  'connection',
                  'outgoing',
                  { preflight: _this._options.preflight },
                  _this
                );
              }
              const monitor = (_this._monitor = new (_this._options
                .StatsMonitor || statsMonitor_1.default)());
              monitor.on('sample', _this._onRTCSample);
              monitor.disableWarnings();
              setTimeout(function () {
                return monitor.enableWarnings();
              }, METRICS_DELAY);
              monitor.on('warning', function (data, wasCleared) {
                if (
                  data.name === 'bytesSent' ||
                  data.name === 'bytesReceived'
                ) {
                  _this._onMediaFailure(Call.MediaFailure.LowBytes);
                }
                _this._reemitWarning(data, wasCleared);
              });
              monitor.on('warning-cleared', function (data) {
                _this._reemitWarningCleared(data);
              });
              _this._mediaHandler = new _this._options.MediaHandler(
                config.audioHelper,
                config.pstream,
                config.getUserMedia,
                {
                  codecPreferences: _this._options.codecPreferences,
                  dscp: _this._options.dscp,
                  forceAggressiveIceNomination:
                    _this._options.forceAggressiveIceNomination,
                  isUnifiedPlan: _this._isUnifiedPlanDefault,
                  maxAverageBitrate: _this._options.maxAverageBitrate,
                  preflight: _this._options.preflight,
                }
              );
              _this.on('volume', function (inputVolume, outputVolume) {
                _this._inputVolumeStreak = _this._checkVolume(
                  inputVolume,
                  _this._inputVolumeStreak,
                  _this._latestInputVolume,
                  'input'
                );
                _this._outputVolumeStreak = _this._checkVolume(
                  outputVolume,
                  _this._outputVolumeStreak,
                  _this._latestOutputVolume,
                  'output'
                );
                _this._latestInputVolume = inputVolume;
                _this._latestOutputVolume = outputVolume;
              });
              _this._mediaHandler.onvolume = function (
                inputVolume,
                outputVolume,
                internalInputVolume,
                internalOutputVolume
              ) {
                monitor.addVolumes(
                  (internalInputVolume / 255) * 32767,
                  (internalOutputVolume / 255) * 32767
                );
                _this.emit('volume', inputVolume, outputVolume);
              };
              _this._mediaHandler.ondtlstransportstatechange = function (
                state
              ) {
                const level = state === 'failed' ? 'error' : 'debug';
                _this._publisher.post(
                  level,
                  'dtls-transport-state',
                  state,
                  null,
                  _this
                );
              };
              _this._mediaHandler.onpcconnectionstatechange = function (state) {
                let level = 'debug';
                const dtlsTransport = _this._mediaHandler.getRTCDtlsTransport();
                if (state === 'failed') {
                  level =
                    dtlsTransport && dtlsTransport.state === 'failed'
                      ? 'error'
                      : 'warning';
                }
                _this._publisher.post(
                  level,
                  'pc-connection-state',
                  state,
                  null,
                  _this
                );
              };
              _this._mediaHandler.onicecandidate = function (candidate) {
                const payload = new icecandidate_1.IceCandidate(
                  candidate
                ).toPayload();
                _this._publisher.debug(
                  'ice-candidate',
                  'ice-candidate',
                  payload,
                  _this
                );
              };
              _this._mediaHandler.onselectedcandidatepairchange = function (
                pair
              ) {
                const localCandidatePayload = new icecandidate_1.IceCandidate(
                  pair.local
                ).toPayload();
                const remoteCandidatePayload = new icecandidate_1.IceCandidate(
                  pair.remote,
                  true
                ).toPayload();
                _this._publisher.debug(
                  'ice-candidate',
                  'selected-ice-candidate-pair',
                  {
                    local_candidate: localCandidatePayload,
                    remote_candidate: remoteCandidatePayload,
                  },
                  _this
                );
              };
              _this._mediaHandler.oniceconnectionstatechange = function (
                state
              ) {
                const level = state === 'failed' ? 'error' : 'debug';
                _this._publisher.post(
                  level,
                  'ice-connection-state',
                  state,
                  null,
                  _this
                );
              };
              _this._mediaHandler.onicegatheringfailure = function (type) {
                _this._publisher.warn('ice-gathering-state', type, null, _this);
                _this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);
              };
              _this._mediaHandler.onicegatheringstatechange = function (state) {
                _this._publisher.debug(
                  'ice-gathering-state',
                  state,
                  null,
                  _this
                );
              };
              _this._mediaHandler.onsignalingstatechange = function (state) {
                _this._publisher.debug('signaling-state', state, null, _this);
              };
              _this._mediaHandler.ondisconnected = function (msg) {
                _this._log.info(msg);
                _this._publisher.warn(
                  'network-quality-warning-raised',
                  'ice-connectivity-lost',
                  { message: msg },
                  _this
                );
                _this.emit('warning', 'ice-connectivity-lost');
                _this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);
              };
              _this._mediaHandler.onfailed = function (msg) {
                _this._onMediaFailure(Call.MediaFailure.ConnectionFailed);
              };
              _this._mediaHandler.onconnected = function () {
                if (_this._status === Call.State.Reconnecting) {
                  _this._onMediaReconnected();
                }
              };
              _this._mediaHandler.onreconnected = function (msg) {
                _this._log.info(msg);
                _this._publisher.info(
                  'network-quality-warning-cleared',
                  'ice-connectivity-lost',
                  { message: msg },
                  _this
                );
                _this.emit('warning-cleared', 'ice-connectivity-lost');
                _this._onMediaReconnected();
              };
              _this._mediaHandler.onerror = function (e) {
                if (e.disconnect === true) {
                  _this._disconnect(e.info && e.info.message);
                }
                const error =
                  e.info.twilioError ||
                  new errors_1.GeneralErrors.UnknownError(e.info.message);
                _this._log.error('Received an error from MediaStream:', e);
                _this.emit('error', error);
              };
              _this._mediaHandler.onopen = function () {
                if (
                  _this._status === Call.State.Open ||
                  _this._status === Call.State.Reconnecting
                ) {
                } else if (
                  _this._status === Call.State.Ringing ||
                  _this._status === Call.State.Connecting
                ) {
                  _this.mute(false);
                  _this._maybeTransitionToOpen();
                } else {
                  _this._mediaHandler.close();
                }
              };
              _this._mediaHandler.onclose = function () {
                _this._status = Call.State.Closed;
                if (
                  _this._options.shouldPlayDisconnect &&
                  _this._options.shouldPlayDisconnect() &&
                  !_this._isCancelled
                ) {
                  _this._soundcache
                    .get(device_1.default.SoundName.Disconnect)
                    .play();
                }
                monitor.disable();
                _this._publishMetrics();
                if (!_this._isCancelled) {
                  console.info('DISCONNECT!!');
                  _this.emit('disconnect', _this);
                }
              };
              _this._pstream = config.pstream;
              _this._pstream.on('cancel', _this._onCancel);
              _this._pstream.on('ringing', _this._onRinging);
              _this._pstream.on('transportClose', _this._onTransportClose);
              _this.on('error', function (error) {
                _this._publisher.error(
                  'connection',
                  'error',
                  { code: error.code, message: error.message },
                  _this
                );
                if (
                  _this._pstream &&
                  _this._pstream.status === 'disconnected'
                ) {
                  _this._cleanupEventListeners();
                }
              });
              _this.on('disconnect', function () {
                _this._cleanupEventListeners();
              });
              return _this;
            }
            Object.defineProperty(Call.prototype, 'direction', {
              get() {
                return this._direction;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(Call.prototype, 'codec', {
              get() {
                return this._codec;
              },
              enumerable: true,
              configurable: true,
            });
            Call.prototype._setInputTracksFromStream = function (stream) {
              return this._mediaHandler.setInputTracksFromStream(stream);
            };
            Call.prototype._setSinkIds = function (sinkIds) {
              return this._mediaHandler._setSinkIds(sinkIds);
            };
            Call.prototype.accept = function (options) {
              const _this = this;
              if (this._status !== Call.State.Pending) {
                return;
              }
              options = options || {};
              const rtcConfiguration =
                options.rtcConfiguration || this._options.rtcConfiguration;
              const rtcConstraints =
                options.rtcConstraints || this._options.rtcConstraints || {};
              const audioConstraints = rtcConstraints.audio || { audio: true };
              this._status = Call.State.Connecting;
              const connect = function () {
                if (_this._status !== Call.State.Connecting) {
                  _this._cleanupEventListeners();
                  _this._mediaHandler.close();
                  return;
                }
                const onAnswer = function (pc) {
                  const eventName =
                    _this._direction === Call.CallDirection.Incoming
                      ? 'accepted-by-local'
                      : 'accepted-by-remote';
                  _this._publisher.info('connection', eventName, null, _this);
                  const _a = getPreferredCodecInfo(
                    _this._mediaHandler.version.getSDP()
                  );
                  const { codecName } = _a;
                  const { codecParams } = _a;
                  _this._publisher.info(
                    'settings',
                    'codec',
                    { codec_params: codecParams, selected_codec: codecName },
                    _this
                  );
                  _this._monitor.enable(pc);
                };
                const sinkIds =
                  typeof _this._options.getSinkIds === 'function' &&
                  _this._options.getSinkIds();
                if (Array.isArray(sinkIds)) {
                  _this._mediaHandler
                    ._setSinkIds(sinkIds)
                    .catch(function () {});
                }
                _this._pstream.addListener('hangup', _this._onHangup);
                if (_this._direction === Call.CallDirection.Incoming) {
                  _this._isAnswered = true;
                  _this._mediaHandler.answerIncomingCall(
                    _this.parameters.CallSid,
                    _this._options.offerSdp,
                    rtcConstraints,
                    rtcConfiguration,
                    onAnswer
                  );
                } else {
                  const params = Array.from(_this.customParameters.entries())
                    .map(function (pair) {
                      return `${encodeURIComponent(
                        pair[0]
                      )}=${encodeURIComponent(pair[1])}`;
                    })
                    .join('&');
                  _this._pstream.once('answer', _this._onAnswer.bind(_this));
                  _this._mediaHandler.makeOutgoingCall(
                    _this._pstream.token,
                    params,
                    _this.outboundConnectionId,
                    rtcConstraints,
                    rtcConfiguration,
                    onAnswer
                  );
                }
              };
              if (this._options.beforeAccept) {
                this._options.beforeAccept(this);
              }
              const inputStream =
                typeof this._options.getInputStream === 'function' &&
                this._options.getInputStream();
              const promise = inputStream
                ? this._mediaHandler.setInputTracksFromStream(inputStream)
                : this._mediaHandler.openWithConstraints(audioConstraints);
              promise.then(
                function () {
                  _this._publisher.info(
                    'get-user-media',
                    'succeeded',
                    { data: { audioConstraints } },
                    _this
                  );
                  connect();
                },
                function (error) {
                  let twilioError;
                  if (
                    error.code === 31208 ||
                    ['PermissionDeniedError', 'NotAllowedError'].indexOf(
                      error.name
                    ) !== -1
                  ) {
                    twilioError =
                      new errors_1.UserMediaErrors.PermissionDeniedError();
                    _this._publisher.error(
                      'get-user-media',
                      'denied',
                      {
                        data: {
                          audioConstraints,
                          error,
                        },
                      },
                      _this
                    );
                  } else {
                    twilioError =
                      new errors_1.UserMediaErrors.AcquisitionFailedError();
                    _this._publisher.error(
                      'get-user-media',
                      'failed',
                      {
                        data: {
                          audioConstraints,
                          error,
                        },
                      },
                      _this
                    );
                  }
                  _this._disconnect();
                  _this.emit('error', twilioError);
                }
              );
            };
            Call.prototype.disconnect = function () {
              this._disconnect();
            };
            Call.prototype.getLocalStream = function () {
              return this._mediaHandler && this._mediaHandler.stream;
            };
            Call.prototype.getRemoteStream = function () {
              return this._mediaHandler && this._mediaHandler._remoteStream;
            };
            Call.prototype.ignore = function () {
              if (this._status !== Call.State.Pending) {
                return;
              }
              this._status = Call.State.Closed;
              this._mediaHandler.ignore(this.parameters.CallSid);
              this._publisher.info(
                'connection',
                'ignored-by-local',
                null,
                this
              );
            };
            Call.prototype.isMuted = function () {
              return this._mediaHandler.isMuted;
            };
            Call.prototype.mute = function (shouldMute) {
              if (shouldMute === void 0) {
                shouldMute = true;
              }
              const wasMuted = this._mediaHandler.isMuted;
              this._mediaHandler.mute(shouldMute);
              const { isMuted } = this._mediaHandler;
              if (wasMuted !== isMuted) {
                this._publisher.info(
                  'connection',
                  isMuted ? 'muted' : 'unmuted',
                  null,
                  this
                );
                this.emit('mute', isMuted, this);
              }
            };
            Call.prototype.postFeedback = function (score, issue) {
              if (typeof score === 'undefined' || score === null) {
                return this._postFeedbackDeclined();
              }
              if (!Object.values(Call.FeedbackScore).includes(score)) {
                throw new errors_1.InvalidArgumentError(
                  `Feedback score must be one of: ${Object.values(
                    Call.FeedbackScore
                  )}`
                );
              }
              if (
                typeof issue !== 'undefined' &&
                issue !== null &&
                !Object.values(Call.FeedbackIssue).includes(issue)
              ) {
                throw new errors_1.InvalidArgumentError(
                  `Feedback issue must be one of: ${Object.values(
                    Call.FeedbackIssue
                  )}`
                );
              }
              return this._publisher.info(
                'feedback',
                'received',
                { issue_name: issue, quality_score: score },
                this,
                true
              );
            };
            Call.prototype.reject = function () {
              if (this._status !== Call.State.Pending) {
                return;
              }
              this._pstream.reject(this.parameters.CallSid);
              this._status = Call.State.Closed;
              this.emit('reject');
              this._mediaHandler.reject(this.parameters.CallSid);
              this._publisher.info(
                'connection',
                'rejected-by-local',
                null,
                this
              );
            };
            Call.prototype.sendDigits = function (digits) {
              if (digits.match(/[^0-9*#w]/)) {
                throw new errors_1.InvalidArgumentError(
                  'Illegal character passed into sendDigits'
                );
              }
              const sequence = [];
              digits.split('').forEach(function (digit) {
                let dtmf = digit !== 'w' ? `dtmf${digit}` : '';
                if (dtmf === 'dtmf*') {
                  dtmf = 'dtmfs';
                }
                if (dtmf === 'dtmf#') {
                  dtmf = 'dtmfh';
                }
                sequence.push(dtmf);
              });
              (function playNextDigit(soundCache, dialtonePlayer) {
                const digit = sequence.shift();
                if (digit) {
                  if (dialtonePlayer) {
                    dialtonePlayer.play(digit);
                  } else {
                    soundCache.get(digit).play();
                  }
                }
                if (sequence.length) {
                  setTimeout(playNextDigit.bind(null, soundCache), 200);
                }
              })(this._soundcache, this._options.dialtonePlayer);
              const dtmfSender = this._mediaHandler.getOrCreateDTMFSender();
              function insertDTMF(dtmfs) {
                if (!dtmfs.length) {
                  return;
                }
                const dtmf = dtmfs.shift();
                if (dtmf && dtmf.length) {
                  dtmfSender.insertDTMF(
                    dtmf,
                    DTMF_TONE_DURATION,
                    DTMF_INTER_TONE_GAP
                  );
                }
                setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);
              }
              if (dtmfSender) {
                if (
                  !('canInsertDTMF' in dtmfSender) ||
                  dtmfSender.canInsertDTMF
                ) {
                  this._log.info('Sending digits using RTCDTMFSender');
                  insertDTMF(digits.split('w'));
                  return;
                }
                this._log.info('RTCDTMFSender cannot insert DTMF');
              }
              this._log.info('Sending digits over PStream');
              if (
                this._pstream !== null &&
                this._pstream.status !== 'disconnected'
              ) {
                this._pstream.dtmf(this.parameters.CallSid, digits);
              } else {
                const error = new errors_1.GeneralErrors.ConnectionError(
                  'Could not send DTMF: Signaling channel is disconnected'
                );
                this.emit('error', error);
              }
            };
            Call.prototype.status = function () {
              return this._status;
            };
            Call.prototype._checkVolume = function (
              currentVolume,
              currentStreak,
              lastValue,
              direction
            ) {
              const wasWarningRaised = currentStreak >= 10;
              let newStreak = 0;
              if (lastValue === currentVolume) {
                newStreak = currentStreak;
              }
              if (newStreak >= 10) {
                this._emitWarning(
                  'audio-level-',
                  `constant-audio-${direction}-level`,
                  10,
                  newStreak,
                  false
                );
              } else if (wasWarningRaised) {
                this._emitWarning(
                  'audio-level-',
                  `constant-audio-${direction}-level`,
                  10,
                  newStreak,
                  true
                );
              }
              return newStreak;
            };
            Call.prototype._cleanupEventListeners = function () {
              const _this = this;
              const cleanup = function () {
                if (!_this._pstream) {
                  return;
                }
                _this._pstream.removeListener('answer', _this._onAnswer);
                _this._pstream.removeListener('cancel', _this._onCancel);
                _this._pstream.removeListener('hangup', _this._onHangup);
                _this._pstream.removeListener('ringing', _this._onRinging);
                _this._pstream.removeListener(
                  'transportClose',
                  _this._onTransportClose
                );
              };
              cleanup();
              setTimeout(cleanup, 0);
            };
            Call.prototype._createMetricPayload = function () {
              const payload = {
                call_sid: this.parameters.CallSid,
                dscp: Boolean(this._options.dscp),
                sdk_version: C.RELEASE_VERSION,
                selected_region: this._options.selectedRegion,
              };
              if (this._options.gateway) {
                payload.gateway = this._options.gateway;
              }
              if (this._options.region) {
                payload.region = this._options.region;
              }
              payload.direction = this._direction;
              return payload;
            };
            Call.prototype._disconnect = function (message, wasRemote) {
              message = typeof message === 'string' ? message : null;
              if (
                this._status !== Call.State.Open &&
                this._status !== Call.State.Connecting &&
                this._status !== Call.State.Reconnecting &&
                this._status !== Call.State.Ringing
              ) {
                return;
              }
              this._log.info('Disconnecting...');
              if (
                this._pstream !== null &&
                this._pstream.status !== 'disconnected' &&
                this._shouldSendHangup
              ) {
                const callsid =
                  this.parameters.CallSid || this.outboundConnectionId;
                if (callsid) {
                  this._pstream.hangup(callsid, message);
                }
              }
              this._cleanupEventListeners();
              this._mediaHandler.close();
              if (!wasRemote) {
                this._publisher.info(
                  'connection',
                  'disconnected-by-local',
                  null,
                  this
                );
              }
            };
            Call.prototype._maybeTransitionToOpen = function () {
              if (
                this._mediaHandler &&
                this._mediaHandler.status === 'open' &&
                this._isAnswered
              ) {
                this._status = Call.State.Open;
                this.emit('accept', this);
              }
            };
            Call.prototype._postFeedbackDeclined = function () {
              return this._publisher.info(
                'feedback',
                'received-none',
                null,
                this,
                true
              );
            };
            Call.prototype._publishMetrics = function () {
              const _this = this;
              if (this._metricsSamples.length === 0) {
                return;
              }
              this._publisher
                .postMetrics(
                  'quality-metrics-samples',
                  'metrics-sample',
                  this._metricsSamples.splice(0),
                  this._createMetricPayload(),
                  this
                )
                .catch(function (e) {
                  _this._log.warn(
                    'Unable to post metrics to Insights. Received error:',
                    e
                  );
                });
            };
            Call.prototype._setCallSid = function (payload) {
              const callSid = payload.callsid;
              if (!callSid) {
                return;
              }
              this.parameters.CallSid = callSid;
              this._mediaHandler.callSid = callSid;
            };
            Call.toString = function () {
              return '[Twilio.Call class]';
            };
            return Call;
          })(events_1.EventEmitter);
          (function (Call) {
            let State;
            (function (State) {
              State.Closed = 'closed';
              State.Connecting = 'connecting';
              State.Open = 'open';
              State.Pending = 'pending';
              State.Reconnecting = 'reconnecting';
              State.Ringing = 'ringing';
            })((State = Call.State || (Call.State = {})));
            let FeedbackIssue;
            (function (FeedbackIssue) {
              FeedbackIssue.AudioLatency = 'audio-latency';
              FeedbackIssue.ChoppyAudio = 'choppy-audio';
              FeedbackIssue.DroppedCall = 'dropped-call';
              FeedbackIssue.Echo = 'echo';
              FeedbackIssue.NoisyCall = 'noisy-call';
              FeedbackIssue.OneWayAudio = 'one-way-audio';
            })(
              (FeedbackIssue = Call.FeedbackIssue || (Call.FeedbackIssue = {}))
            );
            let FeedbackScore;
            (function (FeedbackScore) {
              FeedbackScore[(FeedbackScore.One = 1)] = 'One';
              FeedbackScore[(FeedbackScore.Two = 2)] = 'Two';
              FeedbackScore[(FeedbackScore.Three = 3)] = 'Three';
              FeedbackScore[(FeedbackScore.Four = 4)] = 'Four';
              FeedbackScore[(FeedbackScore.Five = 5)] = 'Five';
            })(
              (FeedbackScore = Call.FeedbackScore || (Call.FeedbackScore = {}))
            );
            let CallDirection;
            (function (CallDirection) {
              CallDirection.Incoming = 'INCOMING';
              CallDirection.Outgoing = 'OUTGOING';
            })(
              (CallDirection = Call.CallDirection || (Call.CallDirection = {}))
            );
            let Codec;
            (function (Codec) {
              Codec.Opus = 'opus';
              Codec.PCMU = 'pcmu';
            })((Codec = Call.Codec || (Call.Codec = {})));
            let IceGatheringFailureReason;
            (function (IceGatheringFailureReason) {
              IceGatheringFailureReason.None = 'none';
              IceGatheringFailureReason.Timeout = 'timeout';
            })(
              (IceGatheringFailureReason =
                Call.IceGatheringFailureReason ||
                (Call.IceGatheringFailureReason = {}))
            );
            let MediaFailure;
            (function (MediaFailure) {
              MediaFailure.ConnectionDisconnected = 'ConnectionDisconnected';
              MediaFailure.ConnectionFailed = 'ConnectionFailed';
              MediaFailure.IceGatheringFailed = 'IceGatheringFailed';
              MediaFailure.LowBytes = 'LowBytes';
            })((MediaFailure = Call.MediaFailure || (Call.MediaFailure = {})));
          })(Call || (Call = {}));
          function generateTempCallSid() {
            return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(
              /[xy]/g,
              function (c) {
                const r = (Math.random() * 16) | 0;
                const v = c === 'x' ? r : (r & 3) | 8;
                return v.toString(16);
              }
            );
          }
          exports.default = Call;
        },
        {
          './constants': 7,
          './device': 9,
          './errors': 12,
          './log': 15,
          './rtc': 23,
          './rtc/icecandidate': 22,
          './rtc/sdp': 28,
          './statsMonitor': 34,
          './util': 35,
          backoff: 42,
          events: 48,
        },
      ],
      7: [
        function (require, module, exports) {
          const PACKAGE_NAME = '@twilio/voice-sdk';
          const RELEASE_VERSION = '2.0.1';
          const SOUNDS_BASE_URL =
            'https://sdk.twilio.com/js/client/sounds/releases/1.0.0';
          module.exports.COWBELL_AUDIO_URL = `${SOUNDS_BASE_URL}/cowbell.mp3?cache=${RELEASE_VERSION}`;
          module.exports.ECHO_TEST_DURATION = 2e4;
          module.exports.PACKAGE_NAME = PACKAGE_NAME;
          module.exports.RELEASE_VERSION = RELEASE_VERSION;
          module.exports.SOUNDS_BASE_URL = SOUNDS_BASE_URL;
          module.exports.USED_ERRORS = [
            'AuthorizationErrors.AccessTokenExpired',
            'AuthorizationErrors.AccessTokenInvalid',
            'AuthorizationErrors.AuthenticationFailed',
            'ClientErrors.BadRequest',
            'GeneralErrors.CallCancelledError',
            'GeneralErrors.ConnectionError',
            'GeneralErrors.TransportError',
            'GeneralErrors.UnknownError',
            'MediaErrors.ClientLocalDescFailed',
            'MediaErrors.ClientRemoteDescFailed',
            'MediaErrors.ConnectionError',
            'SignalingErrors.ConnectionDisconnected',
            'SignalingErrors.ConnectionError',
            'UserMediaErrors.PermissionDeniedError',
            'UserMediaErrors.AcquisitionFailedError',
          ];
        },
        {},
      ],
      8: [
        function (require, module, exports) {
          Object.defineProperty(exports, '__esModule', { value: true });
          const Deferred = (function () {
            function Deferred() {
              const _this = this;
              this._promise = new Promise(function (resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
              });
            }
            Object.defineProperty(Deferred.prototype, 'promise', {
              get() {
                return this._promise;
              },
              enumerable: true,
              configurable: true,
            });
            Deferred.prototype.reject = function (reason) {
              this._reject(reason);
            };
            Deferred.prototype.resolve = function (value) {
              this._resolve(value);
            };
            return Deferred;
          })();
          exports.default = Deferred;
        },
        {},
      ],
      9: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          var __assign =
            (this && this.__assign) ||
            function () {
              __assign =
                Object.assign ||
                function (t) {
                  for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (const p in s)
                      if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
                  }
                  return t;
                };
              return __assign.apply(this, arguments);
            };
          const __awaiter =
            (this && this.__awaiter) ||
            function (thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P
                  ? value
                  : new P(function (resolve) {
                      resolve(value);
                    });
              }
              return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator.throw(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step(result) {
                  result.done
                    ? resolve(result.value)
                    : adopt(result.value).then(fulfilled, rejected);
                }
                step(
                  (generator = generator.apply(
                    thisArg,
                    _arguments || []
                  )).next()
                );
              });
            };
          const __generator =
            (this && this.__generator) ||
            function (thisArg, body) {
              let _ = {
                label: 0,
                sent() {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                },
                trys: [],
                ops: [],
              };
              let f;
              let y;
              let t;
              let g;
              return (
                (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                typeof Symbol === 'function' &&
                  (g[Symbol.iterator] = function () {
                    return this;
                  }),
                g
              );
              function verb(n) {
                return function (v) {
                  return step([n, v]);
                };
              }
              function step(op) {
                if (f) throw new TypeError('Generator is already executing.');
                while (_)
                  try {
                    if (
                      ((f = 1),
                      y &&
                        (t =
                          op[0] & 2
                            ? y.return
                            : op[0]
                            ? y.throw || ((t = y.return) && t.call(y), 0)
                            : y.next) &&
                        !(t = t.call(y, op[1])).done)
                    )
                      return t;
                    if (((y = 0), t)) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (
                          !((t = _.trys),
                          (t = t.length > 0 && t[t.length - 1])) &&
                          (op[0] === 6 || op[0] === 2)
                        ) {
                          _ = 0;
                          continue;
                        }
                        if (
                          op[0] === 3 &&
                          (!t || (op[1] > t[0] && op[1] < t[3]))
                        ) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1];
                          t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    op = [6, e];
                    y = 0;
                  } finally {
                    f = t = 0;
                  }
                if (op[0] & 5) throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            };
          Object.defineProperty(exports, '__esModule', { value: true });
          const events_1 = require('events');
          const loglevel_1 = require('loglevel');
          const audiohelper_1 = require('./audiohelper');
          const call_1 = require('./call');
          const dialtonePlayer_1 = require('./dialtonePlayer');
          const errors_1 = require('./errors');
          const log_1 = require('./log');
          const preflight_1 = require('./preflight/preflight');
          const regions_1 = require('./regions');
          const util_1 = require('./util');
          const C = require('./constants');
          const Publisher = require('./eventpublisher');
          const PStream = require('./pstream');
          const rtc = require('./rtc');
          const getUserMedia = require('./rtc/getusermedia');
          const Sound = require('./sound');
          const REGISTRATION_INTERVAL = 3e4;
          const RINGTONE_PLAY_TIMEOUT = 2e3;
          const PUBLISHER_PRODUCT_NAME = 'twilio-js-sdk';
          const INVALID_TOKEN_MESSAGE =
            'Parameter "token" must be of type "string".';
          let Device = (function (_super) {
            __extends(Device, _super);
            function Device(token, options) {
              let _a;
              let _b;
              if (options === void 0) {
                options = {};
              }
              const _this = _super.call(this) || this;
              _this._activeCall = null;
              _this._audio = null;
              _this._callInputStream = null;
              _this._calls = [];
              _this._callSinkIds = ['default'];
              _this._chunderURIs = [];
              _this._defaultOptions = {
                allowIncomingWhileBusy: false,
                closeProtection: false,
                codecPreferences: [
                  call_1.default.Codec.PCMU,
                  call_1.default.Codec.Opus,
                ],
                dscp: true,
                eventgw: 'eventgw.twilio.com',
                forceAggressiveIceNomination: false,
                logLevel: loglevel_1.levels.ERROR,
                preflight: false,
                sounds: {},
              };
              _this._edge = null;
              _this._enabledSounds =
                ((_a = {}),
                (_a[Device.SoundName.Disconnect] = true),
                (_a[Device.SoundName.Incoming] = true),
                (_a[Device.SoundName.Outgoing] = true),
                _a);
              _this._log = log_1.default.getInstance();
              _this._options = {};
              _this._publisher = null;
              _this._region = null;
              _this._regTimer = null;
              _this._shouldReRegister = false;
              _this._soundcache = new Map();
              _this._state = Device.State.Unregistered;
              _this._stateEventMapping =
                ((_b = {}),
                (_b[Device.State.Destroyed] = Device.EventName.Destroyed),
                (_b[Device.State.Unregistered] = Device.EventName.Unregistered),
                (_b[Device.State.Registering] = Device.EventName.Registering),
                (_b[Device.State.Registered] = Device.EventName.Registered),
                _b);
              _this._stream = null;
              _this._streamConnectedPromise = null;
              _this._createDefaultPayload = function (call) {
                const payload = {
                  aggressive_nomination:
                    _this._options.forceAggressiveIceNomination,
                  browser_extension: _this._isBrowserExtension,
                  dscp: Boolean(_this._options.dscp),
                  ice_restart_enabled: true,
                  platform: rtc.getMediaEngine(),
                  sdk_version: C.RELEASE_VERSION,
                };
                function setIfDefined(propertyName, value) {
                  if (value) {
                    payload[propertyName] = value;
                  }
                }
                if (call) {
                  const callSid = call.parameters.CallSid;
                  setIfDefined(
                    'call_sid',
                    /^TJ/.test(callSid) ? undefined : callSid
                  );
                  setIfDefined('temp_call_sid', call.outboundConnectionId);
                  setIfDefined('audio_codec', call.codec);
                  payload.direction = call.direction;
                }
                setIfDefined('gateway', _this._stream && _this._stream.gateway);
                setIfDefined('region', _this._stream && _this._stream.region);
                return payload;
              };
              _this._onSignalingClose = function () {
                _this._stream = null;
                _this._streamConnectedPromise = null;
              };
              _this._onSignalingConnected = function (payload) {
                const region = regions_1.getRegionShortcode(payload.region);
                _this._edge = regions_1.regionToEdge[region] || payload.region;
                _this._region = region || payload.region;
                if (_this._shouldReRegister) {
                  _this.register();
                }
              };
              _this._onSignalingError = function (payload) {
                if (typeof payload !== 'object') {
                  return;
                }
                const originalError = payload.error;
                const { callsid } = payload;
                if (typeof originalError !== 'object') {
                  return;
                }
                const call =
                  (typeof callsid === 'string' && _this._findCall(callsid)) ||
                  undefined;
                const { code } = originalError;
                const customMessage = originalError.message;
                let { twilioError } = originalError;
                if (typeof code === 'number') {
                  if (code === 31201) {
                    twilioError =
                      new errors_1.AuthorizationErrors.AuthenticationFailed(
                        originalError
                      );
                  } else if (code === 31204) {
                    twilioError =
                      new errors_1.AuthorizationErrors.AccessTokenInvalid(
                        originalError
                      );
                  } else if (code === 31205) {
                    _this._stopRegistrationTimer();
                    twilioError =
                      new errors_1.AuthorizationErrors.AccessTokenExpired(
                        originalError
                      );
                  } else if (errors_1.hasErrorByCode(code)) {
                    twilioError = new (errors_1.getErrorByCode(code))(
                      originalError
                    );
                  }
                }
                if (!twilioError) {
                  _this._log.error('Unknown signaling error: ', originalError);
                  twilioError = new errors_1.GeneralErrors.UnknownError(
                    customMessage,
                    originalError
                  );
                }
                _this._log.info('Received error: ', twilioError);
                _this.emit(Device.EventName.Error, twilioError, call);
              };
              _this._onSignalingInvite = function (payload) {
                return __awaiter(_this, void 0, void 0, function () {
                  let wasBusy;
                  let callParameters;
                  let customParameters;
                  let call;
                  let play;
                  const _this = this;
                  return __generator(this, function (_a) {
                    switch (_a.label) {
                      case 0:
                        wasBusy = Boolean(this._activeCall);
                        if (wasBusy && !this._options.allowIncomingWhileBusy) {
                          this._log.info(
                            'Device busy; ignoring incoming invite'
                          );
                          return [2];
                        }
                        if (!payload.callsid || !payload.sdp) {
                          this.emit(
                            Device.EventName.Error,
                            new errors_1.ClientErrors.BadRequest(
                              'Malformed invite from gateway'
                            )
                          );
                          return [2];
                        }
                        callParameters = payload.parameters || {};
                        callParameters.CallSid =
                          callParameters.CallSid || payload.callsid;
                        customParameters = {
                          ...util_1.queryToJson(callParameters.Params),
                        };
                        return [
                          4,
                          this._makeCall(customParameters, {
                            callParameters,
                            offerSdp: payload.sdp,
                          }),
                        ];
                      case 1:
                        call = _a.sent();
                        this._calls.push(call);
                        call.once('accept', function () {
                          _this._soundcache
                            .get(Device.SoundName.Incoming)
                            .stop();
                          _this._publishNetworkChange();
                        });
                        play =
                          this._enabledSounds.incoming && !wasBusy
                            ? function () {
                                return _this._soundcache
                                  .get(Device.SoundName.Incoming)
                                  .play();
                              }
                            : function () {
                                return Promise.resolve();
                              };
                        this._showIncomingCall(call, play);
                        return [2];
                    }
                  });
                });
              };
              _this._onSignalingOffline = function () {
                _this._log.info('Stream is offline');
                _this._edge = null;
                _this._region = null;
                _this._shouldReRegister =
                  _this.state !== Device.State.Unregistered;
                _this._setState(Device.State.Unregistered);
              };
              _this._onSignalingReady = function () {
                _this._log.info('Stream is ready');
                _this._setState(Device.State.Registered);
              };
              _this._publishNetworkChange = function () {
                if (!_this._activeCall) {
                  return;
                }
                if (_this._networkInformation) {
                  _this._publisher.info(
                    'network-information',
                    'network-change',
                    {
                      connection_type: _this._networkInformation.type,
                      downlink: _this._networkInformation.downlink,
                      downlinkMax: _this._networkInformation.downlinkMax,
                      effective_type: _this._networkInformation.effectiveType,
                      rtt: _this._networkInformation.rtt,
                    },
                    _this._activeCall
                  );
                }
              };
              _this._updateInputStream = function (inputStream) {
                const call = _this._activeCall;
                if (call && !inputStream) {
                  return Promise.reject(
                    new errors_1.InvalidStateError(
                      'Cannot unset input device while a call is in progress.'
                    )
                  );
                }
                _this._callInputStream = inputStream;
                return call
                  ? call._setInputTracksFromStream(inputStream)
                  : Promise.resolve();
              };
              _this._updateSinkIds = function (type, sinkIds) {
                const promise =
                  type === 'ringtone'
                    ? _this._updateRingtoneSinkIds(sinkIds)
                    : _this._updateSpeakerSinkIds(sinkIds);
                return promise.then(
                  function () {
                    _this._publisher.info(
                      'audio',
                      `${type}-devices-set`,
                      { audio_device_ids: sinkIds },
                      _this._activeCall
                    );
                  },
                  function (error) {
                    _this._publisher.error(
                      'audio',
                      `${type}-devices-set-failed`,
                      { audio_device_ids: sinkIds, message: error.message },
                      _this._activeCall
                    );
                    throw error;
                  }
                );
              };
              _this.updateToken(token);
              if (util_1.isLegacyEdge()) {
                throw new errors_1.NotSupportedError(
                  'Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' +
                    'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' +
                    'Please see this documentation for a list of supported browsers ' +
                    'https://www.twilio.com/docs/voice/client/javascript#supported-browsers'
                );
              }
              if (!Device.isSupported && options.ignoreBrowserSupport) {
                if (
                  window &&
                  window.location &&
                  window.location.protocol === 'http:'
                ) {
                  throw new errors_1.NotSupportedError(
                    "twilio.js wasn't able to find WebRTC browser support.           This is most likely because this page is served over http rather than https,           which does not support WebRTC in many browsers. Please load this page over https and           try again."
                  );
                }
                throw new errors_1.NotSupportedError(
                  'twilio.js 1.3+ SDKs require WebRTC browser support.         For more information, see <https://www.twilio.com/docs/api/client/twilio-js>.         If you have any questions about this announcement, please contact         Twilio Support at <help@twilio.com>.'
                );
              }
              if (window) {
                const root = window;
                const browser = root.msBrowser || root.browser || root.chrome;
                _this._isBrowserExtension =
                  (Boolean(browser) &&
                    Boolean(browser.runtime) &&
                    Boolean(browser.runtime.id)) ||
                  (Boolean(root.safari) && Boolean(root.safari.extension));
              }
              if (_this._isBrowserExtension) {
                _this._log.info('Running as browser extension.');
              }
              if (navigator) {
                const n = navigator;
                _this._networkInformation =
                  n.connection || n.mozConnection || n.webkitConnection;
              }
              if (
                _this._networkInformation &&
                typeof _this._networkInformation.addEventListener === 'function'
              ) {
                _this._networkInformation.addEventListener(
                  'change',
                  _this._publishNetworkChange
                );
              }
              Device._getOrCreateAudioContext();
              if (Device._audioContext) {
                if (!Device._dialtonePlayer) {
                  Device._dialtonePlayer = new dialtonePlayer_1.default(
                    Device._audioContext
                  );
                }
              }
              if (typeof Device._isUnifiedPlanDefault === 'undefined') {
                Device._isUnifiedPlanDefault =
                  typeof window !== 'undefined' &&
                  typeof RTCPeerConnection !== 'undefined' &&
                  typeof RTCRtpTransceiver !== 'undefined'
                    ? util_1.isUnifiedPlanDefault(
                        window,
                        window.navigator,
                        RTCPeerConnection,
                        RTCRtpTransceiver
                      )
                    : false;
              }
              _this._boundDestroy = _this.destroy.bind(_this);
              _this._boundConfirmClose = _this._confirmClose.bind(_this);
              if (typeof window !== 'undefined' && window.addEventListener) {
                window.addEventListener('unload', _this._boundDestroy);
                window.addEventListener('pagehide', _this._boundDestroy);
              }
              _this.updateOptions(options);
              return _this;
            }
            Object.defineProperty(Device, 'audioContext', {
              get() {
                return Device._audioContext;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(Device, 'extension', {
              get() {
                const a =
                  typeof document !== 'undefined'
                    ? document.createElement('audio')
                    : { canPlayType: false };
                let canPlayMp3;
                try {
                  canPlayMp3 =
                    a.canPlayType &&
                    Boolean(a.canPlayType('audio/mpeg').replace(/no/, ''));
                } catch (e) {
                  canPlayMp3 = false;
                }
                let canPlayVorbis;
                try {
                  canPlayVorbis =
                    a.canPlayType &&
                    Boolean(
                      a
                        .canPlayType("audio/ogg;codecs='vorbis'")
                        .replace(/no/, '')
                    );
                } catch (e) {
                  canPlayVorbis = false;
                }
                return canPlayVorbis && !canPlayMp3 ? 'ogg' : 'mp3';
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(Device, 'isSupported', {
              get() {
                return rtc.enabled();
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(Device, 'packageName', {
              get() {
                return C.PACKAGE_NAME;
              },
              enumerable: true,
              configurable: true,
            });
            Device.runPreflight = function (token, options) {
              return new preflight_1.PreflightTest(token, {
                audioContext: Device._getOrCreateAudioContext(),
                ...options,
              });
            };
            Device.toString = function () {
              return '[Twilio.Device class]';
            };
            Object.defineProperty(Device, 'version', {
              get() {
                return C.RELEASE_VERSION;
              },
              enumerable: true,
              configurable: true,
            });
            Device._getOrCreateAudioContext = function () {
              if (!Device._audioContext) {
                if (typeof AudioContext !== 'undefined') {
                  Device._audioContext = new AudioContext();
                } else if (typeof webkitAudioContext !== 'undefined') {
                  Device._audioContext = new webkitAudioContext();
                }
              }
              return Device._audioContext;
            };
            Object.defineProperty(Device.prototype, 'audio', {
              get() {
                return this._audio;
              },
              enumerable: true,
              configurable: true,
            });
            Device.prototype.connect = function (options) {
              if (options === void 0) {
                options = {};
              }
              return __awaiter(this, void 0, void 0, function () {
                let activeCall;
                let _a;
                return __generator(this, function (_b) {
                  switch (_b.label) {
                    case 0:
                      this._throwIfDestroyed();
                      if (this._activeCall) {
                        throw new errors_1.InvalidStateError(
                          'A Call is already active'
                        );
                      }
                      _a = this;
                      return [
                        4,
                        this._makeCall(options.params || {}, {
                          rtcConfiguration: options.rtcConfiguration,
                        }),
                      ];
                    case 1:
                      activeCall = _a._activeCall = _b.sent();
                      this._calls.splice(0).forEach(function (call) {
                        return call.ignore();
                      });
                      this._soundcache.get(Device.SoundName.Incoming).stop();
                      activeCall.accept({
                        rtcConstraints: options.rtcConstraints,
                      });
                      this._publishNetworkChange();
                      return [2, activeCall];
                  }
                });
              });
            };
            Object.defineProperty(Device.prototype, 'calls', {
              get() {
                return this._calls;
              },
              enumerable: true,
              configurable: true,
            });
            Device.prototype.destroy = function () {
              this.disconnectAll();
              this._stopRegistrationTimer();
              if (this._audio) {
                this._audio._unbind();
              }
              this._destroyStream();
              this._destroyPublisher();
              this._destroyAudioHelper();
              if (
                this._networkInformation &&
                typeof this._networkInformation.removeEventListener ===
                  'function'
              ) {
                this._networkInformation.removeEventListener(
                  'change',
                  this._publishNetworkChange
                );
              }
              if (typeof window !== 'undefined' && window.removeEventListener) {
                window.removeEventListener(
                  'beforeunload',
                  this._boundConfirmClose
                );
                window.removeEventListener('unload', this._boundDestroy);
                window.removeEventListener('pagehide', this._boundDestroy);
              }
              this._setState(Device.State.Destroyed);
            };
            Device.prototype.disconnectAll = function () {
              const calls = this._calls.splice(0);
              calls.forEach(function (call) {
                return call.disconnect();
              });
              if (this._activeCall) {
                this._activeCall.disconnect();
              }
            };
            Object.defineProperty(Device.prototype, 'edge', {
              get() {
                return this._edge;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(Device.prototype, 'isBusy', {
              get() {
                return Boolean(this._activeCall);
              },
              enumerable: true,
              configurable: true,
            });
            Device.prototype.register = function () {
              return __awaiter(this, void 0, void 0, function () {
                let stream;
                let streamReadyPromise;
                const _this = this;
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      if (this.state !== Device.State.Unregistered) {
                        throw new errors_1.InvalidStateError(
                          `Attempt to register when device is in state "${this.state}". ` +
                            `Must be "${Device.State.Unregistered}".`
                        );
                      }
                      this._setState(Device.State.Registering);
                      return [
                        4,
                        this._streamConnectedPromise || this._setupStream(),
                      ];
                    case 1:
                      stream = _a.sent();
                      streamReadyPromise = new Promise(function (resolve) {
                        _this.once(Device.State.Registered, resolve);
                      });
                      return [4, this._sendPresence(true)];
                    case 2:
                      _a.sent();
                      return [4, streamReadyPromise];
                    case 3:
                      _a.sent();
                      return [2];
                  }
                });
              });
            };
            Object.defineProperty(Device.prototype, 'state', {
              get() {
                return this._state;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(Device.prototype, 'token', {
              get() {
                return this._token;
              },
              enumerable: true,
              configurable: true,
            });
            Device.prototype.toString = function () {
              return '[Twilio.Device instance]';
            };
            Device.prototype.unregister = function () {
              return __awaiter(this, void 0, void 0, function () {
                let stream;
                let streamOfflinePromise;
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      if (this.state !== Device.State.Registered) {
                        throw new errors_1.InvalidStateError(
                          `Attempt to unregister when device is in state "${this.state}". ` +
                            `Must be "${Device.State.Registered}".`
                        );
                      }
                      this._shouldReRegister = false;
                      return [4, this._streamConnectedPromise];
                    case 1:
                      stream = _a.sent();
                      streamOfflinePromise = new Promise(function (resolve) {
                        stream.on('offline', resolve);
                      });
                      return [4, this._sendPresence(false)];
                    case 2:
                      _a.sent();
                      return [4, streamOfflinePromise];
                    case 3:
                      _a.sent();
                      return [2];
                  }
                });
              });
            };
            Device.prototype.updateOptions = function (options) {
              if (options === void 0) {
                options = {};
              }
              if (this.state === Device.State.Destroyed) {
                throw new errors_1.InvalidStateError(
                  `Attempt to "updateOptions" when device is in state "${this.state}".`
                );
              }
              this._options = {
                ...this._defaultOptions,
                ...this._options,
                ...options,
              };
              const originalChunderURIs = new Set(this._chunderURIs);
              const chunderw =
                typeof this._options.chunderw === 'string'
                  ? [this._options.chunderw]
                  : Array.isArray(this._options.chunderw) &&
                    this._options.chunderw;
              const newChunderURIs = (this._chunderURIs = (
                chunderw ||
                regions_1.getChunderURIs(
                  this._options.edge,
                  undefined,
                  this._log.warn.bind(this._log)
                )
              ).map(function (uri) {
                return `wss://${uri}/signal`;
              }));
              let hasChunderURIsChanged =
                originalChunderURIs.size !== newChunderURIs.length;
              if (!hasChunderURIsChanged) {
                for (
                  let _i = 0, newChunderURIs_1 = newChunderURIs;
                  _i < newChunderURIs_1.length;
                  _i++
                ) {
                  const uri = newChunderURIs_1[_i];
                  if (!originalChunderURIs.has(uri)) {
                    hasChunderURIsChanged = true;
                    break;
                  }
                }
              }
              if (this.isBusy && hasChunderURIsChanged) {
                throw new errors_1.InvalidStateError(
                  'Cannot change Edge while on an active Call'
                );
              }
              this._log.setDefaultLevel(
                typeof this._options.logLevel === 'number'
                  ? this._options.logLevel
                  : loglevel_1.levels.ERROR
              );
              if (this._options.dscp) {
                if (!this._options.rtcConstraints) {
                  this._options.rtcConstraints = {};
                }
                this._options.rtcConstraints.optional = [{ googDscp: true }];
              }
              for (
                let _a = 0, _b = Object.keys(Device._defaultSounds);
                _a < _b.length;
                _a++
              ) {
                const name_1 = _b[_a];
                const soundDef = Device._defaultSounds[name_1];
                const defaultUrl = `${C.SOUNDS_BASE_URL}/${soundDef.filename}.${Device.extension}?cache=${C.RELEASE_VERSION}`;
                const soundUrl =
                  (this._options.sounds && this._options.sounds[name_1]) ||
                  defaultUrl;
                const sound = new (this._options.Sound || Sound)(
                  name_1,
                  soundUrl,
                  {
                    audioContext: this._options.disableAudioContextSounds
                      ? null
                      : Device.audioContext,
                    maxDuration: soundDef.maxDuration,
                    shouldLoop: soundDef.shouldLoop,
                  }
                );
                this._soundcache.set(name_1, sound);
              }
              this._setupAudioHelper();
              this._setupPublisher();
              if (hasChunderURIsChanged && this._streamConnectedPromise) {
                this._setupStream();
              }
              if (
                typeof window !== 'undefined' &&
                typeof window.addEventListener === 'function' &&
                this._options.closeProtection
              ) {
                window.removeEventListener(
                  'beforeunload',
                  this._boundConfirmClose
                );
                window.addEventListener(
                  'beforeunload',
                  this._boundConfirmClose
                );
              }
            };
            Device.prototype.updateToken = function (token) {
              if (this.state === Device.State.Destroyed) {
                throw new errors_1.InvalidStateError(
                  `Attempt to "updateToken" when device is in state "${this.state}".`
                );
              }
              if (typeof token !== 'string') {
                throw new errors_1.InvalidArgumentError(INVALID_TOKEN_MESSAGE);
              }
              this._token = token;
              if (this._stream) {
                this._stream.setToken(this._token);
              }
              if (this._publisher) {
                this._publisher.setToken(this._token);
              }
            };
            Device.prototype._confirmClose = function (event) {
              if (!this._activeCall) {
                return '';
              }
              const closeProtection = this._options.closeProtection || false;
              const confirmationMsg =
                typeof closeProtection !== 'string'
                  ? 'A call is currently in-progress. Leaving or reloading this page will end the call.'
                  : closeProtection;
              (event || window.event).returnValue = confirmationMsg;
              return confirmationMsg;
            };
            Device.prototype._destroyAudioHelper = function () {
              if (!this._audio) {
                return;
              }
              this._audio.removeAllListeners();
              this._audio = null;
            };
            Device.prototype._destroyPublisher = function () {
              if (!this._publisher) {
                return;
              }
              this._publisher = null;
            };
            Device.prototype._destroyStream = function () {
              if (this._stream) {
                this._stream.destroy();
                this._stream = null;
              }
              this._streamConnectedPromise = null;
            };
            Device.prototype._findCall = function (callSid) {
              return (
                this._calls.find(function (call) {
                  return (
                    call.parameters.CallSid === callSid ||
                    call.outboundConnectionId === callSid
                  );
                }) || null
              );
            };
            Device.prototype._makeCall = function (twimlParams, options) {
              return __awaiter(this, void 0, void 0, function () {
                let config;
                let _a;
                let call;
                const _this = this;
                return __generator(this, function (_b) {
                  switch (_b.label) {
                    case 0:
                      if (typeof Device._isUnifiedPlanDefault === 'undefined') {
                        throw new errors_1.InvalidStateError(
                          'Device has not been initialized.'
                        );
                      }
                      _a = {
                        audioHelper: this._audio,
                        getUserMedia,
                        isUnifiedPlanDefault: Device._isUnifiedPlanDefault,
                      };
                      return [
                        4,
                        this._streamConnectedPromise || this._setupStream(),
                      ];
                    case 1:
                      config =
                        ((_a.pstream = _b.sent()),
                        (_a.publisher = this._publisher),
                        (_a.soundcache = this._soundcache),
                        _a);
                      options = {
                        MediaStream:
                          this._options.MediaStream || rtc.PeerConnection,
                        beforeAccept(currentCall) {
                          if (
                            !_this._activeCall ||
                            _this._activeCall === currentCall
                          ) {
                            return;
                          }
                          _this._activeCall.disconnect();
                          _this._removeCall(_this._activeCall);
                        },
                        codecPreferences: this._options.codecPreferences,
                        dialtonePlayer: Device._dialtonePlayer,
                        dscp: this._options.dscp,
                        forceAggressiveIceNomination:
                          this._options.forceAggressiveIceNomination,
                        getInputStream() {
                          return (
                            _this._options.fileInputStream ||
                            _this._callInputStream
                          );
                        },
                        getSinkIds() {
                          return _this._callSinkIds;
                        },
                        maxAverageBitrate: this._options.maxAverageBitrate,
                        preflight: this._options.preflight,
                        rtcConstraints: this._options.rtcConstraints,
                        shouldPlayDisconnect() {
                          return _this._enabledSounds.disconnect;
                        },
                        twimlParams,
                        ...options,
                      };
                      call = new (this._options.Call || call_1.default)(
                        config,
                        options
                      );
                      call.once('accept', function () {
                        _this._removeCall(call);
                        _this._activeCall = call;
                        if (_this._audio) {
                          _this._audio._maybeStartPollingVolume();
                        }
                        if (
                          call.direction ===
                            call_1.default.CallDirection.Outgoing &&
                          _this._enabledSounds.outgoing
                        ) {
                          _this._soundcache
                            .get(Device.SoundName.Outgoing)
                            .play();
                        }
                        const data = { edge: _this._edge || _this._region };
                        if (_this._options.edge) {
                          data.selected_edge = Array.isArray(
                            _this._options.edge
                          )
                            ? _this._options.edge
                            : [_this._options.edge];
                        }
                        _this._publisher.info('settings', 'edge', data, call);
                      });
                      call.addListener('error', function (error) {
                        if (call.status() === 'closed') {
                          _this._removeCall(call);
                        }
                        if (_this._audio) {
                          _this._audio._maybeStopPollingVolume();
                        }
                        _this._maybeStopIncomingSound();
                      });
                      call.once('cancel', function () {
                        _this._log.info(`Canceled: ${call.parameters.CallSid}`);
                        _this._removeCall(call);
                        if (_this._audio) {
                          _this._audio._maybeStopPollingVolume();
                        }
                        _this._maybeStopIncomingSound();
                      });
                      call.once('disconnect', function () {
                        if (_this._audio) {
                          _this._audio._maybeStopPollingVolume();
                        }
                        _this._removeCall(call);
                      });
                      call.once('reject', function () {
                        _this._log.info(`Rejected: ${call.parameters.CallSid}`);
                        if (_this._audio) {
                          _this._audio._maybeStopPollingVolume();
                        }
                        _this._removeCall(call);
                        _this._maybeStopIncomingSound();
                      });
                      call.once('transportClose', function () {
                        if (call.status() !== call_1.default.State.Pending) {
                          return;
                        }
                        if (_this._audio) {
                          _this._audio._maybeStopPollingVolume();
                        }
                        _this._removeCall(call);
                        _this._maybeStopIncomingSound();
                      });
                      return [2, call];
                  }
                });
              });
            };
            Device.prototype._maybeStopIncomingSound = function () {
              if (!this._calls.length) {
                this._soundcache.get(Device.SoundName.Incoming).stop();
              }
            };
            Device.prototype._removeCall = function (call) {
              if (this._activeCall === call) {
                this._activeCall = null;
              }
              for (let i = this._calls.length - 1; i >= 0; i--) {
                if (call === this._calls[i]) {
                  this._calls.splice(i, 1);
                }
              }
            };
            Device.prototype._sendPresence = function (presence) {
              return __awaiter(this, void 0, void 0, function () {
                let stream;
                return __generator(this, function (_a) {
                  switch (_a.label) {
                    case 0:
                      return [4, this._streamConnectedPromise];
                    case 1:
                      stream = _a.sent();
                      if (!stream) {
                        return [2];
                      }
                      stream.register({ audio: presence });
                      if (presence) {
                        this._startRegistrationTimer();
                      } else {
                        this._stopRegistrationTimer();
                      }
                      return [2];
                  }
                });
              });
            };
            Device.prototype._setState = function (state) {
              if (state === this.state) {
                return;
              }
              this._state = state;
              this.emit(this._stateEventMapping[state]);
            };
            Device.prototype._setupAudioHelper = function () {
              const _this = this;
              if (this._audio) {
                this._log.info('Found existing audio helper; destroying...');
                this._destroyAudioHelper();
              }
              this._audio = new (this._options.AudioHelper ||
                audiohelper_1.default)(
                this._updateSinkIds,
                this._updateInputStream,
                getUserMedia,
                {
                  audioContext: Device.audioContext,
                  enabledSounds: this._enabledSounds,
                }
              );
              this._audio.on('deviceChange', function (lostActiveDevices) {
                const activeCall = _this._activeCall;
                const deviceIds = lostActiveDevices.map(function (device) {
                  return device.deviceId;
                });
                _this._publisher.info(
                  'audio',
                  'device-change',
                  { lost_active_device_ids: deviceIds },
                  activeCall
                );
                if (activeCall) {
                  activeCall._mediaHandler._onInputDevicesChanged();
                }
              });
            };
            Device.prototype._setupPublisher = function () {
              const _this = this;
              if (this._publisher) {
                this._log.info('Found existing publisher; destroying...');
                this._destroyPublisher();
              }
              this._publisher = (this._options.Publisher || Publisher)(
                PUBLISHER_PRODUCT_NAME,
                this.token,
                {
                  defaultPayload: this._createDefaultPayload,
                  host: this._options.eventgw,
                  metadata: {
                    app_name: this._options.appName,
                    app_version: this._options.appVersion,
                  },
                }
              );
              if (this._options.publishEvents === false) {
                this._publisher.disable();
              } else {
                this._publisher.on('error', function (error) {
                  _this._log.warn('Cannot connect to insights.', error);
                });
              }
              return this._publisher;
            };
            Device.prototype._setupStream = function () {
              const _this = this;
              if (this._stream) {
                this._log.info('Found existing stream; destroying...');
                this._destroyStream();
              }
              this._log.info('Setting up VSP');
              this._stream = (this._options.PStream || PStream)(
                this.token,
                this._chunderURIs,
                {
                  backoffMaxMs: this._options.backoffMaxMs,
                }
              );
              this._stream.addListener('close', this._onSignalingClose);
              this._stream.addListener('connected', this._onSignalingConnected);
              this._stream.addListener('error', this._onSignalingError);
              this._stream.addListener('invite', this._onSignalingInvite);
              this._stream.addListener('offline', this._onSignalingOffline);
              this._stream.addListener('ready', this._onSignalingReady);
              return (this._streamConnectedPromise = new Promise(function (
                resolve
              ) {
                return _this._stream.once('connected', function () {
                  resolve(_this._stream);
                });
              }));
            };
            Device.prototype._showIncomingCall = function (call, play) {
              const _this = this;
              let timeout;
              return Promise.race([
                play(),
                new Promise(function (resolve, reject) {
                  timeout = setTimeout(function () {
                    const msg =
                      'Playing incoming ringtone took too long; it might not play. Continuing execution...';
                    reject(new Error(msg));
                  }, RINGTONE_PLAY_TIMEOUT);
                }),
              ])
                .catch(function (reason) {
                  _this._log.info(reason.message);
                })
                .then(function () {
                  clearTimeout(timeout);
                  _this.emit(Device.EventName.Incoming, call);
                });
            };
            Device.prototype._startRegistrationTimer = function () {
              const _this = this;
              this._stopRegistrationTimer();
              this._regTimer = setTimeout(function () {
                _this._sendPresence(true);
              }, REGISTRATION_INTERVAL);
            };
            Device.prototype._stopRegistrationTimer = function () {
              if (this._regTimer) {
                clearTimeout(this._regTimer);
              }
            };
            Device.prototype._throwIfDestroyed = function () {
              if (this.state === Device.State.Destroyed) {
                throw new errors_1.InvalidStateError(
                  'Device has been destroyed.'
                );
              }
            };
            Device.prototype._updateRingtoneSinkIds = function (sinkIds) {
              return Promise.resolve(
                this._soundcache
                  .get(Device.SoundName.Incoming)
                  .setSinkIds(sinkIds)
              );
            };
            Device.prototype._updateSpeakerSinkIds = function (sinkIds) {
              Array.from(this._soundcache.entries())
                .filter(function (entry) {
                  return entry[0] !== Device.SoundName.Incoming;
                })
                .forEach(function (entry) {
                  return entry[1].setSinkIds(sinkIds);
                });
              this._callSinkIds = sinkIds;
              const call = this._activeCall;
              return call ? call._setSinkIds(sinkIds) : Promise.resolve();
            };
            Device._defaultSounds = {
              disconnect: { filename: 'disconnect', maxDuration: 3e3 },
              dtmf0: { filename: 'dtmf-0', maxDuration: 1e3 },
              dtmf1: { filename: 'dtmf-1', maxDuration: 1e3 },
              dtmf2: { filename: 'dtmf-2', maxDuration: 1e3 },
              dtmf3: { filename: 'dtmf-3', maxDuration: 1e3 },
              dtmf4: { filename: 'dtmf-4', maxDuration: 1e3 },
              dtmf5: { filename: 'dtmf-5', maxDuration: 1e3 },
              dtmf6: { filename: 'dtmf-6', maxDuration: 1e3 },
              dtmf7: { filename: 'dtmf-7', maxDuration: 1e3 },
              dtmf8: { filename: 'dtmf-8', maxDuration: 1e3 },
              dtmf9: { filename: 'dtmf-9', maxDuration: 1e3 },
              dtmfh: { filename: 'dtmf-hash', maxDuration: 1e3 },
              dtmfs: { filename: 'dtmf-star', maxDuration: 1e3 },
              incoming: { filename: 'incoming', shouldLoop: true },
              outgoing: { filename: 'outgoing', maxDuration: 3e3 },
            };
            return Device;
          })(events_1.EventEmitter);
          (function (Device) {
            let EventName;
            (function (EventName) {
              EventName.Error = 'error';
              EventName.Incoming = 'incoming';
              EventName.Destroyed = 'destroyed';
              EventName.Unregistered = 'unregistered';
              EventName.Registering = 'registering';
              EventName.Registered = 'registered';
            })((EventName = Device.EventName || (Device.EventName = {})));
            let State;
            (function (State) {
              State.Destroyed = 'destroyed';
              State.Unregistered = 'unregistered';
              State.Registering = 'registering';
              State.Registered = 'registered';
            })((State = Device.State || (Device.State = {})));
            let SoundName;
            (function (SoundName) {
              SoundName.Incoming = 'incoming';
              SoundName.Outgoing = 'outgoing';
              SoundName.Disconnect = 'disconnect';
              SoundName.Dtmf0 = 'dtmf0';
              SoundName.Dtmf1 = 'dtmf1';
              SoundName.Dtmf2 = 'dtmf2';
              SoundName.Dtmf3 = 'dtmf3';
              SoundName.Dtmf4 = 'dtmf4';
              SoundName.Dtmf5 = 'dtmf5';
              SoundName.Dtmf6 = 'dtmf6';
              SoundName.Dtmf7 = 'dtmf7';
              SoundName.Dtmf8 = 'dtmf8';
              SoundName.Dtmf9 = 'dtmf9';
              SoundName.DtmfS = 'dtmfs';
              SoundName.DtmfH = 'dtmfh';
            })((SoundName = Device.SoundName || (Device.SoundName = {})));
          })(Device || (Device = {}));
          exports.default = Device;
        },
        {
          './audiohelper': 5,
          './call': 6,
          './constants': 7,
          './dialtonePlayer': 10,
          './errors': 12,
          './eventpublisher': 14,
          './log': 15,
          './preflight/preflight': 17,
          './pstream': 18,
          './regions': 19,
          './rtc': 23,
          './rtc/getusermedia': 21,
          './sound': 33,
          './util': 35,
          events: 48,
          loglevel: 49,
        },
      ],
      10: [
        function (require, module, exports) {
          Object.defineProperty(exports, '__esModule', { value: true });
          const errors_1 = require('./errors');
          const bandFrequencies = {
            dtmf0: [1360, 960],
            dtmf1: [1230, 720],
            dtmf2: [1360, 720],
            dtmf3: [1480, 720],
            dtmf4: [1230, 790],
            dtmf5: [1360, 790],
            dtmf6: [1480, 790],
            dtmf7: [1230, 870],
            dtmf8: [1360, 870],
            dtmf9: [1480, 870],
            dtmfh: [1480, 960],
            dtmfs: [1230, 960],
          };
          const DialtonePlayer = (function () {
            function DialtonePlayer(_context) {
              const _this = this;
              this._context = _context;
              this._gainNodes = [];
              this._gainNodes = [
                this._context.createGain(),
                this._context.createGain(),
              ];
              this._gainNodes.forEach(function (gainNode) {
                gainNode.connect(_this._context.destination);
                gainNode.gain.value = 0.1;
                _this._gainNodes.push(gainNode);
              });
            }
            DialtonePlayer.prototype.cleanup = function () {
              this._gainNodes.forEach(function (gainNode) {
                gainNode.disconnect();
              });
            };
            DialtonePlayer.prototype.play = function (sound) {
              const _this = this;
              const frequencies = bandFrequencies[sound];
              if (!frequencies) {
                throw new errors_1.InvalidArgumentError(
                  'Invalid DTMF sound name'
                );
              }
              const oscillators = [
                this._context.createOscillator(),
                this._context.createOscillator(),
              ];
              oscillators.forEach(function (oscillator, i) {
                oscillator.type = 'sine';
                oscillator.frequency.value = frequencies[i];
                oscillator.connect(_this._gainNodes[i]);
                oscillator.start();
                oscillator.stop(_this._context.currentTime + 0.1);
                oscillator.addEventListener('ended', function () {
                  return oscillator.disconnect();
                });
              });
            };
            return DialtonePlayer;
          })();
          exports.default = DialtonePlayer;
        },
        { './errors': 12 },
      ],
      11: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          Object.defineProperty(exports, '__esModule', { value: true });
          const twilioError_1 = require('./twilioError');
          exports.TwilioError = twilioError_1.default;
          let AuthorizationErrors;
          (function (AuthorizationErrors) {
            const AccessTokenInvalid = (function (_super) {
              __extends(AccessTokenInvalid, _super);
              function AccessTokenInvalid(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 20101;
                _this.description = 'Invalid access token';
                _this.explanation =
                  'Twilio was unable to validate your Access Token';
                _this.name = 'AccessTokenInvalid';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  AuthorizationErrors.AccessTokenInvalid.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return AccessTokenInvalid;
            })(twilioError_1.default);
            AuthorizationErrors.AccessTokenInvalid = AccessTokenInvalid;
            const AccessTokenExpired = (function (_super) {
              __extends(AccessTokenExpired, _super);
              function AccessTokenExpired(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 20104;
                _this.description =
                  'Access token expired or expiration date invalid';
                _this.explanation =
                  'The Access Token provided to the Twilio API has expired, the expiration time specified in the token was invalid, or the expiration time specified was too far in the future';
                _this.name = 'AccessTokenExpired';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  AuthorizationErrors.AccessTokenExpired.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return AccessTokenExpired;
            })(twilioError_1.default);
            AuthorizationErrors.AccessTokenExpired = AccessTokenExpired;
            const AuthenticationFailed = (function (_super) {
              __extends(AuthenticationFailed, _super);
              function AuthenticationFailed(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 20151;
                _this.description = 'Authentication Failed';
                _this.explanation =
                  'The Authentication with the provided JWT failed';
                _this.name = 'AuthenticationFailed';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  AuthorizationErrors.AuthenticationFailed.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return AuthenticationFailed;
            })(twilioError_1.default);
            AuthorizationErrors.AuthenticationFailed = AuthenticationFailed;
          })(
            (AuthorizationErrors =
              exports.AuthorizationErrors || (exports.AuthorizationErrors = {}))
          );
          let ClientErrors;
          (function (ClientErrors) {
            const BadRequest = (function (_super) {
              __extends(BadRequest, _super);
              function BadRequest(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 31400;
                _this.description = 'Bad Request (HTTP/SIP)';
                _this.explanation =
                  'The request could not be understood due to malformed syntax.';
                _this.name = 'BadRequest';
                _this.solutions = [];
                Object.setPrototypeOf(_this, ClientErrors.BadRequest.prototype);
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return BadRequest;
            })(twilioError_1.default);
            ClientErrors.BadRequest = BadRequest;
          })(
            (ClientErrors = exports.ClientErrors || (exports.ClientErrors = {}))
          );
          let GeneralErrors;
          (function (GeneralErrors) {
            const UnknownError = (function (_super) {
              __extends(UnknownError, _super);
              function UnknownError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 31e3;
                _this.description = 'Unknown Error';
                _this.explanation =
                  'An unknown error has occurred. See error details for more information.';
                _this.name = 'UnknownError';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  GeneralErrors.UnknownError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return UnknownError;
            })(twilioError_1.default);
            GeneralErrors.UnknownError = UnknownError;
            const ConnectionError = (function (_super) {
              __extends(ConnectionError, _super);
              function ConnectionError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 31005;
                _this.description = 'Connection error';
                _this.explanation =
                  'A connection error occurred during the call';
                _this.name = 'ConnectionError';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  GeneralErrors.ConnectionError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return ConnectionError;
            })(twilioError_1.default);
            GeneralErrors.ConnectionError = ConnectionError;
            const CallCancelledError = (function (_super) {
              __extends(CallCancelledError, _super);
              function CallCancelledError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [
                  'The incoming call was cancelled because it was not answered in time or it was accepted/rejected by another application instance registered with the same identity.',
                ];
                _this.code = 31008;
                _this.description = 'Call cancelled';
                _this.explanation =
                  'Unable to answer because the call has ended';
                _this.name = 'CallCancelledError';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  GeneralErrors.CallCancelledError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return CallCancelledError;
            })(twilioError_1.default);
            GeneralErrors.CallCancelledError = CallCancelledError;
            const TransportError = (function (_super) {
              __extends(TransportError, _super);
              function TransportError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 31009;
                _this.description = 'Transport error';
                _this.explanation =
                  'No transport available to send or receive messages';
                _this.name = 'TransportError';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  GeneralErrors.TransportError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return TransportError;
            })(twilioError_1.default);
            GeneralErrors.TransportError = TransportError;
          })(
            (GeneralErrors =
              exports.GeneralErrors || (exports.GeneralErrors = {}))
          );
          let UserMediaErrors;
          (function (UserMediaErrors) {
            const PermissionDeniedError = (function (_super) {
              __extends(PermissionDeniedError, _super);
              function PermissionDeniedError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [
                  'The user denied the getUserMedia request.',
                  'The browser denied the getUserMedia request.',
                ];
                _this.code = 31401;
                _this.description = 'UserMedia Permission Denied Error';
                _this.explanation =
                  'The browser or end-user denied permissions to user media. Therefore we were unable to acquire input audio.';
                _this.name = 'PermissionDeniedError';
                _this.solutions = [
                  'The user should accept the request next time prompted. If the browser saved the deny, the user should change that permission in their browser.',
                  'The user should to verify that the browser has permission to access the microphone at this address.',
                ];
                Object.setPrototypeOf(
                  _this,
                  UserMediaErrors.PermissionDeniedError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return PermissionDeniedError;
            })(twilioError_1.default);
            UserMediaErrors.PermissionDeniedError = PermissionDeniedError;
            const AcquisitionFailedError = (function (_super) {
              __extends(AcquisitionFailedError, _super);
              function AcquisitionFailedError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [
                  'NotFoundError - The deviceID specified was not found.',
                  'The getUserMedia constraints were overconstrained and no devices matched.',
                ];
                _this.code = 31402;
                _this.description = 'UserMedia Acquisition Failed Error';
                _this.explanation =
                  'The browser and end-user allowed permissions, however getting the media failed. Usually this is due to bad constraints, but can sometimes fail due to browser, OS or hardware issues.';
                _this.name = 'AcquisitionFailedError';
                _this.solutions = [
                  'Ensure the deviceID being specified exists.',
                  'Try acquiring media with fewer constraints.',
                ];
                Object.setPrototypeOf(
                  _this,
                  UserMediaErrors.AcquisitionFailedError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return AcquisitionFailedError;
            })(twilioError_1.default);
            UserMediaErrors.AcquisitionFailedError = AcquisitionFailedError;
          })(
            (UserMediaErrors =
              exports.UserMediaErrors || (exports.UserMediaErrors = {}))
          );
          let SignalingErrors;
          (function (SignalingErrors) {
            const ConnectionError = (function (_super) {
              __extends(ConnectionError, _super);
              function ConnectionError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [];
                _this.code = 53e3;
                _this.description = 'Signaling connection error';
                _this.explanation =
                  'Raised whenever a signaling connection error occurs that is not covered by a more specific error code.';
                _this.name = 'ConnectionError';
                _this.solutions = [];
                Object.setPrototypeOf(
                  _this,
                  SignalingErrors.ConnectionError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return ConnectionError;
            })(twilioError_1.default);
            SignalingErrors.ConnectionError = ConnectionError;
            const ConnectionDisconnected = (function (_super) {
              __extends(ConnectionDisconnected, _super);
              function ConnectionDisconnected(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [
                  'The device running your application lost its Internet connection.',
                ];
                _this.code = 53001;
                _this.description = 'Signaling connection disconnected';
                _this.explanation =
                  'Raised whenever the signaling connection is unexpectedly disconnected.';
                _this.name = 'ConnectionDisconnected';
                _this.solutions = [
                  'Ensure the device running your application has access to a stable Internet connection.',
                ];
                Object.setPrototypeOf(
                  _this,
                  SignalingErrors.ConnectionDisconnected.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return ConnectionDisconnected;
            })(twilioError_1.default);
            SignalingErrors.ConnectionDisconnected = ConnectionDisconnected;
          })(
            (SignalingErrors =
              exports.SignalingErrors || (exports.SignalingErrors = {}))
          );
          let MediaErrors;
          (function (MediaErrors) {
            const ClientLocalDescFailed = (function (_super) {
              __extends(ClientLocalDescFailed, _super);
              function ClientLocalDescFailed(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [
                  'The Client may not be using a supported WebRTC implementation.',
                  'The Client may not have the necessary resources to create or apply a new media description.',
                ];
                _this.code = 53400;
                _this.description =
                  'Client is unable to create or apply a local media description';
                _this.explanation =
                  'Raised whenever a Client is unable to create or apply a local media description.';
                _this.name = 'ClientLocalDescFailed';
                _this.solutions = [
                  'If you are experiencing this error using the JavaScript SDK, ensure you are running it with a supported WebRTC implementation.',
                ];
                Object.setPrototypeOf(
                  _this,
                  MediaErrors.ClientLocalDescFailed.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return ClientLocalDescFailed;
            })(twilioError_1.default);
            MediaErrors.ClientLocalDescFailed = ClientLocalDescFailed;
            const ClientRemoteDescFailed = (function (_super) {
              __extends(ClientRemoteDescFailed, _super);
              function ClientRemoteDescFailed(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [
                  'The Client may not be using a supported WebRTC implementation.',
                  'The Client may be connecting peer-to-peer with another Participant that is not using a supported WebRTC implementation.',
                  'The Client may not have the necessary resources to apply a new media description.',
                ];
                _this.code = 53402;
                _this.description =
                  'Client is unable to apply a remote media description';
                _this.explanation =
                  'Raised whenever the Client receives a remote media description but is unable to apply it.';
                _this.name = 'ClientRemoteDescFailed';
                _this.solutions = [
                  'If you are experiencing this error using the JavaScript SDK, ensure you are running it with a supported WebRTC implementation.',
                ];
                Object.setPrototypeOf(
                  _this,
                  MediaErrors.ClientRemoteDescFailed.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return ClientRemoteDescFailed;
            })(twilioError_1.default);
            MediaErrors.ClientRemoteDescFailed = ClientRemoteDescFailed;
            const ConnectionError = (function (_super) {
              __extends(ConnectionError, _super);
              function ConnectionError(messageOrError, error) {
                const _this = _super.call(this, messageOrError, error) || this;
                _this.causes = [
                  'The Client was unable to establish a media connection.',
                  'A media connection which was active failed liveliness checks.',
                ];
                _this.code = 53405;
                _this.description = 'Media connection failed';
                _this.explanation =
                  'Raised by the Client or Server whenever a media connection fails.';
                _this.name = 'ConnectionError';
                _this.solutions = [
                  'If the problem persists, try connecting to another region.',
                  "Check your Client's network connectivity.",
                  "If you've provided custom ICE Servers then ensure that the URLs and credentials are valid.",
                ];
                Object.setPrototypeOf(
                  _this,
                  MediaErrors.ConnectionError.prototype
                );
                const message =
                  typeof messageOrError === 'string'
                    ? messageOrError
                    : _this.explanation;
                const originalError =
                  typeof messageOrError === 'object' ? messageOrError : error;
                _this.message = `${_this.name} (${_this.code}): ${message}`;
                _this.originalError = originalError;
                return _this;
              }
              return ConnectionError;
            })(twilioError_1.default);
            MediaErrors.ConnectionError = ConnectionError;
          })((MediaErrors = exports.MediaErrors || (exports.MediaErrors = {})));
          exports.errorsByCode = new Map([
            [20101, AuthorizationErrors.AccessTokenInvalid],
            [20104, AuthorizationErrors.AccessTokenExpired],
            [20151, AuthorizationErrors.AuthenticationFailed],
            [31400, ClientErrors.BadRequest],
            [31e3, GeneralErrors.UnknownError],
            [31005, GeneralErrors.ConnectionError],
            [31008, GeneralErrors.CallCancelledError],
            [31009, GeneralErrors.TransportError],
            [31401, UserMediaErrors.PermissionDeniedError],
            [31402, UserMediaErrors.AcquisitionFailedError],
            [53e3, SignalingErrors.ConnectionError],
            [53001, SignalingErrors.ConnectionDisconnected],
            [53400, MediaErrors.ClientLocalDescFailed],
            [53402, MediaErrors.ClientRemoteDescFailed],
            [53405, MediaErrors.ConnectionError],
          ]);
          Object.freeze(exports.errorsByCode);
        },
        { './twilioError': 13 },
      ],
      12: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          Object.defineProperty(exports, '__esModule', { value: true });
          const generated_1 = require('./generated');
          exports.AuthorizationErrors = generated_1.AuthorizationErrors;
          exports.ClientErrors = generated_1.ClientErrors;
          exports.GeneralErrors = generated_1.GeneralErrors;
          exports.MediaErrors = generated_1.MediaErrors;
          exports.SignalingErrors = generated_1.SignalingErrors;
          exports.TwilioError = generated_1.TwilioError;
          exports.UserMediaErrors = generated_1.UserMediaErrors;
          const InvalidArgumentError = (function (_super) {
            __extends(InvalidArgumentError, _super);
            function InvalidArgumentError(message) {
              const _this = _super.call(this, message) || this;
              _this.name = 'InvalidArgumentError';
              return _this;
            }
            return InvalidArgumentError;
          })(Error);
          exports.InvalidArgumentError = InvalidArgumentError;
          const InvalidStateError = (function (_super) {
            __extends(InvalidStateError, _super);
            function InvalidStateError(message) {
              const _this = _super.call(this, message) || this;
              _this.name = 'InvalidStateError';
              return _this;
            }
            return InvalidStateError;
          })(Error);
          exports.InvalidStateError = InvalidStateError;
          const NotSupportedError = (function (_super) {
            __extends(NotSupportedError, _super);
            function NotSupportedError(message) {
              const _this = _super.call(this, message) || this;
              _this.name = 'NotSupportedError';
              return _this;
            }
            return NotSupportedError;
          })(Error);
          exports.NotSupportedError = NotSupportedError;
          function getErrorByCode(code) {
            const error = generated_1.errorsByCode.get(code);
            if (!error) {
              throw new InvalidArgumentError(`Error code ${code} not found`);
            }
            return error;
          }
          exports.getErrorByCode = getErrorByCode;
          function hasErrorByCode(code) {
            return generated_1.errorsByCode.has(code);
          }
          exports.hasErrorByCode = hasErrorByCode;
        },
        { './generated': 11 },
      ],
      13: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          Object.defineProperty(exports, '__esModule', { value: true });
          const TwilioError = (function (_super) {
            __extends(TwilioError, _super);
            function TwilioError(messageOrError, error) {
              const _this = _super.call(this) || this;
              Object.setPrototypeOf(_this, TwilioError.prototype);
              const message =
                typeof messageOrError === 'string'
                  ? messageOrError
                  : _this.explanation;
              const originalError =
                typeof messageOrError === 'object' ? messageOrError : error;
              _this.message = `${_this.name} (${_this.code}): ${message}`;
              _this.originalError = originalError;
              return _this;
            }
            return TwilioError;
          })(Error);
          exports.default = TwilioError;
        },
        {},
      ],
      14: [
        function (require, module, exports) {
          const { EventEmitter } = require('events');
          const request = require('./request');
          const util = require('util');
          function EventPublisher(productName, token, options) {
            if (!(this instanceof EventPublisher)) {
              return new EventPublisher(productName, token, options);
            }
            options = {
              defaultPayload: function defaultPayload() {
                return {};
              },
              host: 'eventgw.twilio.com',
              ...options,
            };
            let { defaultPayload } = options;
            if (typeof defaultPayload !== 'function') {
              defaultPayload = function defaultPayload() {
                return { ...options.defaultPayload };
              };
            }
            let isEnabled = true;
            const metadata = {
              app_name: undefined,
              app_version: undefined,
              ...options.metadata,
            };
            Object.defineProperties(this, {
              _defaultPayload: { value: defaultPayload },
              _isEnabled: {
                get: function get() {
                  return isEnabled;
                },
                set: function set(_isEnabled) {
                  isEnabled = _isEnabled;
                },
              },
              _host: { value: options.host },
              _request: { value: options.request || request, writable: true },
              _token: { value: token, writable: true },
              isEnabled: {
                enumerable: true,
                get: function get() {
                  return isEnabled;
                },
              },
              metadata: {
                enumerable: true,
                get: function get() {
                  return metadata;
                },
              },
              productName: { enumerable: true, value: productName },
              token: {
                enumerable: true,
                get: function get() {
                  return this._token;
                },
              },
            });
          }
          util.inherits(EventPublisher, EventEmitter);
          EventPublisher.prototype._post = function _post(
            endpointName,
            level,
            group,
            name,
            payload,
            connection,
            force
          ) {
            const _this = this;
            if (!this.isEnabled && !force) {
              return Promise.resolve();
            }
            if (
              !connection ||
              ((!connection.parameters || !connection.parameters.CallSid) &&
                !connection.outboundConnectionId)
            ) {
              return Promise.resolve();
            }
            const event = {
              publisher: this.productName,
              group,
              name,
              timestamp: new Date().toISOString(),
              level: level.toUpperCase(),
              payload_type: 'application/json',
              private: false,
              payload:
                payload && payload.forEach
                  ? payload.slice(0)
                  : Object.assign(this._defaultPayload(connection), payload),
            };
            if (this.metadata) {
              event.publisher_metadata = this.metadata;
            }
            const requestParams = {
              url: `https://${this._host}/v4/${endpointName}`,
              body: event,
              headers: {
                'Content-Type': 'application/json',
                'X-Twilio-Token': this.token,
              },
            };
            const self = this;
            return new Promise(function (resolve, reject) {
              self._request.post(requestParams, function (err) {
                if (err) {
                  _this.emit('error', err);
                  reject(err);
                } else {
                  resolve();
                }
              });
            });
          };
          EventPublisher.prototype.post = function post(
            level,
            group,
            name,
            payload,
            connection,
            force
          ) {
            return this._post(
              'EndpointEvents',
              level,
              group,
              name,
              payload,
              connection,
              force
            );
          };
          EventPublisher.prototype.debug = function debug(
            group,
            name,
            payload,
            connection
          ) {
            return this.post('debug', group, name, payload, connection);
          };
          EventPublisher.prototype.info = function info(
            group,
            name,
            payload,
            connection
          ) {
            return this.post('info', group, name, payload, connection);
          };
          EventPublisher.prototype.warn = function warn(
            group,
            name,
            payload,
            connection
          ) {
            return this.post('warning', group, name, payload, connection);
          };
          EventPublisher.prototype.error = function error(
            group,
            name,
            payload,
            connection
          ) {
            return this.post('error', group, name, payload, connection);
          };
          EventPublisher.prototype.postMetrics = function postMetrics(
            group,
            name,
            metrics,
            customFields,
            connection
          ) {
            const _this2 = this;
            return new Promise(function (resolve) {
              const samples = metrics.map(formatMetric).map(function (sample) {
                return Object.assign(sample, customFields);
              });
              resolve(
                _this2._post(
                  'EndpointMetrics',
                  'info',
                  group,
                  name,
                  samples,
                  connection
                )
              );
            });
          };
          EventPublisher.prototype.setToken = function setToken(token) {
            this._token = token;
          };
          EventPublisher.prototype.enable = function enable() {
            this._isEnabled = true;
          };
          EventPublisher.prototype.disable = function disable() {
            this._isEnabled = false;
          };
          function formatMetric(sample) {
            return {
              timestamp: new Date(sample.timestamp).toISOString(),
              total_packets_received: sample.totals.packetsReceived,
              total_packets_lost: sample.totals.packetsLost,
              total_packets_sent: sample.totals.packetsSent,
              total_bytes_received: sample.totals.bytesReceived,
              total_bytes_sent: sample.totals.bytesSent,
              packets_received: sample.packetsReceived,
              packets_lost: sample.packetsLost,
              packets_lost_fraction:
                sample.packetsLostFraction &&
                Math.round(sample.packetsLostFraction * 100) / 100,
              bytes_received: sample.bytesReceived,
              bytes_sent: sample.bytesSent,
              audio_codec: sample.codecName,
              audio_level_in: sample.audioInputLevel,
              audio_level_out: sample.audioOutputLevel,
              call_volume_input: sample.inputVolume,
              call_volume_output: sample.outputVolume,
              jitter: sample.jitter,
              rtt: sample.rtt,
              mos: sample.mos && Math.round(sample.mos * 100) / 100,
            };
          }
          module.exports = EventPublisher;
        },
        { './request': 20, events: 48, util: 60 },
      ],
      15: [
        function (require, module, exports) {
          Object.defineProperty(exports, '__esModule', { value: true });
          const LogLevelModule = require('loglevel');
          const constants_1 = require('./constants');
          const Log = (function () {
            function Log(options) {
              this._log = (
                options && options.LogLevelModule
                  ? options.LogLevelModule
                  : LogLevelModule
              ).getLogger(constants_1.PACKAGE_NAME);
            }
            Log.getInstance = function () {
              if (!Log.instance) {
                Log.instance = new Log();
              }
              return Log.instance;
            };
            Log.prototype.debug = function () {
              let _a;
              const args = [];
              for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              (_a = this._log).debug.apply(_a, args);
            };
            Log.prototype.error = function () {
              let _a;
              const args = [];
              for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              (_a = this._log).error.apply(_a, args);
            };
            Log.prototype.getLogLevelInstance = function () {
              return this._log;
            };
            Log.prototype.info = function () {
              let _a;
              const args = [];
              for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              (_a = this._log).info.apply(_a, args);
            };
            Log.prototype.setDefaultLevel = function (level) {
              this._log.setDefaultLevel(level);
            };
            Log.prototype.warn = function () {
              let _a;
              const args = [];
              for (let _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
              }
              (_a = this._log).warn.apply(_a, args);
            };
            Log.levels = LogLevelModule.levels;
            return Log;
          })();
          exports.Logger = Log.getInstance().getLogLevelInstance();
          exports.default = Log;
        },
        { './constants': 7, loglevel: 49 },
      ],
      16: [
        function (require, module, exports) {
          Object.defineProperty(exports, '__esModule', { value: true });
          const constants_1 = require('./constants');
          const errors_1 = require('./errors');
          const DEFAULT_TEST_SOUND_URL = `${constants_1.SOUNDS_BASE_URL}/outgoing.mp3`;
          const OutputDeviceCollection = (function () {
            function OutputDeviceCollection(
              _name,
              _availableDevices,
              _beforeChange,
              _isSupported
            ) {
              this._name = _name;
              this._availableDevices = _availableDevices;
              this._beforeChange = _beforeChange;
              this._isSupported = _isSupported;
              this._activeDevices = new Set();
            }
            OutputDeviceCollection.prototype.delete = function (device) {
              const wasDeleted = Boolean(this._activeDevices.delete(device));
              const defaultDevice =
                this._availableDevices.get('default') ||
                Array.from(this._availableDevices.values())[0];
              if (!this._activeDevices.size && defaultDevice) {
                this._activeDevices.add(defaultDevice);
              }
              const deviceIds = Array.from(this._activeDevices.values()).map(
                function (deviceInfo) {
                  return deviceInfo.deviceId;
                }
              );
              this._beforeChange(this._name, deviceIds);
              return Boolean(wasDeleted);
            };
            OutputDeviceCollection.prototype.get = function () {
              return this._activeDevices;
            };
            OutputDeviceCollection.prototype.set = function (deviceIdOrIds) {
              const _this = this;
              if (!this._isSupported) {
                return Promise.reject(
                  new errors_1.NotSupportedError(
                    'This browser does not support audio output selection'
                  )
                );
              }
              const deviceIds = Array.isArray(deviceIdOrIds)
                ? deviceIdOrIds
                : [deviceIdOrIds];
              if (!deviceIds.length) {
                return Promise.reject(
                  new errors_1.InvalidArgumentError(
                    'Must specify at least one device to set'
                  )
                );
              }
              const missingIds = [];
              const devices = deviceIds.map(function (id) {
                const device = _this._availableDevices.get(id);
                if (!device) {
                  missingIds.push(id);
                }
                return device;
              });
              if (missingIds.length) {
                return Promise.reject(
                  new errors_1.InvalidArgumentError(
                    `Devices not found: ${missingIds.join(', ')}`
                  )
                );
              }
              return new Promise(function (resolve) {
                resolve(_this._beforeChange(_this._name, deviceIds));
              }).then(function () {
                _this._activeDevices.clear();
                devices.forEach(_this._activeDevices.add, _this._activeDevices);
              });
            };
            OutputDeviceCollection.prototype.test = function (soundUrl) {
              if (soundUrl === void 0) {
                soundUrl = DEFAULT_TEST_SOUND_URL;
              }
              if (!this._isSupported) {
                return Promise.reject(
                  new errors_1.NotSupportedError(
                    'This browser does not support audio output selection'
                  )
                );
              }
              if (!this._activeDevices.size) {
                return Promise.reject(
                  new errors_1.InvalidStateError(
                    'No active output devices to test'
                  )
                );
              }
              return Promise.all(
                Array.from(this._activeDevices).map(function (device) {
                  let el;
                  return new Promise(function (resolve) {
                    el = new Audio(soundUrl);
                    el.oncanplay = resolve;
                  }).then(function () {
                    return el.setSinkId(device.deviceId).then(function () {
                      return el.play();
                    });
                  });
                })
              );
            };
            return OutputDeviceCollection;
          })();
          exports.default = OutputDeviceCollection;
        },
        { './constants': 7, './errors': 12 },
      ],
      17: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          var __assign =
            (this && this.__assign) ||
            function () {
              __assign =
                Object.assign ||
                function (t) {
                  for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (const p in s)
                      if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
                  }
                  return t;
                };
              return __assign.apply(this, arguments);
            };
          const __awaiter =
            (this && this.__awaiter) ||
            function (thisArg, _arguments, P, generator) {
              function adopt(value) {
                return value instanceof P
                  ? value
                  : new P(function (resolve) {
                      resolve(value);
                    });
              }
              return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator.throw(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step(result) {
                  result.done
                    ? resolve(result.value)
                    : adopt(result.value).then(fulfilled, rejected);
                }
                step(
                  (generator = generator.apply(
                    thisArg,
                    _arguments || []
                  )).next()
                );
              });
            };
          const __generator =
            (this && this.__generator) ||
            function (thisArg, body) {
              let _ = {
                label: 0,
                sent() {
                  if (t[0] & 1) throw t[1];
                  return t[1];
                },
                trys: [],
                ops: [],
              };
              let f;
              let y;
              let t;
              let g;
              return (
                (g = { next: verb(0), throw: verb(1), return: verb(2) }),
                typeof Symbol === 'function' &&
                  (g[Symbol.iterator] = function () {
                    return this;
                  }),
                g
              );
              function verb(n) {
                return function (v) {
                  return step([n, v]);
                };
              }
              function step(op) {
                if (f) throw new TypeError('Generator is already executing.');
                while (_)
                  try {
                    if (
                      ((f = 1),
                      y &&
                        (t =
                          op[0] & 2
                            ? y.return
                            : op[0]
                            ? y.throw || ((t = y.return) && t.call(y), 0)
                            : y.next) &&
                        !(t = t.call(y, op[1])).done)
                    )
                      return t;
                    if (((y = 0), t)) op = [op[0] & 2, t.value];
                    switch (op[0]) {
                      case 0:
                      case 1:
                        t = op;
                        break;
                      case 4:
                        _.label++;
                        return { value: op[1], done: false };
                      case 5:
                        _.label++;
                        y = op[1];
                        op = [0];
                        continue;
                      case 7:
                        op = _.ops.pop();
                        _.trys.pop();
                        continue;
                      default:
                        if (
                          !((t = _.trys),
                          (t = t.length > 0 && t[t.length - 1])) &&
                          (op[0] === 6 || op[0] === 2)
                        ) {
                          _ = 0;
                          continue;
                        }
                        if (
                          op[0] === 3 &&
                          (!t || (op[1] > t[0] && op[1] < t[3]))
                        ) {
                          _.label = op[1];
                          break;
                        }
                        if (op[0] === 6 && _.label < t[1]) {
                          _.label = t[1];
                          t = op;
                          break;
                        }
                        if (t && _.label < t[2]) {
                          _.label = t[2];
                          _.ops.push(op);
                          break;
                        }
                        if (t[2]) _.ops.pop();
                        _.trys.pop();
                        continue;
                    }
                    op = body.call(thisArg, _);
                  } catch (e) {
                    op = [6, e];
                    y = 0;
                  } finally {
                    f = t = 0;
                  }
                if (op[0] & 5) throw op[1];
                return { value: op[0] ? op[1] : void 0, done: true };
              }
            };
          Object.defineProperty(exports, '__esModule', { value: true });
          const events_1 = require('events');
          const call_1 = require('../call');
          const device_1 = require('../device');
          const errors_1 = require('../errors');
          const stats_1 = require('../rtc/stats');
          const _a = require('../constants');
          const { COWBELL_AUDIO_URL } = _a;
          const { ECHO_TEST_DURATION } = _a;
          let PreflightTest = (function (_super) {
            __extends(PreflightTest, _super);
            function PreflightTest(token, options) {
              const _this = _super.call(this) || this;
              _this._hasInsightsErrored = false;
              _this._networkTiming = {};
              _this._options = {
                codecPreferences: [
                  call_1.default.Codec.PCMU,
                  call_1.default.Codec.Opus,
                ],
                edge: 'roaming',
                fakeMicInput: false,
                logLevel: 'error',
                signalingTimeoutMs: 1e4,
              };
              _this._status = PreflightTest.Status.Connecting;
              Object.assign(_this._options, options);
              _this._samples = [];
              _this._warnings = [];
              _this._startTime = Date.now();
              _this._initDevice(token, {
                ..._this._options,
                fileInputStream: _this._options.fakeMicInput
                  ? _this._getStreamFromFile()
                  : undefined,
              });
              return _this;
            }
            PreflightTest.prototype.stop = function () {
              const _this = this;
              const error = new errors_1.GeneralErrors.CallCancelledError();
              if (this._device) {
                this._device.once(
                  device_1.default.EventName.Unregistered,
                  function () {
                    return _this._onFailed(error);
                  }
                );
                this._device.destroy();
              } else {
                this._onFailed(error);
              }
            };
            PreflightTest.prototype._emitWarning = function (
              name,
              description,
              rtcWarning
            ) {
              const warning = { name, description };
              if (rtcWarning) {
                warning.rtcWarning = rtcWarning;
              }
              this._warnings.push(warning);
              this.emit(PreflightTest.Events.Warning, warning);
            };
            PreflightTest.prototype._getCallQuality = function (mos) {
              if (mos > 4.2) {
                return PreflightTest.CallQuality.Excellent;
              } else if (mos >= 4.1 && mos <= 4.2) {
                return PreflightTest.CallQuality.Great;
              } else if (mos >= 3.7 && mos <= 4) {
                return PreflightTest.CallQuality.Good;
              } else if (mos >= 3.1 && mos <= 3.6) {
                return PreflightTest.CallQuality.Fair;
              }
              return PreflightTest.CallQuality.Degraded;
            };
            PreflightTest.prototype._getReport = function () {
              const stats = this._getRTCStats();
              const testTiming = { start: this._startTime };
              if (this._endTime) {
                testTiming.end = this._endTime;
                testTiming.duration = this._endTime - this._startTime;
              }
              const report = {
                callSid: this._callSid,
                edge: this._edge,
                iceCandidateStats:
                  this._rtcIceCandidateStatsReport.iceCandidateStats,
                networkTiming: this._networkTiming,
                samples: this._samples,
                selectedEdge: this._options.edge,
                stats,
                testTiming,
                totals: this._getRTCSampleTotals(),
                warnings: this._warnings,
              };
              const { selectedIceCandidatePairStats } =
                this._rtcIceCandidateStatsReport;
              if (selectedIceCandidatePairStats) {
                report.selectedIceCandidatePairStats =
                  selectedIceCandidatePairStats;
                report.isTurnRequired =
                  selectedIceCandidatePairStats.localCandidate.candidateType ===
                    'relay' ||
                  selectedIceCandidatePairStats.remoteCandidate
                    .candidateType === 'relay';
              }
              if (stats) {
                report.callQuality = this._getCallQuality(stats.mos.average);
              }
              return report;
            };
            PreflightTest.prototype._getRTCSampleTotals = function () {
              if (!this._latestSample) {
                return;
              }
              return { ...this._latestSample.totals };
            };
            PreflightTest.prototype._getRTCStats = function () {
              const firstMosSampleIdx = this._samples.findIndex(function (
                sample
              ) {
                return typeof sample.mos === 'number' && sample.mos > 0;
              });
              const samples =
                firstMosSampleIdx >= 0
                  ? this._samples.slice(firstMosSampleIdx)
                  : [];
              if (!samples || !samples.length) {
                return;
              }
              return ['jitter', 'mos', 'rtt'].reduce(function (statObj, stat) {
                let _a;
                const values = samples.map(function (s) {
                  return s[stat];
                });
                return {
                  ...statObj,
                  ...((_a = {}),
                  (_a[stat] = {
                    average: Number(
                      (
                        values.reduce(function (total, value) {
                          return total + value;
                        }) / values.length
                      ).toPrecision(5)
                    ),
                    max: Math.max.apply(Math, values),
                    min: Math.min.apply(Math, values),
                  }),
                  _a),
                };
              }, {});
            };
            PreflightTest.prototype._getStreamFromFile = function () {
              const { audioContext } = this._options;
              if (!audioContext) {
                throw new errors_1.NotSupportedError(
                  'Cannot fake input audio stream: AudioContext is not supported by this browser.'
                );
              }
              const audioEl = new Audio(COWBELL_AUDIO_URL);
              audioEl.addEventListener('canplaythrough', function () {
                return audioEl.play();
              });
              if (typeof audioEl.setAttribute === 'function') {
                audioEl.setAttribute('crossorigin', 'anonymous');
              }
              const src = audioContext.createMediaElementSource(audioEl);
              const dest = audioContext.createMediaStreamDestination();
              src.connect(dest);
              return dest.stream;
            };
            PreflightTest.prototype._initDevice = function (token, options) {
              const _this = this;
              try {
                this._device = new (options.deviceFactory || device_1.default)(
                  token,
                  {
                    codecPreferences: options.codecPreferences,
                    edge: options.edge,
                    fileInputStream: options.fileInputStream,
                    logLevel: options.logLevel,
                    preflight: true,
                  }
                );
                this._device.once(
                  device_1.default.EventName.Registered,
                  function () {
                    _this._onDeviceRegistered();
                  }
                );
                this._device.once(
                  device_1.default.EventName.Error,
                  function (error) {
                    _this._onDeviceError(error);
                  }
                );
                this._device.register();
              } catch (error) {
                setTimeout(function () {
                  _this._onFailed(error);
                });
                return;
              }
              this._signalingTimeoutTimer = setTimeout(function () {
                _this._onDeviceError(
                  new errors_1.SignalingErrors.ConnectionError(
                    'WebSocket Connection Timeout'
                  )
                );
              }, options.signalingTimeoutMs);
            };
            PreflightTest.prototype._onDeviceError = function (error) {
              this._device.destroy();
              this._onFailed(error);
            };
            PreflightTest.prototype._onDeviceRegistered = function () {
              return __awaiter(this, void 0, void 0, function () {
                let _a;
                let audio;
                let publisher;
                const _this = this;
                return __generator(this, function (_b) {
                  switch (_b.label) {
                    case 0:
                      clearTimeout(this._echoTimer);
                      clearTimeout(this._signalingTimeoutTimer);
                      _a = this;
                      return [
                        4,
                        this._device.connect({
                          rtcConfiguration: this._options.rtcConfiguration,
                        }),
                      ];
                    case 1:
                      _a._call = _b.sent();
                      this._networkTiming.signaling = { start: Date.now() };
                      this._setupCallHandlers(this._call);
                      this._edge = this._device.edge || undefined;
                      if (this._options.fakeMicInput) {
                        this._echoTimer = setTimeout(function () {
                          return _this._device.disconnectAll();
                        }, ECHO_TEST_DURATION);
                        audio = this._device.audio;
                        if (audio) {
                          audio.disconnect(false);
                          audio.outgoing(false);
                        }
                      }
                      this._call.once('disconnect', function () {
                        _this._device.once(
                          device_1.default.EventName.Unregistered,
                          function () {
                            return _this._onUnregistered();
                          }
                        );
                        _this._device.destroy();
                      });
                      publisher = this._call._publisher;
                      publisher.on('error', function () {
                        if (!_this._hasInsightsErrored) {
                          _this._emitWarning(
                            'insights-connection-error',
                            'Received an error when attempting to connect to Insights gateway'
                          );
                        }
                        _this._hasInsightsErrored = true;
                      });
                      return [2];
                  }
                });
              });
            };
            PreflightTest.prototype._onFailed = function (error) {
              clearTimeout(this._echoTimer);
              clearTimeout(this._signalingTimeoutTimer);
              this._releaseHandlers();
              this._endTime = Date.now();
              this._status = PreflightTest.Status.Failed;
              this.emit(PreflightTest.Events.Failed, error);
            };
            PreflightTest.prototype._onUnregistered = function () {
              const _this = this;
              setTimeout(function () {
                if (_this._status === PreflightTest.Status.Failed) {
                  return;
                }
                clearTimeout(_this._echoTimer);
                clearTimeout(_this._signalingTimeoutTimer);
                _this._releaseHandlers();
                _this._endTime = Date.now();
                _this._status = PreflightTest.Status.Completed;
                _this._report = _this._getReport();
                _this.emit(PreflightTest.Events.Completed, _this._report);
              }, 10);
            };
            PreflightTest.prototype._releaseHandlers = function () {
              [this._device, this._call].forEach(function (emitter) {
                if (emitter) {
                  emitter.eventNames().forEach(function (name) {
                    return emitter.removeAllListeners(name);
                  });
                }
              });
            };
            PreflightTest.prototype._setupCallHandlers = function (call) {
              const _this = this;
              if (this._options.fakeMicInput) {
                call.once('volume', function () {
                  call._mediaHandler.outputs.forEach(function (output) {
                    return (output.audio.muted = true);
                  });
                });
              }
              call.on('warning', function (name, data) {
                _this._emitWarning(
                  name,
                  'Received an RTCWarning. See .rtcWarning for the RTCWarning',
                  data
                );
              });
              call.once('accept', function () {
                _this._callSid = call._mediaHandler.callSid;
                _this._status = PreflightTest.Status.Connected;
                _this.emit(PreflightTest.Events.Connected);
              });
              call.on('sample', function (sample) {
                return __awaiter(_this, void 0, void 0, function () {
                  let _a;
                  return __generator(this, function (_b) {
                    switch (_b.label) {
                      case 0:
                        if (Boolean(this._latestSample)) return [3, 2];
                        _a = this;
                        return [
                          4,
                          (
                            this._options.getRTCIceCandidateStatsReport ||
                            stats_1.getRTCIceCandidateStatsReport
                          )(call._mediaHandler.version.pc),
                        ];
                      case 1:
                        _a._rtcIceCandidateStatsReport = _b.sent();
                        _b.label = 2;
                      case 2:
                        this._latestSample = sample;
                        this._samples.push(sample);
                        this.emit(PreflightTest.Events.Sample, sample);
                        return [2];
                    }
                  });
                });
              });
              [
                { reportLabel: 'peerConnection', type: 'pcconnection' },
                { reportLabel: 'ice', type: 'iceconnection' },
                { reportLabel: 'dtls', type: 'dtlstransport' },
                { reportLabel: 'signaling', type: 'signaling' },
              ].forEach(function (_a) {
                const { type } = _a;
                const { reportLabel } = _a;
                const handlerName = `on${type}statechange`;
                const originalHandler = call._mediaHandler[handlerName];
                call._mediaHandler[handlerName] = function (state) {
                  const timing = (_this._networkTiming[reportLabel] = _this
                    ._networkTiming[reportLabel] || {
                    start: 0,
                  });
                  if (state === 'connecting' || state === 'checking') {
                    timing.start = Date.now();
                  } else if (
                    (state === 'connected' || state === 'stable') &&
                    !timing.duration
                  ) {
                    timing.end = Date.now();
                    timing.duration = timing.end - timing.start;
                  }
                  originalHandler(state);
                };
              });
            };
            Object.defineProperty(PreflightTest.prototype, 'callSid', {
              get() {
                return this._callSid;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(PreflightTest.prototype, 'endTime', {
              get() {
                return this._endTime;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(PreflightTest.prototype, 'latestSample', {
              get() {
                return this._latestSample;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(PreflightTest.prototype, 'report', {
              get() {
                return this._report;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(PreflightTest.prototype, 'startTime', {
              get() {
                return this._startTime;
              },
              enumerable: true,
              configurable: true,
            });
            Object.defineProperty(PreflightTest.prototype, 'status', {
              get() {
                return this._status;
              },
              enumerable: true,
              configurable: true,
            });
            return PreflightTest;
          })(events_1.EventEmitter);
          exports.PreflightTest = PreflightTest;
          (function (PreflightTest) {
            let CallQuality;
            (function (CallQuality) {
              CallQuality.Excellent = 'excellent';
              CallQuality.Great = 'great';
              CallQuality.Good = 'good';
              CallQuality.Fair = 'fair';
              CallQuality.Degraded = 'degraded';
            })(
              (CallQuality =
                PreflightTest.CallQuality || (PreflightTest.CallQuality = {}))
            );
            let Events;
            (function (Events) {
              Events.Completed = 'completed';
              Events.Connected = 'connected';
              Events.Failed = 'failed';
              Events.Sample = 'sample';
              Events.Warning = 'warning';
            })((Events = PreflightTest.Events || (PreflightTest.Events = {})));
            let Status;
            (function (Status) {
              Status.Connecting = 'connecting';
              Status.Connected = 'connected';
              Status.Completed = 'completed';
              Status.Failed = 'failed';
            })((Status = PreflightTest.Status || (PreflightTest.Status = {})));
          })(
            (PreflightTest =
              exports.PreflightTest || (exports.PreflightTest = {}))
          );
          exports.PreflightTest = PreflightTest;
        },
        {
          '../call': 6,
          '../constants': 7,
          '../device': 9,
          '../errors': 12,
          '../rtc/stats': 29,
          events: 48,
        },
      ],
      18: [
        function (require, module, exports) {
          function _toConsumableArray(arr) {
            if (Array.isArray(arr)) {
              for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
              }
              return arr2;
            }
            return Array.from(arr);
          }
          const C = require('./constants');
          const { EventEmitter } = require('events');
          const Log = require('./log').default;
          const util = require('util');
          const WSTransport = require('./wstransport').default;
          const _require = require('./errors');
          const { GeneralErrors } = _require;
          const { SignalingErrors } = _require;
          const PSTREAM_VERSION = '1.5';
          function PStream(token, uris, options) {
            if (!(this instanceof PStream)) {
              return new PStream(token, uris, options);
            }
            const defaults = { TransportFactory: WSTransport };
            options = options || {};
            for (const prop in defaults) {
              if (prop in options) continue;
              options[prop] = defaults[prop];
            }
            this.options = options;
            this.token = token || '';
            this.status = 'disconnected';
            this.gateway = null;
            this.region = null;
            this._messageQueue = [];
            this._uris = uris;
            this._handleTransportClose = this._handleTransportClose.bind(this);
            this._handleTransportError = this._handleTransportError.bind(this);
            this._handleTransportMessage =
              this._handleTransportMessage.bind(this);
            this._handleTransportOpen = this._handleTransportOpen.bind(this);
            this._log = Log.getInstance();
            this.on('error', function () {});
            const self = this;
            this.addListener('ready', function () {
              self.status = 'ready';
            });
            this.addListener('offline', function () {
              self.status = 'offline';
            });
            this.addListener('close', function () {
              self._log.info(
                'Received "close" from server. Destroying PStream...'
              );
              self._destroy();
            });
            this.transport = new this.options.TransportFactory(this._uris, {
              backoffMaxMs: this.options.backoffMaxMs,
            });
            Object.defineProperties(this, {
              uri: {
                enumerable: true,
                get: function get() {
                  return this.transport.uri;
                },
              },
            });
            this.transport.on('close', this._handleTransportClose);
            this.transport.on('error', this._handleTransportError);
            this.transport.on('message', this._handleTransportMessage);
            this.transport.on('open', this._handleTransportOpen);
            this.transport.open();
            return this;
          }
          util.inherits(PStream, EventEmitter);
          PStream.prototype._handleTransportClose = function () {
            this.emit('transportClose');
            if (this.status !== 'disconnected') {
              if (this.status !== 'offline') {
                this.emit('offline', this);
              }
              this.status = 'disconnected';
            }
          };
          PStream.prototype._handleTransportError = function (error) {
            if (!error) {
              this.emit('error', {
                error: {
                  code: 31e3,
                  message: 'Websocket closed without a provided reason',
                  twilioError: new SignalingErrors.ConnectionDisconnected(),
                },
              });
              return;
            }
            this.emit(
              'error',
              typeof error.code !== 'undefined' ? { error } : error
            );
          };
          PStream.prototype._handleTransportMessage = function (msg) {
            if (!msg || !msg.data || typeof msg.data !== 'string') {
              return;
            }
            const _JSON$parse = JSON.parse(msg.data);
            const { type } = _JSON$parse;
            const _JSON$parse$payload = _JSON$parse.payload;
            const payload =
              _JSON$parse$payload === undefined ? {} : _JSON$parse$payload;
            this.gateway = payload.gateway || this.gateway;
            this.region = payload.region || this.region;
            if (type === 'error' && payload.error) {
              payload.error.twilioError = new SignalingErrors.ConnectionError();
            }
            this.emit(type, payload);
          };
          PStream.prototype._handleTransportOpen = function () {
            const _this = this;
            this.status = 'connected';
            this.setToken(this.token);
            const messages = this._messageQueue.splice(
              0,
              this._messageQueue.length
            );
            messages.forEach(function (message) {
              return _this._publish.apply(_this, _toConsumableArray(message));
            });
          };
          PStream.toString = function () {
            return '[Twilio.PStream class]';
          };
          PStream.prototype.toString = function () {
            return '[Twilio.PStream instance]';
          };
          PStream.prototype.setToken = function (token) {
            this._log.info('Setting token and publishing listen');
            this.token = token;
            const payload = { token, browserinfo: getBrowserInfo() };
            this._publish('listen', payload);
          };
          PStream.prototype.register = function (mediaCapabilities) {
            const regPayload = { media: mediaCapabilities };
            this._publish('register', regPayload, true);
          };
          PStream.prototype.invite = function (
            sdp,
            callsid,
            preflight,
            params
          ) {
            const payload = {
              callsid,
              sdp,
              preflight: Boolean(preflight),
              twilio: params ? { params } : {},
            };
            this._publish('invite', payload, true);
          };
          PStream.prototype.answer = function (sdp, callsid) {
            this._publish('answer', { sdp, callsid }, true);
          };
          PStream.prototype.dtmf = function (callsid, digits) {
            this._publish('dtmf', { callsid, dtmf: digits }, true);
          };
          PStream.prototype.hangup = function (callsid, message) {
            const payload = message ? { callsid, message } : { callsid };
            this._publish('hangup', payload, true);
          };
          PStream.prototype.reject = function (callsid) {
            this._publish('reject', { callsid }, true);
          };
          PStream.prototype.reinvite = function (sdp, callsid) {
            this._publish('reinvite', { sdp, callsid }, false);
          };
          PStream.prototype._destroy = function () {
            this.transport.removeListener('close', this._handleTransportClose);
            this.transport.removeListener('error', this._handleTransportError);
            this.transport.removeListener(
              'message',
              this._handleTransportMessage
            );
            this.transport.removeListener('open', this._handleTransportOpen);
            this.transport.close();
            this.emit('offline', this);
          };
          PStream.prototype.destroy = function () {
            this._log.info('PStream.destroy() called...');
            this._destroy();
            return this;
          };
          PStream.prototype.publish = function (type, payload) {
            return this._publish(type, payload, true);
          };
          PStream.prototype._publish = function (type, payload, shouldRetry) {
            const msg = JSON.stringify({
              type,
              version: PSTREAM_VERSION,
              payload,
            });
            const isSent = Boolean(this.transport.send(msg));
            if (!isSent) {
              this.emit('error', {
                error: {
                  code: 31009,
                  message: 'No transport available to send or receive messages',
                  twilioError: new GeneralErrors.TransportError(),
                },
              });
              if (shouldRetry) {
                this._messageQueue.push([type, payload, true]);
              }
            }
          };
          function getBrowserInfo() {
            const nav = typeof navigator !== 'undefined' ? navigator : {};
            return {
              p: 'browser',
              v: C.RELEASE_VERSION,
              browser: {
                userAgent: nav.userAgent || 'unknown',
                platform: nav.platform || 'unknown',
              },
              plugin: 'rtc',
            };
          }
          module.exports = PStream;
        },
        {
          './constants': 7,
          './errors': 12,
          './log': 15,
          './wstransport': 36,
          events: 48,
          util: 60,
        },
      ],
      19: [
        function (require, module, exports) {
          let _a;
          let _b;
          let _c;
          let _d;
          Object.defineProperty(exports, '__esModule', { value: true });
          const errors_1 = require('./errors');
          let DeprecatedRegion;
          (function (DeprecatedRegion) {
            DeprecatedRegion.Au = 'au';
            DeprecatedRegion.Br = 'br';
            DeprecatedRegion.Ie = 'ie';
            DeprecatedRegion.Jp = 'jp';
            DeprecatedRegion.Sg = 'sg';
            DeprecatedRegion.UsOr = 'us-or';
            DeprecatedRegion.UsVa = 'us-va';
          })(
            (DeprecatedRegion =
              exports.DeprecatedRegion || (exports.DeprecatedRegion = {}))
          );
          let Edge;
          (function (Edge) {
            Edge.Sydney = 'sydney';
            Edge.SaoPaulo = 'sao-paulo';
            Edge.Dublin = 'dublin';
            Edge.Frankfurt = 'frankfurt';
            Edge.Tokyo = 'tokyo';
            Edge.Singapore = 'singapore';
            Edge.Ashburn = 'ashburn';
            Edge.Umatilla = 'umatilla';
            Edge.Roaming = 'roaming';
            Edge.AshburnIx = 'ashburn-ix';
            Edge.SanJoseIx = 'san-jose-ix';
            Edge.LondonIx = 'london-ix';
            Edge.FrankfurtIx = 'frankfurt-ix';
            Edge.SingaporeIx = 'singapore-ix';
            Edge.SydneyIx = 'sydney-ix';
            Edge.TokyoIx = 'tokyo-ix';
          })((Edge = exports.Edge || (exports.Edge = {})));
          let Region;
          (function (Region) {
            Region.Au1 = 'au1';
            Region.Au1Ix = 'au1-ix';
            Region.Br1 = 'br1';
            Region.De1 = 'de1';
            Region.De1Ix = 'de1-ix';
            Region.Gll = 'gll';
            Region.Ie1 = 'ie1';
            Region.Ie1Ix = 'ie1-ix';
            Region.Ie1Tnx = 'ie1-tnx';
            Region.Jp1 = 'jp1';
            Region.Jp1Ix = 'jp1-ix';
            Region.Sg1 = 'sg1';
            Region.Sg1Ix = 'sg1-ix';
            Region.Sg1Tnx = 'sg1-tnx';
            Region.Us1 = 'us1';
            Region.Us1Ix = 'us1-ix';
            Region.Us1Tnx = 'us1-tnx';
            Region.Us2 = 'us2';
            Region.Us2Ix = 'us2-ix';
            Region.Us2Tnx = 'us2-tnx';
          })((Region = exports.Region || (exports.Region = {})));
          exports.deprecatedRegions =
            ((_a = {}),
            (_a[DeprecatedRegion.Au] = Region.Au1),
            (_a[DeprecatedRegion.Br] = Region.Br1),
            (_a[DeprecatedRegion.Ie] = Region.Ie1),
            (_a[DeprecatedRegion.Jp] = Region.Jp1),
            (_a[DeprecatedRegion.Sg] = Region.Sg1),
            (_a[DeprecatedRegion.UsOr] = Region.Us1),
            (_a[DeprecatedRegion.UsVa] = Region.Us1),
            _a);
          exports.regionShortcodes = {
            ASIAPAC_SINGAPORE: Region.Sg1,
            ASIAPAC_SYDNEY: Region.Au1,
            ASIAPAC_TOKYO: Region.Jp1,
            EU_FRANKFURT: Region.De1,
            EU_IRELAND: Region.Ie1,
            SOUTH_AMERICA_SAO_PAULO: Region.Br1,
            US_EAST_VIRGINIA: Region.Us1,
            US_WEST_OREGON: Region.Us2,
          };
          const regionURIs =
            ((_b = {}),
            (_b[Region.Au1] = 'chunderw-vpc-gll-au1.twilio.com'),
            (_b[Region.Au1Ix] = 'chunderw-vpc-gll-au1-ix.twilio.com'),
            (_b[Region.Br1] = 'chunderw-vpc-gll-br1.twilio.com'),
            (_b[Region.De1] = 'chunderw-vpc-gll-de1.twilio.com'),
            (_b[Region.De1Ix] = 'chunderw-vpc-gll-de1-ix.twilio.com'),
            (_b[Region.Gll] = 'chunderw-vpc-gll.twilio.com'),
            (_b[Region.Ie1] = 'chunderw-vpc-gll-ie1.twilio.com'),
            (_b[Region.Ie1Ix] = 'chunderw-vpc-gll-ie1-ix.twilio.com'),
            (_b[Region.Ie1Tnx] = 'chunderw-vpc-gll-ie1-tnx.twilio.com'),
            (_b[Region.Jp1] = 'chunderw-vpc-gll-jp1.twilio.com'),
            (_b[Region.Jp1Ix] = 'chunderw-vpc-gll-jp1-ix.twilio.com'),
            (_b[Region.Sg1] = 'chunderw-vpc-gll-sg1.twilio.com'),
            (_b[Region.Sg1Ix] = 'chunderw-vpc-gll-sg1-ix.twilio.com'),
            (_b[Region.Sg1Tnx] = 'chunderw-vpc-gll-sg1-tnx.twilio.com'),
            (_b[Region.Us1] = 'chunderw-vpc-gll-us1.twilio.com'),
            (_b[Region.Us1Ix] = 'chunderw-vpc-gll-us1-ix.twilio.com'),
            (_b[Region.Us1Tnx] = 'chunderw-vpc-gll-us1-tnx.twilio.com'),
            (_b[Region.Us2] = 'chunderw-vpc-gll-us2.twilio.com'),
            (_b[Region.Us2Ix] = 'chunderw-vpc-gll-us2-ix.twilio.com'),
            (_b[Region.Us2Tnx] = 'chunderw-vpc-gll-us2-tnx.twilio.com'),
            _b);
          exports.edgeToRegion =
            ((_c = {}),
            (_c[Edge.Sydney] = Region.Au1),
            (_c[Edge.SaoPaulo] = Region.Br1),
            (_c[Edge.Dublin] = Region.Ie1),
            (_c[Edge.Frankfurt] = Region.De1),
            (_c[Edge.Tokyo] = Region.Jp1),
            (_c[Edge.Singapore] = Region.Sg1),
            (_c[Edge.Ashburn] = Region.Us1),
            (_c[Edge.Umatilla] = Region.Us2),
            (_c[Edge.Roaming] = Region.Gll),
            (_c[Edge.AshburnIx] = Region.Us1Ix),
            (_c[Edge.SanJoseIx] = Region.Us2Ix),
            (_c[Edge.LondonIx] = Region.Ie1Ix),
            (_c[Edge.FrankfurtIx] = Region.De1Ix),
            (_c[Edge.SingaporeIx] = Region.Sg1Ix),
            (_c[Edge.SydneyIx] = Region.Au1Ix),
            (_c[Edge.TokyoIx] = Region.Jp1Ix),
            _c);
          exports.regionToEdge =
            ((_d = {}),
            (_d[Region.Au1] = Edge.Sydney),
            (_d[Region.Br1] = Edge.SaoPaulo),
            (_d[Region.Ie1] = Edge.Dublin),
            (_d[Region.De1] = Edge.Frankfurt),
            (_d[Region.Jp1] = Edge.Tokyo),
            (_d[Region.Sg1] = Edge.Singapore),
            (_d[Region.Us1] = Edge.Ashburn),
            (_d[Region.Us2] = Edge.Umatilla),
            (_d[Region.Gll] = Edge.Roaming),
            (_d[Region.Us1Ix] = Edge.AshburnIx),
            (_d[Region.Us2Ix] = Edge.SanJoseIx),
            (_d[Region.Ie1Ix] = Edge.LondonIx),
            (_d[Region.De1Ix] = Edge.FrankfurtIx),
            (_d[Region.Sg1Ix] = Edge.SingaporeIx),
            (_d[Region.Au1Ix] = Edge.SydneyIx),
            (_d[Region.Jp1Ix] = Edge.TokyoIx),
            (_d[Region.Us1Tnx] = Edge.AshburnIx),
            (_d[Region.Us2Tnx] = Edge.AshburnIx),
            (_d[Region.Ie1Tnx] = Edge.LondonIx),
            (_d[Region.Sg1Tnx] = Edge.SingaporeIx),
            _d);
          exports.defaultRegion = 'gll';
          exports.defaultEdge = Edge.Roaming;
          exports.defaultChunderRegionURI = 'chunderw-vpc-gll.twilio.com';
          function createChunderRegionUri(region) {
            return region === exports.defaultRegion
              ? exports.defaultChunderRegionURI
              : `chunderw-vpc-gll-${region}.twilio.com`;
          }
          function createChunderEdgeUri(edge) {
            return `voice-js.${edge}.twilio.com`;
          }
          function getChunderURIs(edge, region, onDeprecated) {
            if (Boolean(region) && typeof region !== 'string') {
              throw new errors_1.InvalidArgumentError(
                'If `region` is provided, it must be of type `string`.'
              );
            }
            if (
              Boolean(edge) &&
              typeof edge !== 'string' &&
              !Array.isArray(edge)
            ) {
              throw new errors_1.InvalidArgumentError(
                'If `edge` is provided, it must be of type `string` or an array of strings.'
              );
            }
            const deprecatedMessages = [];
            let uris;
            if (region && edge) {
              throw new errors_1.InvalidArgumentError(
                'You cannot specify `region` when `edge` is specified in' +
                  '`Twilio.Device.Options`.'
              );
            } else if (region) {
              let chunderRegion = region;
              deprecatedMessages.push(
                'Regions are deprecated in favor of edges. Please see this page for ' +
                  'documentation: https://www.twilio.com/docs/voice/client/edges.'
              );
              const isDeprecatedRegion =
                Object.values(DeprecatedRegion).includes(chunderRegion);
              if (isDeprecatedRegion) {
                chunderRegion = exports.deprecatedRegions[chunderRegion];
              }
              const isKnownRegion =
                Object.values(Region).includes(chunderRegion);
              if (isKnownRegion) {
                const preferredEdge = exports.regionToEdge[chunderRegion];
                deprecatedMessages.push(
                  `Region "${chunderRegion}" is deprecated, please use \`edge\` ` +
                    `"${preferredEdge}".`
                );
              }
              uris = [createChunderRegionUri(chunderRegion)];
            } else if (edge) {
              const edgeValues_1 = Object.values(Edge);
              const edgeParams = Array.isArray(edge) ? edge : [edge];
              uris = edgeParams.map(function (param) {
                return edgeValues_1.includes(param)
                  ? createChunderRegionUri(exports.edgeToRegion[param])
                  : createChunderEdgeUri(param);
              });
            } else {
              uris = [exports.defaultChunderRegionURI];
            }
            if (onDeprecated && deprecatedMessages.length) {
              setTimeout(function () {
                return onDeprecated(deprecatedMessages.join('\n'));
              });
            }
            return uris;
          }
          exports.getChunderURIs = getChunderURIs;
          function getRegionShortcode(region) {
            return exports.regionShortcodes[region] || null;
          }
          exports.getRegionShortcode = getRegionShortcode;
        },
        { './errors': 12 },
      ],
      20: [
        function (require, module, exports) {
          const XHR = require('xmlhttprequest').XMLHttpRequest;
          function request(method, params, callback) {
            const options = {};
            options.XMLHttpRequest = options.XMLHttpRequest || XHR;
            const xhr = new options.XMLHttpRequest();
            xhr.open(method, params.url, true);
            xhr.onreadystatechange = function onreadystatechange() {
              if (xhr.readyState !== 4) {
                return;
              }
              if (xhr.status >= 200 && xhr.status < 300) {
                callback(null, xhr.responseText);
                return;
              }
              callback(new Error(xhr.responseText));
            };
            for (const headerName in params.headers) {
              xhr.setRequestHeader(headerName, params.headers[headerName]);
            }
            xhr.send(JSON.stringify(params.body));
          }
          const Request = request;
          Request.get = function get(params, callback) {
            return new this('GET', params, callback);
          };
          Request.post = function post(params, callback) {
            return new this('POST', params, callback);
          };
          module.exports = Request;
        },
        { xmlhttprequest: 2 },
      ],
      21: [
        function (require, module, exports) {
          const _typeof =
            typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
              ? function (obj) {
                  return typeof obj;
                }
              : function (obj) {
                  return obj &&
                    typeof Symbol === 'function' &&
                    obj.constructor === Symbol &&
                    obj !== Symbol.prototype
                    ? 'symbol'
                    : typeof obj;
                };
          const { NotSupportedError } = require('../errors');
          const util = require('../util');
          function getUserMedia(constraints, options) {
            options = options || {};
            options.util = options.util || util;
            options.navigator =
              options.navigator ||
              (typeof navigator !== 'undefined' ? navigator : null);
            return new Promise(function (resolve, reject) {
              if (!options.navigator) {
                throw new NotSupportedError('getUserMedia is not supported');
              }
              switch ('function') {
                case _typeof(
                  options.navigator.mediaDevices &&
                    options.navigator.mediaDevices.getUserMedia
                ):
                  return resolve(
                    options.navigator.mediaDevices.getUserMedia(constraints)
                  );
                case _typeof(options.navigator.webkitGetUserMedia):
                  return options.navigator.webkitGetUserMedia(
                    constraints,
                    resolve,
                    reject
                  );
                case _typeof(options.navigator.mozGetUserMedia):
                  return options.navigator.mozGetUserMedia(
                    constraints,
                    resolve,
                    reject
                  );
                case _typeof(options.navigator.getUserMedia):
                  return options.navigator.getUserMedia(
                    constraints,
                    resolve,
                    reject
                  );
                default:
                  throw new NotSupportedError('getUserMedia is not supported');
              }
            }).catch(function (e) {
              throw options.util.isFirefox() && e.name === 'NotReadableError'
                ? new NotSupportedError(
                    'Firefox does not currently support opening multiple audio input tracks' +
                      'simultaneously, even across different tabs.\n' +
                      'Related Bugzilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'
                  )
                : e;
            });
          }
          module.exports = getUserMedia;
        },
        { '../errors': 12, '../util': 35 },
      ],
      22: [
        function (require, module, exports) {
          Object.defineProperty(exports, '__esModule', { value: true });
          const IceCandidate = (function () {
            function IceCandidate(iceCandidate, isRemote) {
              if (isRemote === void 0) {
                isRemote = false;
              }
              this.deleted = false;
              let cost;
              const parts = iceCandidate.candidate.split('network-cost ');
              if (parts[1]) {
                cost = parseInt(parts[1], 10);
              }
              this.candidateType = iceCandidate.type;
              this.ip = iceCandidate.ip || iceCandidate.address;
              this.isRemote = isRemote;
              this.networkCost = cost;
              this.port = iceCandidate.port;
              this.priority = iceCandidate.priority;
              this.protocol = iceCandidate.protocol;
              this.relatedAddress = iceCandidate.relatedAddress;
              this.relatedPort = iceCandidate.relatedPort;
              this.tcpType = iceCandidate.tcpType;
              this.transportId = iceCandidate.sdpMid;
            }
            IceCandidate.prototype.toPayload = function () {
              return {
                candidate_type: this.candidateType,
                deleted: this.deleted,
                ip: this.ip,
                is_remote: this.isRemote,
                'network-cost': this.networkCost,
                port: this.port,
                priority: this.priority,
                protocol: this.protocol,
                related_address: this.relatedAddress,
                related_port: this.relatedPort,
                tcp_type: this.tcpType,
                transport_id: this.transportId,
              };
            };
            return IceCandidate;
          })();
          exports.IceCandidate = IceCandidate;
        },
        {},
      ],
      23: [
        function (require, module, exports) {
          const PeerConnection = require('./peerconnection');
          const _require = require('./rtcpc');
          const { test } = _require;
          function enabled() {
            return test();
          }
          function getMediaEngine() {
            return typeof RTCIceGatherer !== 'undefined' ? 'ORTC' : 'WebRTC';
          }
          module.exports = {
            enabled,
            getMediaEngine,
            PeerConnection,
          };
        },
        { './peerconnection': 26, './rtcpc': 27 },
      ],
      24: [
        function (require, module, exports) {
          const OLD_MAX_VOLUME = 32767;
          const NativeRTCStatsReport =
            typeof window !== 'undefined' ? window.RTCStatsReport : undefined;
          function MockRTCStatsReport(statsMap) {
            if (!(this instanceof MockRTCStatsReport)) {
              return new MockRTCStatsReport(statsMap);
            }
            const self = this;
            Object.defineProperties(this, {
              size: {
                enumerable: true,
                get() {
                  return self._map.size;
                },
              },
              _map: { value: statsMap },
            });
            this[Symbol.iterator] = statsMap[Symbol.iterator];
          }
          if (NativeRTCStatsReport) {
            MockRTCStatsReport.prototype = Object.create(
              NativeRTCStatsReport.prototype
            );
            MockRTCStatsReport.prototype.constructor = MockRTCStatsReport;
          }
          ['entries', 'forEach', 'get', 'has', 'keys', 'values'].forEach(
            function (key) {
              MockRTCStatsReport.prototype[key] = function () {
                let _a;
                const args = [];
                for (let _i = 0; _i < arguments.length; _i++) {
                  args[_i] = arguments[_i];
                }
                return (_a = this._map)[key].apply(_a, args);
              };
            }
          );
          MockRTCStatsReport.fromArray = function fromArray(array) {
            return new MockRTCStatsReport(
              array.reduce(function (map, rtcStats) {
                map.set(rtcStats.id, rtcStats);
                return map;
              }, new Map())
            );
          };
          MockRTCStatsReport.fromRTCStatsResponse =
            function fromRTCStatsResponse(statsResponse) {
              let activeCandidatePairId;
              const transportIds = new Map();
              const statsMap = statsResponse
                .result()
                .reduce(function (map, report) {
                  const { id } = report;
                  switch (report.type) {
                    case 'googCertificate':
                      map.set(id, createRTCCertificateStats(report));
                      break;
                    case 'datachannel':
                      map.set(id, createRTCDataChannelStats(report));
                      break;
                    case 'googCandidatePair':
                      if (getBoolean(report, 'googActiveConnection')) {
                        activeCandidatePairId = id;
                      }
                      map.set(id, createRTCIceCandidatePairStats(report));
                      break;
                    case 'localcandidate':
                      map.set(id, createRTCIceCandidateStats(report, false));
                      break;
                    case 'remotecandidate':
                      map.set(id, createRTCIceCandidateStats(report, true));
                      break;
                    case 'ssrc':
                      if (isPresent(report, 'packetsReceived')) {
                        map.set(
                          `rtp-${id}`,
                          createRTCInboundRTPStreamStats(report)
                        );
                      } else {
                        map.set(
                          `rtp-${id}`,
                          createRTCOutboundRTPStreamStats(report)
                        );
                      }
                      map.set(
                        `track-${id}`,
                        createRTCMediaStreamTrackStats(report)
                      );
                      map.set(`codec-${id}`, createRTCCodecStats(report));
                      break;
                    case 'googComponent':
                      var transportReport = createRTCTransportStats(report);
                      transportIds.set(
                        transportReport.selectedCandidatePairId,
                        id
                      );
                      map.set(id, createRTCTransportStats(report));
                      break;
                  }
                  return map;
                }, new Map());
              if (activeCandidatePairId) {
                const activeTransportId = transportIds.get(
                  activeCandidatePairId
                );
                if (activeTransportId) {
                  statsMap.get(activeTransportId).dtlsState = 'connected';
                }
              }
              return new MockRTCStatsReport(statsMap);
            };
          function createRTCTransportStats(report) {
            return {
              type: 'transport',
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              bytesSent: undefined,
              bytesReceived: undefined,
              rtcpTransportStatsId: undefined,
              dtlsState: undefined,
              selectedCandidatePairId: report.stat('selectedCandidatePairId'),
              localCertificateId: report.stat('localCertificateId'),
              remoteCertificateId: report.stat('remoteCertificateId'),
            };
          }
          function createRTCCodecStats(report) {
            return {
              type: 'codec',
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              payloadType: undefined,
              mimeType: `${report.stat('mediaType')}/${report.stat(
                'googCodecName'
              )}`,
              clockRate: undefined,
              channels: undefined,
              sdpFmtpLine: undefined,
              implementation: undefined,
            };
          }
          function createRTCMediaStreamTrackStats(report) {
            return {
              type: 'track',
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              trackIdentifier: report.stat('googTrackId'),
              remoteSource: undefined,
              ended: undefined,
              kind: report.stat('mediaType'),
              detached: undefined,
              ssrcIds: undefined,
              frameWidth: isPresent(report, 'googFrameWidthReceived')
                ? getInt(report, 'googFrameWidthReceived')
                : getInt(report, 'googFrameWidthSent'),
              frameHeight: isPresent(report, 'googFrameHeightReceived')
                ? getInt(report, 'googFrameHeightReceived')
                : getInt(report, 'googFrameHeightSent'),
              framesPerSecond: undefined,
              framesSent: getInt(report, 'framesEncoded'),
              framesReceived: undefined,
              framesDecoded: getInt(report, 'framesDecoded'),
              framesDropped: undefined,
              framesCorrupted: undefined,
              partialFramesLost: undefined,
              fullFramesLost: undefined,
              audioLevel: isPresent(report, 'audioOutputLevel')
                ? getInt(report, 'audioOutputLevel') / OLD_MAX_VOLUME
                : (getInt(report, 'audioInputLevel') || 0) / OLD_MAX_VOLUME,
              echoReturnLoss: getFloat(
                report,
                'googEchoCancellationReturnLoss'
              ),
              echoReturnLossEnhancement: getFloat(
                report,
                'googEchoCancellationReturnLossEnhancement'
              ),
            };
          }
          function createRTCRTPStreamStats(report, isInbound) {
            return {
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              ssrc: report.stat('ssrc'),
              associateStatsId: undefined,
              isRemote: undefined,
              mediaType: report.stat('mediaType'),
              trackId: `track-${report.id}`,
              transportId: report.stat('transportId'),
              codecId: `codec-${report.id}`,
              firCount: isInbound ? getInt(report, 'googFirsSent') : undefined,
              pliCount: isInbound
                ? getInt(report, 'googPlisSent')
                : getInt(report, 'googPlisReceived'),
              nackCount: isInbound
                ? getInt(report, 'googNacksSent')
                : getInt(report, 'googNacksReceived'),
              sliCount: undefined,
              qpSum: getInt(report, 'qpSum'),
            };
          }
          function createRTCInboundRTPStreamStats(report) {
            const rtp = createRTCRTPStreamStats(report, true);
            Object.assign(rtp, {
              type: 'inbound-rtp',
              packetsReceived: getInt(report, 'packetsReceived'),
              bytesReceived: getInt(report, 'bytesReceived'),
              packetsLost: getInt(report, 'packetsLost'),
              jitter: convertMsToSeconds(report.stat('googJitterReceived')),
              fractionLost: undefined,
              roundTripTime: convertMsToSeconds(report.stat('googRtt')),
              packetsDiscarded: undefined,
              packetsRepaired: undefined,
              burstPacketsLost: undefined,
              burstPacketsDiscarded: undefined,
              burstLossCount: undefined,
              burstDiscardCount: undefined,
              burstLossRate: undefined,
              burstDiscardRate: undefined,
              gapLossRate: undefined,
              gapDiscardRate: undefined,
              framesDecoded: getInt(report, 'framesDecoded'),
            });
            return rtp;
          }
          function createRTCOutboundRTPStreamStats(report) {
            const rtp = createRTCRTPStreamStats(report, false);
            Object.assign(rtp, {
              type: 'outbound-rtp',
              remoteTimestamp: undefined,
              packetsSent: getInt(report, 'packetsSent'),
              bytesSent: getInt(report, 'bytesSent'),
              targetBitrate: undefined,
              framesEncoded: getInt(report, 'framesEncoded'),
            });
            return rtp;
          }
          function createRTCIceCandidateStats(report, isRemote) {
            return {
              type: isRemote ? 'remote-candidate' : 'local-candidate',
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              transportId: undefined,
              isRemote,
              ip: report.stat('ipAddress'),
              port: getInt(report, 'portNumber'),
              protocol: report.stat('transport'),
              candidateType: translateCandidateType(
                report.stat('candidateType')
              ),
              priority: getFloat(report, 'priority'),
              url: undefined,
              relayProtocol: undefined,
              deleted: undefined,
            };
          }
          function createRTCIceCandidatePairStats(report) {
            return {
              type: 'candidate-pair',
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              transportId: report.stat('googChannelId'),
              localCandidateId: report.stat('localCandidateId'),
              remoteCandidateId: report.stat('remoteCandidateId'),
              state: undefined,
              priority: undefined,
              nominated: undefined,
              writable: getBoolean(report, 'googWritable'),
              readable: undefined,
              bytesSent: getInt(report, 'bytesSent'),
              bytesReceived: getInt(report, 'bytesReceived'),
              lastPacketSentTimestamp: undefined,
              lastPacketReceivedTimestamp: undefined,
              totalRoundTripTime: undefined,
              currentRoundTripTime: convertMsToSeconds(report.stat('googRtt')),
              availableOutgoingBitrate: undefined,
              availableIncomingBitrate: undefined,
              requestsReceived: getInt(report, 'requestsReceived'),
              requestsSent: getInt(report, 'requestsSent'),
              responsesReceived: getInt(report, 'responsesReceived'),
              responsesSent: getInt(report, 'responsesSent'),
              retransmissionsReceived: undefined,
              retransmissionsSent: undefined,
              consentRequestsSent: getInt(report, 'consentRequestsSent'),
            };
          }
          function createRTCCertificateStats(report) {
            return {
              type: 'certificate',
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              fingerprint: report.stat('googFingerprint'),
              fingerprintAlgorithm: report.stat('googFingerprintAlgorithm'),
              base64Certificate: report.stat('googDerBase64'),
              issuerCertificateId: report.stat('googIssuerId'),
            };
          }
          function createRTCDataChannelStats(report) {
            return {
              type: 'data-channel',
              id: report.id,
              timestamp: Date.parse(report.timestamp),
              label: report.stat('label'),
              protocol: report.stat('protocol'),
              datachannelid: report.stat('datachannelid'),
              transportId: report.stat('transportId'),
              state: report.stat('state'),
              messagesSent: undefined,
              bytesSent: undefined,
              messagesReceived: undefined,
              bytesReceived: undefined,
            };
          }
          function convertMsToSeconds(inMs) {
            return isNaN(inMs) || inMs === ''
              ? undefined
              : parseInt(inMs, 10) / 1e3;
          }
          function translateCandidateType(type) {
            switch (type) {
              case 'peerreflexive':
                return 'prflx';
              case 'serverreflexive':
                return 'srflx';
              case 'host':
              case 'relay':
              default:
                return type;
            }
          }
          function getInt(report, statName) {
            const stat = report.stat(statName);
            return isPresent(report, statName) ? parseInt(stat, 10) : undefined;
          }
          function getFloat(report, statName) {
            const stat = report.stat(statName);
            return isPresent(report, statName) ? parseFloat(stat) : undefined;
          }
          function getBoolean(report, statName) {
            const stat = report.stat(statName);
            return isPresent(report, statName)
              ? stat === 'true' || stat === true
              : undefined;
          }
          function isPresent(report, statName) {
            const stat = report.stat(statName);
            return typeof stat !== 'undefined' && stat !== '';
          }
          module.exports = MockRTCStatsReport;
        },
        {},
      ],
      25: [
        function (require, module, exports) {
          Object.defineProperty(exports, '__esModule', { value: true });
          const r0 = 94.768;
          function calculate(rtt, jitter, fractionLost) {
            if (
              typeof rtt !== 'number' ||
              typeof jitter !== 'number' ||
              typeof fractionLost !== 'number' ||
              !isNonNegativeNumber(rtt) ||
              !isNonNegativeNumber(jitter) ||
              !isNonNegativeNumber(fractionLost)
            ) {
              return null;
            }
            const effectiveLatency = rtt + jitter * 2 + 10;
            let rFactor = 0;
            switch (true) {
              case effectiveLatency < 160:
                rFactor = r0 - effectiveLatency / 40;
                break;
              case effectiveLatency < 1e3:
                rFactor = r0 - (effectiveLatency - 120) / 10;
                break;
            }
            switch (true) {
              case fractionLost <= rFactor / 2.5:
                rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);
                break;
              default:
                rFactor = 0;
                break;
            }
            return (
              1 +
              0.035 * rFactor +
              7e-6 * rFactor * (rFactor - 60) * (100 - rFactor)
            );
          }
          exports.calculate = calculate;
          function isNonNegativeNumber(n) {
            return typeof n === 'number' && !isNaN(n) && isFinite(n) && n >= 0;
          }
          exports.isNonNegativeNumber = isNonNegativeNumber;
          exports.default = {
            calculate,
            isNonNegativeNumber,
          };
        },
        {},
      ],
      26: [
        function (require, module, exports) {
          const _require = require('../errors');
          const { InvalidArgumentError } = _require;
          const { MediaErrors } = _require;
          const { NotSupportedError } = _require;
          const { SignalingErrors } = _require;
          const Log = require('../log').default;
          const util = require('../util');
          const RTCPC = require('./rtcpc');
          const _require2 = require('./sdp');
          const { setIceAggressiveNomination } = _require2;
          const ICE_GATHERING_TIMEOUT = 15e3;
          const ICE_GATHERING_FAIL_NONE = 'none';
          const ICE_GATHERING_FAIL_TIMEOUT = 'timeout';
          const INITIAL_ICE_CONNECTION_STATE = 'new';
          const VOLUME_INTERVAL_MS = 50;
          function PeerConnection(audioHelper, pstream, getUserMedia, options) {
            if (!audioHelper || !pstream || !getUserMedia) {
              throw new InvalidArgumentError(
                'Audiohelper, pstream and getUserMedia are required arguments'
              );
            }
            if (!(this instanceof PeerConnection)) {
              return new PeerConnection(
                audioHelper,
                pstream,
                getUserMedia,
                options
              );
            }
            function noop() {}
            this.onopen = noop;
            this.onerror = noop;
            this.onclose = noop;
            this.ondisconnected = noop;
            this.onfailed = noop;
            this.onconnected = noop;
            this.onreconnected = noop;
            this.onsignalingstatechange = noop;
            this.ondtlstransportstatechange = noop;
            this.onicegatheringfailure = noop;
            this.onicegatheringstatechange = noop;
            this.oniceconnectionstatechange = noop;
            this.onpcconnectionstatechange = noop;
            this.onicecandidate = noop;
            this.onselectedcandidatepairchange = noop;
            this.onvolume = noop;
            this.version = null;
            this.pstream = pstream;
            this.stream = null;
            this.sinkIds = new Set(['default']);
            this.outputs = new Map();
            this.status = 'connecting';
            this.callSid = null;
            this.isMuted = false;
            this.getUserMedia = getUserMedia;
            const AudioContext =
              typeof window !== 'undefined' &&
              (window.AudioContext || window.webkitAudioContext);
            this._isSinkSupported =
              Boolean(AudioContext) &&
              typeof HTMLAudioElement !== 'undefined' &&
              HTMLAudioElement.prototype.setSinkId;
            this._audioContext = AudioContext && audioHelper._audioContext;
            this._hasIceCandidates = false;
            this._hasIceGatheringFailures = false;
            this._iceGatheringTimeoutId = null;
            this._masterAudio = null;
            this._masterAudioDeviceId = null;
            this._mediaStreamSource = null;
            this._dtmfSender = null;
            this._dtmfSenderUnsupported = false;
            this._callEvents = [];
            this._nextTimeToPublish = Date.now();
            this._onAnswerOrRinging = noop;
            this._onHangup = noop;
            this._remoteStream = null;
            this._shouldManageStream = true;
            this._iceState = INITIAL_ICE_CONNECTION_STATE;
            this._isUnifiedPlan = options.isUnifiedPlan;
            this.options = options = options || {};
            this.navigator =
              options.navigator ||
              (typeof navigator !== 'undefined' ? navigator : null);
            this.util = options.util || util;
            this.codecPreferences = options.codecPreferences;
            this._log = Log.getInstance();
            return this;
          }
          PeerConnection.prototype.uri = function () {
            return this._uri;
          };
          PeerConnection.prototype.openWithConstraints = function (
            constraints
          ) {
            return this.getUserMedia({ audio: constraints }).then(
              this._setInputTracksFromStream.bind(this, false)
            );
          };
          PeerConnection.prototype.setInputTracksFromStream = function (
            stream
          ) {
            const self = this;
            return this._setInputTracksFromStream(true, stream).then(
              function () {
                self._shouldManageStream = false;
              }
            );
          };
          PeerConnection.prototype._createAnalyser = function (
            audioContext,
            options
          ) {
            options = {
              fftSize: 32,
              smoothingTimeConstant: 0.3,
              ...options,
            };
            const analyser = audioContext.createAnalyser();
            for (const field in options) {
              analyser[field] = options[field];
            }
            return analyser;
          };
          PeerConnection.prototype._setVolumeHandler = function (handler) {
            this.onvolume = handler;
          };
          PeerConnection.prototype._startPollingVolume = function () {
            if (!this._audioContext || !this.stream || !this._remoteStream) {
              return;
            }
            const audioContext = this._audioContext;
            const inputAnalyser = (this._inputAnalyser =
              this._createAnalyser(audioContext));
            const inputBufferLength = inputAnalyser.frequencyBinCount;
            const inputDataArray = new Uint8Array(inputBufferLength);
            this._inputAnalyser2 = this._createAnalyser(audioContext, {
              minDecibels: -127,
              maxDecibels: 0,
              smoothingTimeConstant: 0,
            });
            const outputAnalyser = (this._outputAnalyser =
              this._createAnalyser(audioContext));
            const outputBufferLength = outputAnalyser.frequencyBinCount;
            const outputDataArray = new Uint8Array(outputBufferLength);
            this._outputAnalyser2 = this._createAnalyser(audioContext, {
              minDecibels: -127,
              maxDecibels: 0,
              smoothingTimeConstant: 0,
            });
            this._updateInputStreamSource(this.stream);
            this._updateOutputStreamSource(this._remoteStream);
            const self = this;
            setTimeout(function emitVolume() {
              if (!self._audioContext) {
                return;
              } else if (self.status === 'closed') {
                self._inputAnalyser.disconnect();
                self._outputAnalyser.disconnect();
                self._inputAnalyser2.disconnect();
                self._outputAnalyser2.disconnect();
                return;
              }
              self._inputAnalyser.getByteFrequencyData(inputDataArray);
              const inputVolume = self.util.average(inputDataArray);
              self._inputAnalyser2.getByteFrequencyData(inputDataArray);
              const inputVolume2 = self.util.average(inputDataArray);
              self._outputAnalyser.getByteFrequencyData(outputDataArray);
              const outputVolume = self.util.average(outputDataArray);
              self._outputAnalyser2.getByteFrequencyData(outputDataArray);
              const outputVolume2 = self.util.average(outputDataArray);
              self.onvolume(
                inputVolume / 255,
                outputVolume / 255,
                inputVolume2,
                outputVolume2
              );
              setTimeout(emitVolume, VOLUME_INTERVAL_MS);
            }, VOLUME_INTERVAL_MS);
          };
          PeerConnection.prototype._stopStream = function _stopStream(stream) {
            if (!this._shouldManageStream) {
              return;
            }
            if (typeof MediaStreamTrack.prototype.stop === 'function') {
              const audioTracks =
                typeof stream.getAudioTracks === 'function'
                  ? stream.getAudioTracks()
                  : stream.audioTracks;
              audioTracks.forEach(function (track) {
                track.stop();
              });
            } else {
              stream.stop();
            }
          };
          PeerConnection.prototype._updateInputStreamSource = function (
            stream
          ) {
            if (this._inputStreamSource) {
              this._inputStreamSource.disconnect();
            }
            this._inputStreamSource =
              this._audioContext.createMediaStreamSource(stream);
            this._inputStreamSource.connect(this._inputAnalyser);
            this._inputStreamSource.connect(this._inputAnalyser2);
          };
          PeerConnection.prototype._updateOutputStreamSource = function (
            stream
          ) {
            if (this._outputStreamSource) {
              this._outputStreamSource.disconnect();
            }
            this._outputStreamSource =
              this._audioContext.createMediaStreamSource(stream);
            this._outputStreamSource.connect(this._outputAnalyser);
            this._outputStreamSource.connect(this._outputAnalyser2);
          };
          PeerConnection.prototype._setInputTracksFromStream = function (
            shouldClone,
            newStream
          ) {
            return this._isUnifiedPlan
              ? this._setInputTracksForUnifiedPlan(shouldClone, newStream)
              : this._setInputTracksForPlanB(shouldClone, newStream);
          };
          PeerConnection.prototype._setInputTracksForPlanB = function (
            shouldClone,
            newStream
          ) {
            const _this = this;
            if (!newStream) {
              return Promise.reject(
                new InvalidArgumentError(
                  'Can not set input stream to null while in a call'
                )
              );
            }
            if (!newStream.getAudioTracks().length) {
              return Promise.reject(
                new InvalidArgumentError(
                  'Supplied input stream has no audio tracks'
                )
              );
            }
            const localStream = this.stream;
            if (!localStream) {
              this.stream = shouldClone ? cloneStream(newStream) : newStream;
            } else {
              this._stopStream(localStream);
              removeStream(this.version.pc, localStream);
              localStream
                .getAudioTracks()
                .forEach(localStream.removeTrack, localStream);
              newStream
                .getAudioTracks()
                .forEach(localStream.addTrack, localStream);
              addStream(this.version.pc, newStream);
              this._updateInputStreamSource(this.stream);
            }
            this.mute(this.isMuted);
            if (!this.version) {
              return Promise.resolve(this.stream);
            }
            return new Promise(function (resolve, reject) {
              _this.version.createOffer(
                _this.options.maxAverageBitrate,
                _this.codecPreferences,
                { audio: true },
                function () {
                  _this.version.processAnswer(
                    _this.codecPreferences,
                    _this._answerSdp,
                    function () {
                      resolve(_this.stream);
                    },
                    reject
                  );
                },
                reject
              );
            });
          };
          PeerConnection.prototype._setInputTracksForUnifiedPlan = function (
            shouldClone,
            newStream
          ) {
            const _this2 = this;
            if (!newStream) {
              return Promise.reject(
                new InvalidArgumentError(
                  'Can not set input stream to null while in a call'
                )
              );
            }
            if (!newStream.getAudioTracks().length) {
              return Promise.reject(
                new InvalidArgumentError(
                  'Supplied input stream has no audio tracks'
                )
              );
            }
            const localStream = this.stream;
            const getStreamPromise = function getStreamPromise() {
              _this2.mute(_this2.isMuted);
              return Promise.resolve(_this2.stream);
            };
            if (!localStream) {
              this.stream = shouldClone ? cloneStream(newStream) : newStream;
            } else {
              if (this._shouldManageStream) {
                this._stopStream(localStream);
              }
              if (!this._sender) {
                this._sender = this.version.pc.getSenders()[0];
              }
              return this._sender
                .replaceTrack(newStream.getAudioTracks()[0])
                .then(function () {
                  _this2._updateInputStreamSource(newStream);
                  return getStreamPromise();
                });
            }
            return getStreamPromise();
          };
          PeerConnection.prototype._onInputDevicesChanged = function () {
            if (!this.stream) {
              return;
            }
            const activeInputWasLost = this.stream
              .getAudioTracks()
              .every(function (track) {
                return track.readyState === 'ended';
              });
            if (activeInputWasLost && this._shouldManageStream) {
              this.openWithConstraints(true);
            }
          };
          PeerConnection.prototype._onIceGatheringFailure = function (type) {
            this._hasIceGatheringFailures = true;
            this.onicegatheringfailure(type);
          };
          PeerConnection.prototype._onMediaConnectionStateChange = function (
            newState
          ) {
            const previousState = this._iceState;
            if (
              previousState === newState ||
              (newState !== 'connected' &&
                newState !== 'disconnected' &&
                newState !== 'failed')
            ) {
              return;
            }
            this._iceState = newState;
            let message = void 0;
            switch (newState) {
              case 'connected':
                if (
                  previousState === 'disconnected' ||
                  previousState === 'failed'
                ) {
                  message =
                    'ICE liveliness check succeeded. Connection with Twilio restored';
                  this._log.info(message);
                  this.onreconnected(message);
                } else {
                  message = 'Media connection established.';
                  this._log.info(message);
                  this.onconnected(message);
                }
                this._stopIceGatheringTimeout();
                this._hasIceGatheringFailures = false;
                break;
              case 'disconnected':
                message =
                  'ICE liveliness check failed. May be having trouble connecting to Twilio';
                this._log.info(message);
                this.ondisconnected(message);
                break;
              case 'failed':
                message = 'Connection with Twilio was interrupted.';
                this._log.info(message);
                this.onfailed(message);
                break;
            }
          };
          PeerConnection.prototype._setSinkIds = function (sinkIds) {
            if (!this._isSinkSupported) {
              return Promise.reject(
                new NotSupportedError(
                  'Audio output selection is not supported by this browser'
                )
              );
            }
            this.sinkIds = new Set(sinkIds.forEach ? sinkIds : [sinkIds]);
            return this.version
              ? this._updateAudioOutputs()
              : Promise.resolve();
          };
          PeerConnection.prototype._startIceGatheringTimeout =
            function startIceGatheringTimeout() {
              const _this3 = this;
              this._stopIceGatheringTimeout();
              this._iceGatheringTimeoutId = setTimeout(function () {
                _this3._onIceGatheringFailure(ICE_GATHERING_FAIL_TIMEOUT);
              }, ICE_GATHERING_TIMEOUT);
            };
          PeerConnection.prototype._stopIceGatheringTimeout =
            function stopIceGatheringTimeout() {
              clearInterval(this._iceGatheringTimeoutId);
            };
          PeerConnection.prototype._updateAudioOutputs =
            function updateAudioOutputs() {
              const addedOutputIds = Array.from(this.sinkIds).filter(function (
                id
              ) {
                return !this.outputs.has(id);
              },
              this);
              const removedOutputIds = Array.from(this.outputs.keys()).filter(
                function (id) {
                  return !this.sinkIds.has(id);
                },
                this
              );
              const self = this;
              const createOutputPromises = addedOutputIds.map(
                this._createAudioOutput,
                this
              );
              return Promise.all(createOutputPromises).then(function () {
                return Promise.all(
                  removedOutputIds.map(self._removeAudioOutput, self)
                );
              });
            };
          PeerConnection.prototype._createAudio = function createAudio(arr) {
            return new Audio(arr);
          };
          PeerConnection.prototype._createAudioOutput =
            function createAudioOutput(id) {
              const dest = this._audioContext.createMediaStreamDestination();
              this._mediaStreamSource.connect(dest);
              const audio = this._createAudio();
              setAudioSource(audio, dest.stream);
              const self = this;
              return audio
                .setSinkId(id)
                .then(function () {
                  return audio.play();
                })
                .then(function () {
                  self.outputs.set(id, { audio, dest });
                });
            };
          PeerConnection.prototype._removeAudioOutputs =
            function removeAudioOutputs() {
              if (
                this._masterAudio &&
                typeof this._masterAudioDeviceId !== 'undefined'
              ) {
                this._disableOutput(this, this._masterAudioDeviceId);
                this.outputs.delete(this._masterAudioDeviceId);
                this._masterAudioDeviceId = null;
                if (!this._masterAudio.paused) {
                  this._masterAudio.pause();
                }
                if (typeof this._masterAudio.srcObject !== 'undefined') {
                  this._masterAudio.srcObject = null;
                } else {
                  this._masterAudio.src = '';
                }
                this._masterAudio = null;
              }
              return Array.from(this.outputs.keys()).map(
                this._removeAudioOutput,
                this
              );
            };
          PeerConnection.prototype._disableOutput = function disableOutput(
            pc,
            id
          ) {
            const output = pc.outputs.get(id);
            if (!output) {
              return;
            }
            if (output.audio) {
              output.audio.pause();
              output.audio.src = '';
            }
            if (output.dest) {
              output.dest.disconnect();
            }
          };
          PeerConnection.prototype._reassignMasterOutput =
            function reassignMasterOutput(pc, masterId) {
              const masterOutput = pc.outputs.get(masterId);
              pc.outputs.delete(masterId);
              const self = this;
              const idToReplace = Array.from(pc.outputs.keys())[0] || 'default';
              return masterOutput.audio
                .setSinkId(idToReplace)
                .then(function () {
                  self._disableOutput(pc, idToReplace);
                  pc.outputs.set(idToReplace, masterOutput);
                  pc._masterAudioDeviceId = idToReplace;
                })
                .catch(function rollback() {
                  pc.outputs.set(masterId, masterOutput);
                  self._log.info(
                    'Could not reassign master output. Attempted to roll back.'
                  );
                });
            };
          PeerConnection.prototype._removeAudioOutput =
            function removeAudioOutput(id) {
              if (this._masterAudioDeviceId === id) {
                return this._reassignMasterOutput(this, id);
              }
              this._disableOutput(this, id);
              this.outputs.delete(id);
              return Promise.resolve();
            };
          PeerConnection.prototype._onAddTrack = function onAddTrack(
            pc,
            stream
          ) {
            const audio = (pc._masterAudio = this._createAudio());
            setAudioSource(audio, stream);
            audio.play();
            const deviceId = Array.from(pc.outputs.keys())[0] || 'default';
            pc._masterAudioDeviceId = deviceId;
            pc.outputs.set(deviceId, { audio });
            pc._mediaStreamSource =
              pc._audioContext.createMediaStreamSource(stream);
            pc.pcStream = stream;
            pc._updateAudioOutputs();
          };
          PeerConnection.prototype._fallbackOnAddTrack =
            function fallbackOnAddTrack(pc, stream) {
              const audio = document && document.createElement('audio');
              audio.autoplay = true;
              if (!setAudioSource(audio, stream)) {
                pc._log.info('Error attaching stream to element.');
              }
              pc.outputs.set('default', { audio });
            };
          PeerConnection.prototype._setEncodingParameters = function (
            enableDscp
          ) {
            if (
              !enableDscp ||
              !this._sender ||
              typeof this._sender.getParameters !== 'function' ||
              typeof this._sender.setParameters !== 'function'
            ) {
              return;
            }
            const params = this._sender.getParameters();
            if (
              !params.priority &&
              !(params.encodings && params.encodings.length)
            ) {
              return;
            }
            params.priority = 'high';
            if (params.encodings && params.encodings.length) {
              params.encodings.forEach(function (encoding) {
                encoding.priority = 'high';
                encoding.networkPriority = 'high';
              });
            }
            this._sender.setParameters(params);
          };
          PeerConnection.prototype._setupPeerConnection = function (
            rtcConstraints,
            rtcConfiguration
          ) {
            const _this4 = this;
            const self = this;
            const version = new (this.options.rtcpcFactory || RTCPC)();
            version.create(rtcConstraints, rtcConfiguration);
            addStream(version.pc, this.stream);
            const eventName =
              'ontrack' in version.pc ? 'ontrack' : 'onaddstream';
            version.pc[eventName] = function (event) {
              const stream = (self._remoteStream =
                event.stream || event.streams[0]);
              if (typeof version.pc.getSenders === 'function') {
                _this4._sender = version.pc.getSenders()[0];
              }
              if (self._isSinkSupported) {
                self._onAddTrack(self, stream);
              } else {
                self._fallbackOnAddTrack(self, stream);
              }
              self._startPollingVolume();
            };
            return version;
          };
          PeerConnection.prototype._maybeSetIceAggressiveNomination = function (
            sdp
          ) {
            return this.options.forceAggressiveIceNomination
              ? setIceAggressiveNomination(sdp)
              : sdp;
          };
          PeerConnection.prototype._setupChannel = function () {
            const _this5 = this;
            const { pc } = this.version;
            this.version.pc.onopen = function () {
              _this5.status = 'open';
              _this5.onopen();
            };
            this.version.pc.onstatechange = function () {
              if (
                _this5.version.pc &&
                _this5.version.pc.readyState === 'stable'
              ) {
                _this5.status = 'open';
                _this5.onopen();
              }
            };
            this.version.pc.onsignalingstatechange = function () {
              const state = pc.signalingState;
              _this5._log.info(`signalingState is "${state}"`);
              if (
                _this5.version.pc &&
                _this5.version.pc.signalingState === 'stable'
              ) {
                _this5.status = 'open';
                _this5.onopen();
              }
              _this5.onsignalingstatechange(pc.signalingState);
            };
            pc.onconnectionstatechange = function () {
              _this5._log.info(`pc.connectionState is "${pc.connectionState}"`);
              _this5.onpcconnectionstatechange(pc.connectionState);
              _this5._onMediaConnectionStateChange(pc.connectionState);
            };
            pc.onicecandidate = function (event) {
              const { candidate } = event;
              if (candidate) {
                _this5._hasIceCandidates = true;
                _this5.onicecandidate(candidate);
                _this5._setupRTCIceTransportListener();
              }
              _this5._log.info(`ICE Candidate: ${JSON.stringify(candidate)}`);
            };
            pc.onicegatheringstatechange = function () {
              const state = pc.iceGatheringState;
              if (state === 'gathering') {
                _this5._startIceGatheringTimeout();
              } else if (state === 'complete') {
                _this5._stopIceGatheringTimeout();
                if (!_this5._hasIceCandidates) {
                  _this5._onIceGatheringFailure(ICE_GATHERING_FAIL_NONE);
                }
                if (
                  _this5._hasIceCandidates &&
                  _this5._hasIceGatheringFailures
                ) {
                  _this5._startIceGatheringTimeout();
                }
              }
              _this5._log.info(
                `pc.iceGatheringState is "${pc.iceGatheringState}"`
              );
              _this5.onicegatheringstatechange(state);
            };
            pc.oniceconnectionstatechange = function () {
              _this5._log.info(
                `pc.iceConnectionState is "${pc.iceConnectionState}"`
              );
              _this5.oniceconnectionstatechange(pc.iceConnectionState);
              _this5._onMediaConnectionStateChange(pc.iceConnectionState);
            };
          };
          PeerConnection.prototype._initializeMediaStream = function (
            rtcConstraints,
            rtcConfiguration
          ) {
            if (this.status === 'open') {
              return false;
            }
            if (this.pstream.status === 'disconnected') {
              this.onerror({
                info: {
                  code: 31e3,
                  message:
                    'Cannot establish connection. Client is disconnected',
                  twilioError: new SignalingErrors.ConnectionDisconnected(),
                },
              });
              this.close();
              return false;
            }
            this.version = this._setupPeerConnection(
              rtcConstraints,
              rtcConfiguration
            );
            this._setupChannel();
            return true;
          };
          PeerConnection.prototype._removeReconnectionListeners = function () {
            if (this.pstream) {
              this.pstream.removeListener('answer', this._onAnswerOrRinging);
              this.pstream.removeListener('hangup', this._onHangup);
            }
          };
          PeerConnection.prototype._setupRTCDtlsTransportListener =
            function () {
              const _this6 = this;
              const dtlsTransport = this.getRTCDtlsTransport();
              if (!dtlsTransport || dtlsTransport.onstatechange) {
                return;
              }
              const handler = function handler() {
                _this6._log.info(
                  `dtlsTransportState is "${dtlsTransport.state}"`
                );
                _this6.ondtlstransportstatechange(dtlsTransport.state);
              };
              handler();
              dtlsTransport.onstatechange = handler;
            };
          PeerConnection.prototype._setupRTCIceTransportListener = function () {
            const _this7 = this;
            const iceTransport = this._getRTCIceTransport();
            if (!iceTransport || iceTransport.onselectedcandidatepairchange) {
              return;
            }
            iceTransport.onselectedcandidatepairchange = function () {
              return _this7.onselectedcandidatepairchange(
                iceTransport.getSelectedCandidatePair()
              );
            };
          };
          PeerConnection.prototype.iceRestart = function () {
            const _this8 = this;
            this._log.info('Attempting to restart ICE...');
            this._hasIceCandidates = false;
            this.version
              .createOffer(
                this.options.maxAverageBitrate,
                this.codecPreferences,
                { iceRestart: true }
              )
              .then(function () {
                _this8._removeReconnectionListeners();
                _this8._onAnswerOrRinging = function (payload) {
                  _this8._removeReconnectionListeners();
                  if (
                    !payload.sdp ||
                    _this8.version.pc.signalingState !== 'have-local-offer'
                  ) {
                    const message =
                      `Invalid state or param during ICE Restart:` +
                      `hasSdp:${Boolean(payload.sdp)}, signalingState:${
                        _this8.version.pc.signalingState
                      }`;
                    _this8._log.info(message);
                    return;
                  }
                  const sdp = _this8._maybeSetIceAggressiveNomination(
                    payload.sdp
                  );
                  _this8._answerSdp = sdp;
                  if (_this8.status !== 'closed') {
                    _this8.version.processAnswer(
                      _this8.codecPreferences,
                      sdp,
                      null,
                      function (err) {
                        const message = err && err.message ? err.message : err;
                        _this8._log.info(
                          `Failed to process answer during ICE Restart. Error: ${message}`
                        );
                      }
                    );
                  }
                };
                _this8._onHangup = function () {
                  _this8._log.info('Received hangup during ICE Restart');
                  _this8._removeReconnectionListeners();
                };
                _this8.pstream.on('answer', _this8._onAnswerOrRinging);
                _this8.pstream.on('hangup', _this8._onHangup);
                _this8.pstream.reinvite(
                  _this8.version.getSDP(),
                  _this8.callSid
                );
              })
              .catch(function (err) {
                const message = err && err.message ? err.message : err;
                _this8._log.info(
                  `Failed to createOffer during ICE Restart. Error: ${message}`
                );
                _this8.onfailed(message);
              });
          };
          PeerConnection.prototype.makeOutgoingCall = function (
            token,
            params,
            callsid,
            rtcConstraints,
            rtcConfiguration,
            onMediaStarted
          ) {
            const _this9 = this;
            if (
              !this._initializeMediaStream(rtcConstraints, rtcConfiguration)
            ) {
              return;
            }
            const self = this;
            this.callSid = callsid;
            function onAnswerSuccess() {
              if (self.options) {
                self._setEncodingParameters(self.options.dscp);
              }
              onMediaStarted(self.version.pc);
            }
            function onAnswerError(err) {
              const errMsg = err.message || err;
              self.onerror({
                info: {
                  code: 31e3,
                  message: `Error processing answer: ${errMsg}`,
                  twilioError: new MediaErrors.ClientRemoteDescFailed(),
                },
              });
            }
            this._onAnswerOrRinging = function (payload) {
              if (!payload.sdp) {
                return;
              }
              const sdp = _this9._maybeSetIceAggressiveNomination(payload.sdp);
              self._answerSdp = sdp;
              if (self.status !== 'closed') {
                self.version.processAnswer(
                  _this9.codecPreferences,
                  sdp,
                  onAnswerSuccess,
                  onAnswerError
                );
              }
              self.pstream.removeListener('answer', self._onAnswerOrRinging);
              self.pstream.removeListener('ringing', self._onAnswerOrRinging);
            };
            this.pstream.on('answer', this._onAnswerOrRinging);
            this.pstream.on('ringing', this._onAnswerOrRinging);
            function onOfferSuccess() {
              if (self.status !== 'closed') {
                self.pstream.invite(
                  self.version.getSDP(),
                  self.callSid,
                  self.options.preflight,
                  params
                );
                self._setupRTCDtlsTransportListener();
              }
            }
            function onOfferError(err) {
              const errMsg = err.message || err;
              self.onerror({
                info: {
                  code: 31e3,
                  message: `Error creating the offer: ${errMsg}`,
                  twilioError: new MediaErrors.ClientLocalDescFailed(),
                },
              });
            }
            this.version.createOffer(
              this.options.maxAverageBitrate,
              this.codecPreferences,
              { audio: true },
              onOfferSuccess,
              onOfferError
            );
          };
          PeerConnection.prototype.answerIncomingCall = function (
            callSid,
            sdp,
            rtcConstraints,
            rtcConfiguration,
            onMediaStarted
          ) {
            if (
              !this._initializeMediaStream(rtcConstraints, rtcConfiguration)
            ) {
              return;
            }
            sdp = this._maybeSetIceAggressiveNomination(sdp);
            this._answerSdp = sdp.replace(
              /^a=setup:actpass$/gm,
              'a=setup:passive'
            );
            this.callSid = callSid;
            const self = this;
            function onAnswerSuccess() {
              if (self.status !== 'closed') {
                self.pstream.answer(self.version.getSDP(), callSid);
                if (self.options) {
                  self._setEncodingParameters(self.options.dscp);
                }
                onMediaStarted(self.version.pc);
                self._setupRTCDtlsTransportListener();
              }
            }
            function onAnswerError(err) {
              const errMsg = err.message || err;
              self.onerror({
                info: {
                  code: 31e3,
                  message: `Error creating the answer: ${errMsg}`,
                  twilioError: new MediaErrors.ClientRemoteDescFailed(),
                },
              });
            }
            this.version.processSDP(
              this.options.maxAverageBitrate,
              this.codecPreferences,
              sdp,
              { audio: true },
              onAnswerSuccess,
              onAnswerError
            );
          };
          PeerConnection.prototype.close = function () {
            if (this.version && this.version.pc) {
              if (this.version.pc.signalingState !== 'closed') {
                this.version.pc.close();
              }
              this.version.pc = null;
            }
            if (this.stream) {
              this.mute(false);
              this._stopStream(this.stream);
            }
            this.stream = null;
            this._removeReconnectionListeners();
            this._stopIceGatheringTimeout();
            Promise.all(this._removeAudioOutputs()).catch(function () {});
            if (this._mediaStreamSource) {
              this._mediaStreamSource.disconnect();
            }
            if (this._inputAnalyser) {
              this._inputAnalyser.disconnect();
            }
            if (this._outputAnalyser) {
              this._outputAnalyser.disconnect();
            }
            if (this._inputAnalyser2) {
              this._inputAnalyser2.disconnect();
            }
            if (this._outputAnalyser2) {
              this._outputAnalyser2.disconnect();
            }
            this.status = 'closed';
            this.onclose();
          };
          PeerConnection.prototype.reject = function (callSid) {
            this.callSid = callSid;
          };
          PeerConnection.prototype.ignore = function (callSid) {
            this.callSid = callSid;
          };
          PeerConnection.prototype.mute = function (shouldMute) {
            this.isMuted = shouldMute;
            if (!this.stream) {
              return;
            }
            if (this._sender && this._sender.track) {
              this._sender.track.enabled = !shouldMute;
            } else {
              const audioTracks =
                typeof this.stream.getAudioTracks === 'function'
                  ? this.stream.getAudioTracks()
                  : this.stream.audioTracks;
              audioTracks.forEach(function (track) {
                track.enabled = !shouldMute;
              });
            }
          };
          PeerConnection.prototype.getOrCreateDTMFSender =
            function getOrCreateDTMFSender() {
              if (this._dtmfSender || this._dtmfSenderUnsupported) {
                return this._dtmfSender || null;
              }
              const self = this;
              const { pc } = this.version;
              if (!pc) {
                this._log.info(
                  'No RTCPeerConnection available to call createDTMFSender on'
                );
                return null;
              }
              if (
                typeof pc.getSenders === 'function' &&
                (typeof RTCDTMFSender === 'function' ||
                  typeof RTCDtmfSender === 'function')
              ) {
                const chosenSender = pc.getSenders().find(function (sender) {
                  return sender.dtmf;
                });
                if (chosenSender) {
                  this._log.info('Using RTCRtpSender#dtmf');
                  this._dtmfSender = chosenSender.dtmf;
                  return this._dtmfSender;
                }
              }
              if (
                typeof pc.createDTMFSender === 'function' &&
                typeof pc.getLocalStreams === 'function'
              ) {
                const track = pc.getLocalStreams().map(function (stream) {
                  const tracks = self._getAudioTracks(stream);
                  return tracks && tracks[0];
                })[0];
                if (!track) {
                  this._log.info(
                    'No local audio MediaStreamTrack available on the RTCPeerConnection to pass to createDTMFSender'
                  );
                  return null;
                }
                this._log.info('Creating RTCDTMFSender');
                this._dtmfSender = pc.createDTMFSender(track);
                return this._dtmfSender;
              }
              this._log.info(
                'RTCPeerConnection does not support RTCDTMFSender'
              );
              this._dtmfSenderUnsupported = true;
              return null;
            };
          PeerConnection.prototype.getRTCDtlsTransport =
            function getRTCDtlsTransport() {
              const sender =
                this.version &&
                this.version.pc &&
                typeof this.version.pc.getSenders === 'function' &&
                this.version.pc.getSenders()[0];
              return (sender && sender.transport) || null;
            };
          PeerConnection.prototype._canStopMediaStreamTrack = function () {
            return typeof MediaStreamTrack.prototype.stop === 'function';
          };
          PeerConnection.prototype._getAudioTracks = function (stream) {
            return typeof stream.getAudioTracks === 'function'
              ? stream.getAudioTracks()
              : stream.audioTracks;
          };
          PeerConnection.prototype._getRTCIceTransport =
            function _getRTCIceTransport() {
              const dtlsTransport = this.getRTCDtlsTransport();
              return (dtlsTransport && dtlsTransport.iceTransport) || null;
            };
          PeerConnection.protocol = (function () {
            return RTCPC.test() ? new RTCPC() : null;
          })();
          function addStream(pc, stream) {
            if (typeof pc.addTrack === 'function') {
              stream.getAudioTracks().forEach(function (track) {
                pc.addTrack(track, stream);
              });
            } else {
              pc.addStream(stream);
            }
          }
          function cloneStream(oldStream) {
            const newStream =
              typeof MediaStream !== 'undefined'
                ? new MediaStream()
                : new webkitMediaStream();
            oldStream.getAudioTracks().forEach(newStream.addTrack, newStream);
            return newStream;
          }
          function removeStream(pc, stream) {
            if (typeof pc.removeTrack === 'function') {
              pc.getSenders().forEach(function (sender) {
                pc.removeTrack(sender);
              });
            } else {
              pc.removeStream(stream);
            }
          }
          function setAudioSource(audio, stream) {
            if (typeof audio.srcObject !== 'undefined') {
              audio.srcObject = stream;
            } else if (typeof audio.mozSrcObject !== 'undefined') {
              audio.mozSrcObject = stream;
            } else if (typeof audio.src !== 'undefined') {
              const _window = audio.options.window || window;
              audio.src = (_window.URL || _window.webkitURL).createObjectURL(
                stream
              );
            } else {
              return false;
            }
            return true;
          }
          PeerConnection.enabled = RTCPC.test();
          module.exports = PeerConnection;
        },
        {
          '../errors': 12,
          '../log': 15,
          '../util': 35,
          './rtcpc': 27,
          './sdp': 28,
        },
      ],
      27: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              const _typeof =
                typeof Symbol === 'function' &&
                typeof Symbol.iterator === 'symbol'
                  ? function (obj) {
                      return typeof obj;
                    }
                  : function (obj) {
                      return obj &&
                        typeof Symbol === 'function' &&
                        obj.constructor === Symbol &&
                        obj !== Symbol.prototype
                        ? 'symbol'
                        : typeof obj;
                    };
              const RTCPeerConnectionShim = require('rtcpeerconnection-shim');
              const Log = require('../log').default;
              const _require = require('./sdp');
              const { setCodecPreferences } = _require;
              const { setMaxAverageBitrate } = _require;
              const util = require('../util');
              function RTCPC() {
                if (typeof window === 'undefined') {
                  this.log.info(
                    'No RTCPeerConnection implementation available. The window object was not found.'
                  );
                  return;
                }
                if (util.isLegacyEdge()) {
                  this.RTCPeerConnection = new RTCPeerConnectionShim(
                    typeof window !== 'undefined' ? window : global
                  );
                } else if (typeof window.RTCPeerConnection === 'function') {
                  this.RTCPeerConnection = window.RTCPeerConnection;
                } else if (
                  typeof window.webkitRTCPeerConnection === 'function'
                ) {
                  this.RTCPeerConnection = webkitRTCPeerConnection;
                } else if (typeof window.mozRTCPeerConnection === 'function') {
                  this.RTCPeerConnection = mozRTCPeerConnection;
                  window.RTCSessionDescription = mozRTCSessionDescription;
                  window.RTCIceCandidate = mozRTCIceCandidate;
                } else {
                  this.log.info(
                    'No RTCPeerConnection implementation available'
                  );
                }
              }
              RTCPC.prototype.create = function (
                rtcConstraints,
                rtcConfiguration
              ) {
                this.log = Log.getInstance();
                this.pc = new this.RTCPeerConnection(
                  rtcConfiguration,
                  rtcConstraints
                );
              };
              RTCPC.prototype.createModernConstraints = function (c) {
                if (typeof c === 'undefined') {
                  return null;
                }
                const nc = { ...c };
                if (
                  typeof webkitRTCPeerConnection !== 'undefined' &&
                  !util.isLegacyEdge()
                ) {
                  nc.mandatory = {};
                  if (typeof c.audio !== 'undefined') {
                    nc.mandatory.OfferToReceiveAudio = c.audio;
                  }
                  if (typeof c.video !== 'undefined') {
                    nc.mandatory.OfferToReceiveVideo = c.video;
                  }
                } else {
                  if (typeof c.audio !== 'undefined') {
                    nc.offerToReceiveAudio = c.audio;
                  }
                  if (typeof c.video !== 'undefined') {
                    nc.offerToReceiveVideo = c.video;
                  }
                }
                delete nc.audio;
                delete nc.video;
                return nc;
              };
              RTCPC.prototype.createOffer = function (
                maxAverageBitrate,
                codecPreferences,
                constraints,
                onSuccess,
                onError
              ) {
                const _this = this;
                constraints = this.createModernConstraints(constraints);
                return promisifyCreate(
                  this.pc.createOffer,
                  this.pc
                )(constraints)
                  .then(function (offer) {
                    if (!_this.pc) {
                      return Promise.resolve();
                    }
                    const sdp = setMaxAverageBitrate(
                      offer.sdp,
                      maxAverageBitrate
                    );
                    return promisifySet(
                      _this.pc.setLocalDescription,
                      _this.pc
                    )(
                      new RTCSessionDescription({
                        type: 'offer',
                        sdp: setCodecPreferences(sdp, codecPreferences),
                      })
                    );
                  })
                  .then(onSuccess, onError);
              };
              RTCPC.prototype.createAnswer = function (
                maxAverageBitrate,
                codecPreferences,
                constraints,
                onSuccess,
                onError
              ) {
                const _this2 = this;
                constraints = this.createModernConstraints(constraints);
                return promisifyCreate(
                  this.pc.createAnswer,
                  this.pc
                )(constraints)
                  .then(function (answer) {
                    if (!_this2.pc) {
                      return Promise.resolve();
                    }
                    const sdp = setMaxAverageBitrate(
                      answer.sdp,
                      maxAverageBitrate
                    );
                    return promisifySet(
                      _this2.pc.setLocalDescription,
                      _this2.pc
                    )(
                      new RTCSessionDescription({
                        type: 'answer',
                        sdp: setCodecPreferences(sdp, codecPreferences),
                      })
                    );
                  })
                  .then(onSuccess, onError);
              };
              RTCPC.prototype.processSDP = function (
                maxAverageBitrate,
                codecPreferences,
                sdp,
                constraints,
                onSuccess,
                onError
              ) {
                const _this3 = this;
                sdp = setCodecPreferences(sdp, codecPreferences);
                const desc = new RTCSessionDescription({
                  sdp,
                  type: 'offer',
                });
                return promisifySet(
                  this.pc.setRemoteDescription,
                  this.pc
                )(desc).then(function () {
                  _this3.createAnswer(
                    maxAverageBitrate,
                    codecPreferences,
                    constraints,
                    onSuccess,
                    onError
                  );
                });
              };
              RTCPC.prototype.getSDP = function () {
                return this.pc.localDescription.sdp;
              };
              RTCPC.prototype.processAnswer = function (
                codecPreferences,
                sdp,
                onSuccess,
                onError
              ) {
                if (!this.pc) {
                  return Promise.resolve();
                }
                sdp = setCodecPreferences(sdp, codecPreferences);
                return promisifySet(
                  this.pc.setRemoteDescription,
                  this.pc
                )(new RTCSessionDescription({ sdp, type: 'answer' })).then(
                  onSuccess,
                  onError
                );
              };
              RTCPC.test = function () {
                if (
                  (typeof navigator === 'undefined'
                    ? 'undefined'
                    : _typeof(navigator)) === 'object'
                ) {
                  const getUserMedia =
                    (navigator.mediaDevices &&
                      navigator.mediaDevices.getUserMedia) ||
                    navigator.webkitGetUserMedia ||
                    navigator.mozGetUserMedia ||
                    navigator.getUserMedia;
                  if (util.isLegacyEdge(navigator)) {
                    return false;
                  }
                  if (
                    getUserMedia &&
                    typeof window.RTCPeerConnection === 'function'
                  ) {
                    return true;
                  } else if (
                    getUserMedia &&
                    typeof window.webkitRTCPeerConnection === 'function'
                  ) {
                    return true;
                  } else if (
                    getUserMedia &&
                    typeof window.mozRTCPeerConnection === 'function'
                  ) {
                    try {
                      const test = new window.mozRTCPeerConnection();
                      if (typeof test.getLocalStreams !== 'function')
                        return false;
                    } catch (e) {
                      return false;
                    }
                    return true;
                  } else if (typeof RTCIceGatherer !== 'undefined') {
                    return true;
                  }
                }
                return false;
              };
              function promisify(fn, ctx, areCallbacksFirst) {
                return function () {
                  const args = Array.prototype.slice.call(arguments);
                  return new Promise(function (resolve) {
                    resolve(fn.apply(ctx, args));
                  }).catch(function () {
                    return new Promise(function (resolve, reject) {
                      fn.apply(
                        ctx,
                        areCallbacksFirst
                          ? [resolve, reject].concat(args)
                          : args.concat([resolve, reject])
                      );
                    });
                  });
                };
              }
              function promisifyCreate(fn, ctx) {
                return promisify(fn, ctx, true);
              }
              function promisifySet(fn, ctx) {
                return promisify(fn, ctx, false);
              }
              module.exports = RTCPC;
            }.call(this));
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {
          '../log': 15,
          '../util': 35,
          './sdp': 28,
          'rtcpeerconnection-shim': 56,
        },
      ],
      28: [
        function (require, module, exports) {
          const _slicedToArray = (function () {
            function sliceIterator(arr, i) {
              const _arr = [];
              let _n = true;
              let _d = false;
              let _e = undefined;
              try {
                for (
                  var _i = arr[Symbol.iterator](), _s;
                  !(_n = (_s = _i.next()).done);
                  _n = true
                ) {
                  _arr.push(_s.value);
                  if (i && _arr.length === i) break;
                }
              } catch (err) {
                _d = true;
                _e = err;
              } finally {
                try {
                  if (!_n && _i.return) _i.return();
                } finally {
                  if (_d) throw _e;
                }
              }
              return _arr;
            }
            return function (arr, i) {
              if (Array.isArray(arr)) {
                return arr;
              } else if (Symbol.iterator in Object(arr)) {
                return sliceIterator(arr, i);
              }
              throw new TypeError(
                'Invalid attempt to destructure non-iterable instance'
              );
            };
          })();
          const util = require('../util');
          const ptToFixedBitrateAudioCodecName = { 0: 'PCMU', 8: 'PCMA' };
          const defaultOpusId = 111;
          const BITRATE_MAX = 51e4;
          const BITRATE_MIN = 6e3;
          function getPreferredCodecInfo(sdp) {
            const _ref = /a=rtpmap:(\d+) (\S+)/m.exec(sdp) || [null, '', ''];
            const _ref2 = _slicedToArray(_ref, 3);
            const codecId = _ref2[1];
            const codecName = _ref2[2];
            const regex = new RegExp(`a=fmtp:${codecId} (\\S+)`, 'm');
            const _ref3 = regex.exec(sdp) || [null, ''];
            const _ref4 = _slicedToArray(_ref3, 2);
            const codecParams = _ref4[1];
            return { codecName, codecParams };
          }
          function setIceAggressiveNomination(sdp) {
            if (!util.isChrome(window, window.navigator)) {
              return sdp;
            }
            return sdp
              .split('\n')
              .filter(function (line) {
                return line.indexOf('a=ice-lite') === -1;
              })
              .join('\n');
          }
          function setMaxAverageBitrate(sdp, maxAverageBitrate) {
            if (
              typeof maxAverageBitrate !== 'number' ||
              maxAverageBitrate < BITRATE_MIN ||
              maxAverageBitrate > BITRATE_MAX
            ) {
              return sdp;
            }
            const matches = /a=rtpmap:(\d+) opus/m.exec(sdp);
            const opusId =
              matches && matches.length ? matches[1] : defaultOpusId;
            const regex = new RegExp(`a=fmtp:${opusId}`);
            const lines = sdp.split('\n').map(function (line) {
              return regex.test(line)
                ? `${line};maxaveragebitrate=${maxAverageBitrate}`
                : line;
            });
            return lines.join('\n');
          }
          function setCodecPreferences(sdp, preferredCodecs) {
            const mediaSections = getMediaSections(sdp);
            const session = sdp.split('\r\nm=')[0];
            return [session]
              .concat(
                mediaSections.map(function (section) {
                  if (!/^m=(audio|video)/.test(section)) {
                    return section;
                  }
                  const kind = section.match(/^m=(audio|video)/)[1];
                  const codecMap = createCodecMapForMediaSection(section);
                  const payloadTypes = getReorderedPayloadTypes(
                    codecMap,
                    preferredCodecs
                  );
                  const newSection = setPayloadTypesInMediaSection(
                    payloadTypes,
                    section
                  );
                  const pcmaPayloadTypes = codecMap.get('pcma') || [];
                  const pcmuPayloadTypes = codecMap.get('pcmu') || [];
                  const fixedBitratePayloadTypes =
                    kind === 'audio'
                      ? new Set(pcmaPayloadTypes.concat(pcmuPayloadTypes))
                      : new Set();
                  return fixedBitratePayloadTypes.has(payloadTypes[0])
                    ? newSection.replace(/\r\nb=(AS|TIAS):([0-9]+)/g, '')
                    : newSection;
                })
              )
              .join('\r\n');
          }
          function getMediaSections(sdp, kind, direction) {
            return sdp
              .replace(/\r\n\r\n$/, '\r\n')
              .split('\r\nm=')
              .slice(1)
              .map(function (mediaSection) {
                return `m=${mediaSection}`;
              })
              .filter(function (mediaSection) {
                const kindPattern = new RegExp(`m=${kind || '.*'}`, 'gm');
                const directionPattern = new RegExp(
                  `a=${direction || '.*'}`,
                  'gm'
                );
                return (
                  kindPattern.test(mediaSection) &&
                  directionPattern.test(mediaSection)
                );
              });
          }
          function createCodecMapForMediaSection(section) {
            return Array.from(createPtToCodecName(section)).reduce(function (
              codecMap,
              pair
            ) {
              const pt = pair[0];
              const codecName = pair[1];
              const pts = codecMap.get(codecName) || [];
              return codecMap.set(codecName, pts.concat(pt));
            },
            new Map());
          }
          function getReorderedPayloadTypes(codecMap, preferredCodecs) {
            preferredCodecs = preferredCodecs.map(function (codecName) {
              return codecName.toLowerCase();
            });
            const preferredPayloadTypes = util.flatMap(
              preferredCodecs,
              function (codecName) {
                return codecMap.get(codecName) || [];
              }
            );
            const remainingCodecs = util.difference(
              Array.from(codecMap.keys()),
              preferredCodecs
            );
            const remainingPayloadTypes = util.flatMap(
              remainingCodecs,
              function (codecName) {
                return codecMap.get(codecName);
              }
            );
            return preferredPayloadTypes.concat(remainingPayloadTypes);
          }
          function setPayloadTypesInMediaSection(payloadTypes, section) {
            const lines = section.split('\r\n');
            let mLine = lines[0];
            const otherLines = lines.slice(1);
            mLine = mLine.replace(/([0-9]+\s?)+$/, payloadTypes.join(' '));
            return [mLine].concat(otherLines).join('\r\n');
          }
          function createPtToCodecName(mediaSection) {
            return getPayloadTypesInMediaSection(mediaSection).reduce(function (
              ptToCodecName,
              pt
            ) {
              const rtpmapPattern = new RegExp(`a=rtpmap:${pt} ([^/]+)`);
              const matches = mediaSection.match(rtpmapPattern);
              const codecName = matches
                ? matches[1].toLowerCase()
                : ptToFixedBitrateAudioCodecName[pt]
                ? ptToFixedBitrateAudioCodecName[pt].toLowerCase()
                : '';
              return ptToCodecName.set(pt, codecName);
            },
            new Map());
          }
          function getPayloadTypesInMediaSection(section) {
            const mLine = section.split('\r\n')[0];
            const matches = mLine.match(/([0-9]+)/g);
            if (!matches) {
              return [];
            }
            return matches.slice(1).map(function (match) {
              return parseInt(match, 10);
            });
          }
          module.exports = {
            getPreferredCodecInfo,
            setCodecPreferences,
            setIceAggressiveNomination,
            setMaxAverageBitrate,
          };
        },
        { '../util': 35 },
      ],
      29: [
        function (require, module, exports) {
          const __spreadArrays =
            (this && this.__spreadArrays) ||
            function () {
              for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                s += arguments[i].length;
              for (var r = Array(s), k = 0, i = 0; i < il; i++)
                for (
                  let a = arguments[i], j = 0, jl = a.length;
                  j < jl;
                  j++, k++
                )
                  r[k] = a[j];
              return r;
            };
          const _a = require('../errors');
          const { NotSupportedError } = _a;
          const { InvalidArgumentError } = _a;
          const MockRTCStatsReport = require('./mockrtcstatsreport');
          const ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';
          const ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';
          function getRTCStatsReport(peerConnection) {
            if (!peerConnection) {
              return Promise.reject(
                new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL)
              );
            }
            if (typeof peerConnection.getStats !== 'function') {
              return Promise.reject(
                new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED)
              );
            }
            let promise;
            try {
              promise = peerConnection.getStats();
            } catch (e) {
              promise = new Promise(function (resolve) {
                return peerConnection.getStats(resolve);
              }).then(MockRTCStatsReport.fromRTCStatsResponse);
            }
            return promise;
          }
          function getRTCStats(peerConnection, options) {
            options = {
              createRTCSample,
              ...options,
            };
            return getRTCStatsReport(peerConnection).then(
              options.createRTCSample
            );
          }
          function getRTCIceCandidateStatsReport(peerConnection) {
            return getRTCStatsReport(peerConnection).then(function (report) {
              const _a = Array.from(report.values()).reduce(function (
                rval,
                stat
              ) {
                [
                  'candidatePairs',
                  'localCandidates',
                  'remoteCandidates',
                ].forEach(function (prop) {
                  if (!rval[prop]) {
                    rval[prop] = [];
                  }
                });
                switch (stat.type) {
                  case 'candidate-pair':
                    rval.candidatePairs.push(stat);
                    break;
                  case 'local-candidate':
                    rval.localCandidates.push(stat);
                    break;
                  case 'remote-candidate':
                    rval.remoteCandidates.push(stat);
                    break;
                  case 'transport':
                    if (stat.selectedCandidatePairId) {
                      rval.transport = stat;
                    }
                    break;
                }
                return rval;
              },
              {});
              const { candidatePairs } = _a;
              const { localCandidates } = _a;
              const { remoteCandidates } = _a;
              const { transport } = _a;
              const selectedCandidatePairReport = candidatePairs.find(function (
                pair
              ) {
                return (
                  pair.selected ||
                  (transport && pair.id === transport.selectedCandidatePairId)
                );
              });
              let selectedIceCandidatePairStats;
              if (selectedCandidatePairReport) {
                selectedIceCandidatePairStats = {
                  localCandidate: localCandidates.find(function (candidate) {
                    return (
                      candidate.id ===
                      selectedCandidatePairReport.localCandidateId
                    );
                  }),
                  remoteCandidate: remoteCandidates.find(function (candidate) {
                    return (
                      candidate.id ===
                      selectedCandidatePairReport.remoteCandidateId
                    );
                  }),
                };
              }
              return {
                iceCandidateStats: __spreadArrays(
                  localCandidates,
                  remoteCandidates
                ),
                selectedIceCandidatePairStats,
              };
            });
          }
          function RTCSample() {}
          function createRTCSample(statsReport) {
            let activeTransportId = null;
            const sample = new RTCSample();
            let fallbackTimestamp;
            Array.from(statsReport.values()).forEach(function (stats) {
              if (stats.isRemote) {
                return;
              }
              const type = stats.type.replace('-', '');
              fallbackTimestamp = fallbackTimestamp || stats.timestamp;
              if (stats.remoteId) {
                const remote = statsReport.get(stats.remoteId);
                if (remote && remote.roundTripTime) {
                  sample.rtt = remote.roundTripTime * 1e3;
                }
              }
              switch (type) {
                case 'inboundrtp':
                  sample.timestamp = sample.timestamp || stats.timestamp;
                  sample.jitter = stats.jitter * 1e3;
                  sample.packetsLost = stats.packetsLost;
                  sample.packetsReceived = stats.packetsReceived;
                  sample.bytesReceived = stats.bytesReceived;
                  break;
                case 'outboundrtp':
                  sample.timestamp = stats.timestamp;
                  sample.packetsSent = stats.packetsSent;
                  sample.bytesSent = stats.bytesSent;
                  if (stats.codecId) {
                    const codec = statsReport.get(stats.codecId);
                    sample.codecName = codec
                      ? codec.mimeType && codec.mimeType.match(/(.*\/)?(.*)/)[2]
                      : stats.codecId;
                  }
                  break;
                case 'transport':
                  activeTransportId = stats.id;
                  break;
              }
            });
            if (!sample.timestamp) {
              sample.timestamp = fallbackTimestamp;
            }
            const activeTransport = statsReport.get(activeTransportId);
            if (!activeTransport) {
              return sample;
            }
            const selectedCandidatePair = statsReport.get(
              activeTransport.selectedCandidatePairId
            );
            if (!selectedCandidatePair) {
              return sample;
            }
            const localCandidate = statsReport.get(
              selectedCandidatePair.localCandidateId
            );
            const remoteCandidate = statsReport.get(
              selectedCandidatePair.remoteCandidateId
            );
            if (!sample.rtt) {
              sample.rtt =
                selectedCandidatePair &&
                selectedCandidatePair.currentRoundTripTime * 1e3;
            }
            Object.assign(sample, {
              localAddress: localCandidate && localCandidate.ip,
              remoteAddress: remoteCandidate && remoteCandidate.ip,
            });
            return sample;
          }
          module.exports = {
            getRTCStats,
            getRTCIceCandidateStatsReport,
          };
        },
        { '../errors': 12, './mockrtcstatsreport': 24 },
      ],
      30: [
        function (require, module, exports) {
          const { EventEmitter } = require('events');
          function EventTarget() {
            Object.defineProperties(this, {
              _eventEmitter: { value: new EventEmitter() },
              _handlers: { value: {} },
            });
          }
          EventTarget.prototype.dispatchEvent = function dispatchEvent(event) {
            return this._eventEmitter.emit(event.type, event);
          };
          EventTarget.prototype.addEventListener = function addEventListener() {
            let _a;
            return (_a = this._eventEmitter).addListener.apply(_a, arguments);
          };
          EventTarget.prototype.removeEventListener =
            function removeEventListener() {
              let _a;
              return (_a = this._eventEmitter).removeListener.apply(
                _a,
                arguments
              );
            };
          EventTarget.prototype._defineEventHandler =
            function _defineEventHandler(eventName) {
              const self = this;
              Object.defineProperty(this, `on${eventName}`, {
                get() {
                  return self._handlers[eventName];
                },
                set(newHandler) {
                  const oldHandler = self._handlers[eventName];
                  if (
                    oldHandler &&
                    (typeof newHandler === 'function' ||
                      typeof newHandler === 'undefined' ||
                      newHandler === null)
                  ) {
                    self._handlers[eventName] = null;
                    self.removeEventListener(eventName, oldHandler);
                  }
                  if (typeof newHandler === 'function') {
                    self._handlers[eventName] = newHandler;
                    self.addEventListener(eventName, newHandler);
                  }
                },
              });
            };
          module.exports = EventTarget;
        },
        { events: 48 },
      ],
      31: [
        function (require, module, exports) {
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          const MediaDeviceInfoShim = function MediaDeviceInfoShim(options) {
            _classCallCheck(this, MediaDeviceInfoShim);
            Object.defineProperties(this, {
              deviceId: {
                get: function get() {
                  return options.deviceId;
                },
              },
              groupId: {
                get: function get() {
                  return options.groupId;
                },
              },
              kind: {
                get: function get() {
                  return options.kind;
                },
              },
              label: {
                get: function get() {
                  return options.label;
                },
              },
            });
          };
          module.exports = MediaDeviceInfoShim;
        },
        {},
      ],
      32: [
        function (require, module, exports) {
          const EventTarget = require('./eventtarget');
          const { inherits } = require('util');
          const POLL_INTERVAL_MS = 500;
          const nativeMediaDevices =
            typeof navigator !== 'undefined' && navigator.mediaDevices;
          function MediaDevicesShim() {
            EventTarget.call(this);
            this._defineEventHandler('devicechange');
            this._defineEventHandler('deviceinfochange');
            const knownDevices = [];
            Object.defineProperties(this, {
              _deviceChangeIsNative: {
                value: reemitNativeEvent(this, 'devicechange'),
              },
              _deviceInfoChangeIsNative: {
                value: reemitNativeEvent(this, 'deviceinfochange'),
              },
              _knownDevices: { value: knownDevices },
              _pollInterval: { value: null, writable: true },
            });
            if (typeof nativeMediaDevices.enumerateDevices === 'function') {
              nativeMediaDevices.enumerateDevices().then(function (devices) {
                devices.sort(sortDevicesById).forEach([].push, knownDevices);
              });
            }
            this._eventEmitter.on(
              'newListener',
              function maybeStartPolling(eventName) {
                if (
                  eventName !== 'devicechange' &&
                  eventName !== 'deviceinfochange'
                ) {
                  return;
                }
                this._pollInterval =
                  this._pollInterval ||
                  setInterval(sampleDevices.bind(null, this), POLL_INTERVAL_MS);
              }.bind(this)
            );
            this._eventEmitter.on(
              'removeListener',
              function maybeStopPolling() {
                if (this._pollInterval && !hasChangeListeners(this)) {
                  clearInterval(this._pollInterval);
                  this._pollInterval = null;
                }
              }.bind(this)
            );
          }
          inherits(MediaDevicesShim, EventTarget);
          if (
            nativeMediaDevices &&
            typeof nativeMediaDevices.enumerateDevices === 'function'
          ) {
            MediaDevicesShim.prototype.enumerateDevices =
              function enumerateDevices() {
                return nativeMediaDevices.enumerateDevices.apply(
                  nativeMediaDevices,
                  arguments
                );
              };
          }
          MediaDevicesShim.prototype.getUserMedia = function getUserMedia() {
            return nativeMediaDevices.getUserMedia.apply(
              nativeMediaDevices,
              arguments
            );
          };
          function deviceInfosHaveChanged(newDevices, oldDevices) {
            const oldLabels = oldDevices.reduce(function (map, device) {
              return map.set(device.deviceId, device.label || null);
            }, new Map());
            return newDevices.some(function (newDevice) {
              const oldLabel = oldLabels.get(newDevice.deviceId);
              return (
                typeof oldLabel !== 'undefined' && oldLabel !== newDevice.label
              );
            });
          }
          function devicesHaveChanged(newDevices, oldDevices) {
            return (
              newDevices.length !== oldDevices.length ||
              propertyHasChanged('deviceId', newDevices, oldDevices)
            );
          }
          function hasChangeListeners(mediaDevices) {
            return (
              ['devicechange', 'deviceinfochange'].reduce(function (
                count,
                event
              ) {
                return count + mediaDevices._eventEmitter.listenerCount(event);
              },
              0) > 0
            );
          }
          function sampleDevices(mediaDevices) {
            nativeMediaDevices.enumerateDevices().then(function (newDevices) {
              const knownDevices = mediaDevices._knownDevices;
              const oldDevices = knownDevices.slice();
              [].splice.apply(
                knownDevices,
                [0, knownDevices.length].concat(
                  newDevices.sort(sortDevicesById)
                )
              );
              if (
                !mediaDevices._deviceChangeIsNative &&
                devicesHaveChanged(knownDevices, oldDevices)
              ) {
                mediaDevices.dispatchEvent(new Event('devicechange'));
              }
              if (
                !mediaDevices._deviceInfoChangeIsNative &&
                deviceInfosHaveChanged(knownDevices, oldDevices)
              ) {
                mediaDevices.dispatchEvent(new Event('deviceinfochange'));
              }
            });
          }
          function propertyHasChanged(propertyName, as, bs) {
            return as.some(function (a, i) {
              return a[propertyName] !== bs[i][propertyName];
            });
          }
          function reemitNativeEvent(mediaDevices, eventName) {
            const methodName = `on${eventName}`;
            function dispatchEvent(event) {
              mediaDevices.dispatchEvent(event);
            }
            if (methodName in nativeMediaDevices) {
              if ('addEventListener' in nativeMediaDevices) {
                nativeMediaDevices.addEventListener(eventName, dispatchEvent);
              } else {
                nativeMediaDevices[methodName] = dispatchEvent;
              }
              return true;
            }
            return false;
          }
          function sortDevicesById(a, b) {
            return a.deviceId < b.deviceId;
          }
          module.exports = (function shimMediaDevices() {
            return nativeMediaDevices ? new MediaDevicesShim() : null;
          })();
        },
        { './eventtarget': 30, util: 60 },
      ],
      33: [
        function (require, module, exports) {
          const { AsyncQueue } = require('./asyncQueue');
          const AudioPlayer = require('@twilio/audioplayer');
          const { InvalidArgumentError } = require('./errors');
          function Sound(name, url, options) {
            if (!(this instanceof Sound)) {
              return new Sound(name, url, options);
            }
            if (!name || !url) {
              throw new InvalidArgumentError(
                'name and url are required arguments'
              );
            }
            options = {
              AudioFactory: typeof Audio !== 'undefined' ? Audio : null,
              maxDuration: 0,
              shouldLoop: false,
              ...options,
            };
            options.AudioPlayer = options.audioContext
              ? AudioPlayer.bind(AudioPlayer, options.audioContext)
              : options.AudioFactory;
            Object.defineProperties(this, {
              _activeEls: { value: new Map() },
              _Audio: { value: options.AudioPlayer },
              _isSinkSupported: {
                value:
                  options.AudioFactory !== null &&
                  typeof options.AudioFactory.prototype.setSinkId ===
                    'function',
              },
              _maxDuration: { value: options.maxDuration },
              _maxDurationTimeout: { value: null, writable: true },
              _operations: { value: new AsyncQueue() },
              _playPromise: { value: null, writable: true },
              _shouldLoop: { value: options.shouldLoop },
              _sinkIds: { value: ['default'] },
              isPlaying: {
                enumerable: true,
                get: function get() {
                  return Boolean(this._playPromise);
                },
              },
              name: { enumerable: true, value: name },
              url: { enumerable: true, value: url },
            });
            if (this._Audio) {
              this._play(true, false);
            }
          }
          function destroyAudioElement(audioElement) {
            if (audioElement) {
              audioElement.pause();
              audioElement.src = '';
              audioElement.srcObject = null;
              audioElement.load();
            }
          }
          Sound.prototype._playAudioElement = function _playAudioElement(
            sinkId,
            isMuted,
            shouldLoop
          ) {
            const _this = this;
            const audioElement = this._activeEls.get(sinkId);
            if (!audioElement) {
              throw new InvalidArgumentError(
                `sinkId: "${sinkId}" doesn't have an audio element`
              );
            }
            audioElement.muted = Boolean(isMuted);
            audioElement.loop = Boolean(shouldLoop);
            return audioElement
              .play()
              .then(function () {
                return audioElement;
              })
              .catch(function (reason) {
                destroyAudioElement(audioElement);
                _this._activeEls.delete(sinkId);
                throw reason;
              });
          };
          Sound.prototype._play = function _play(
            forceIsMuted,
            forceShouldLoop
          ) {
            if (this.isPlaying) {
              this._stop();
            }
            if (this._maxDuration > 0) {
              this._maxDurationTimeout = setTimeout(
                this._stop.bind(this),
                this._maxDuration
              );
            }
            forceShouldLoop =
              typeof forceShouldLoop === 'boolean'
                ? forceShouldLoop
                : this._shouldLoop;
            const self = this;
            return (this._playPromise = Promise.all(
              this._sinkIds.map(function createAudioElement(sinkId) {
                if (!self._Audio) {
                  return Promise.resolve();
                }
                let audioElement = self._activeEls.get(sinkId);
                if (audioElement) {
                  return self._playAudioElement(
                    sinkId,
                    forceIsMuted,
                    forceShouldLoop
                  );
                }
                audioElement = new self._Audio(self.url);
                if (typeof audioElement.setAttribute === 'function') {
                  audioElement.setAttribute('crossorigin', 'anonymous');
                }
                return new Promise(function (resolve) {
                  audioElement.addEventListener('canplaythrough', resolve);
                }).then(function () {
                  return (
                    self._isSinkSupported
                      ? audioElement.setSinkId(sinkId)
                      : Promise.resolve()
                  ).then(function setSinkIdSuccess() {
                    self._activeEls.set(sinkId, audioElement);
                    if (!self._playPromise) {
                      return Promise.resolve();
                    }
                    return self._playAudioElement(
                      sinkId,
                      forceIsMuted,
                      forceShouldLoop
                    );
                  });
                });
              })
            ));
          };
          Sound.prototype._stop = function _stop() {
            const _this2 = this;
            this._activeEls.forEach(function (audioEl, sinkId) {
              if (_this2._sinkIds.includes(sinkId)) {
                audioEl.pause();
                audioEl.currentTime = 0;
              } else {
                destroyAudioElement(audioEl);
                _this2._activeEls.delete(sinkId);
              }
            });
            clearTimeout(this._maxDurationTimeout);
            this._playPromise = null;
            this._maxDurationTimeout = null;
          };
          Sound.prototype.setSinkIds = function setSinkIds(ids) {
            if (!this._isSinkSupported) {
              return;
            }
            ids = ids.forEach ? ids : [ids];
            [].splice.apply(
              this._sinkIds,
              [0, this._sinkIds.length].concat(ids)
            );
          };
          Sound.prototype.stop = function stop() {
            const _this3 = this;
            this._operations.enqueue(function () {
              _this3._stop();
              return Promise.resolve();
            });
          };
          Sound.prototype.play = function play() {
            const _this4 = this;
            return this._operations.enqueue(function () {
              return _this4._play();
            });
          };
          module.exports = Sound;
        },
        { './asyncQueue': 4, './errors': 12, '@twilio/audioplayer': 40 },
      ],
      34: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          var __assign =
            (this && this.__assign) ||
            function () {
              __assign =
                Object.assign ||
                function (t) {
                  for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (const p in s)
                      if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
                  }
                  return t;
                };
              return __assign.apply(this, arguments);
            };
          const __spreadArrays =
            (this && this.__spreadArrays) ||
            function () {
              for (var s = 0, i = 0, il = arguments.length; i < il; i++)
                s += arguments[i].length;
              for (var r = Array(s), k = 0, i = 0; i < il; i++)
                for (
                  let a = arguments[i], j = 0, jl = a.length;
                  j < jl;
                  j++, k++
                )
                  r[k] = a[j];
              return r;
            };
          Object.defineProperty(exports, '__esModule', { value: true });
          const events_1 = require('events');
          const errors_1 = require('./errors');
          const mos_1 = require('./rtc/mos');
          const util_1 = require('./util');
          const { getRTCStats } = require('./rtc/stats');
          const SAMPLE_COUNT_METRICS = 5;
          const SAMPLE_COUNT_CLEAR = 0;
          const SAMPLE_COUNT_RAISE = 3;
          const SAMPLE_INTERVAL = 1e3;
          const WARNING_TIMEOUT = 5 * 1e3;
          const DEFAULT_THRESHOLDS = {
            audioInputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },
            audioOutputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },
            bytesReceived: {
              clearCount: 2,
              min: 1,
              raiseCount: 3,
              sampleCount: 3,
            },
            bytesSent: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },
            jitter: { max: 30 },
            mos: { min: 3 },
            packetsLostFraction: [
              { max: 1 },
              { clearValue: 1, maxAverage: 3, sampleCount: 7 },
            ],
            rtt: { max: 400 },
          };
          function countHigh(max, values) {
            return values.reduce(function (highCount, value) {
              return (highCount += value > max ? 1 : 0);
            }, 0);
          }
          function countLow(min, values) {
            return values.reduce(function (lowCount, value) {
              return (lowCount += value < min ? 1 : 0);
            }, 0);
          }
          function calculateStandardDeviation(values) {
            if (values.length <= 0) {
              return null;
            }
            const valueAverage =
              values.reduce(function (partialSum, value) {
                return partialSum + value;
              }, 0) / values.length;
            const diffSquared = values.map(function (value) {
              return Math.pow(value - valueAverage, 2);
            });
            return Math.sqrt(
              diffSquared.reduce(function (partialSum, value) {
                return partialSum + value;
              }, 0) / diffSquared.length
            );
          }
          function flattenSamples(sampleSets) {
            return sampleSets.reduce(function (flat, current) {
              return __spreadArrays(flat, current);
            }, []);
          }
          const StatsMonitor = (function (_super) {
            __extends(StatsMonitor, _super);
            function StatsMonitor(options) {
              const _this = _super.call(this) || this;
              _this._activeWarnings = new Map();
              _this._currentStreaks = new Map();
              _this._inputVolumes = [];
              _this._outputVolumes = [];
              _this._sampleBuffer = [];
              _this._supplementalSampleBuffers = {
                audioInputLevel: [],
                audioOutputLevel: [],
              };
              _this._warningsEnabled = true;
              options = options || {};
              _this._getRTCStats = options.getRTCStats || getRTCStats;
              _this._mos = options.Mos || mos_1.default;
              _this._peerConnection = options.peerConnection;
              _this._thresholds = {
                ...DEFAULT_THRESHOLDS,
                ...options.thresholds,
              };
              const thresholdSampleCounts = Object.values(_this._thresholds)
                .map(function (threshold) {
                  return threshold.sampleCount;
                })
                .filter(function (sampleCount) {
                  return Boolean(sampleCount);
                });
              _this._maxSampleCount = Math.max.apply(
                Math,
                __spreadArrays([SAMPLE_COUNT_METRICS], thresholdSampleCounts)
              );
              if (_this._peerConnection) {
                _this.enable(_this._peerConnection);
              }
              return _this;
            }
            StatsMonitor.prototype.addVolumes = function (
              inputVolume,
              outputVolume
            ) {
              this._inputVolumes.push(inputVolume);
              this._outputVolumes.push(outputVolume);
            };
            StatsMonitor.prototype.disable = function () {
              clearInterval(this._sampleInterval);
              delete this._sampleInterval;
              return this;
            };
            StatsMonitor.prototype.disableWarnings = function () {
              if (this._warningsEnabled) {
                this._activeWarnings.clear();
              }
              this._warningsEnabled = false;
              return this;
            };
            StatsMonitor.prototype.enable = function (peerConnection) {
              if (peerConnection) {
                if (
                  this._peerConnection &&
                  peerConnection !== this._peerConnection
                ) {
                  throw new errors_1.InvalidArgumentError(
                    'Attempted to replace an existing PeerConnection in StatsMonitor.enable'
                  );
                }
                this._peerConnection = peerConnection;
              }
              if (!this._peerConnection) {
                throw new errors_1.InvalidArgumentError(
                  'Can not enable StatsMonitor without a PeerConnection'
                );
              }
              this._sampleInterval =
                this._sampleInterval ||
                setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);
              return this;
            };
            StatsMonitor.prototype.enableWarnings = function () {
              this._warningsEnabled = true;
              return this;
            };
            StatsMonitor.prototype.hasActiveWarning = function (
              statName,
              thresholdName
            ) {
              const warningId = `${statName}:${thresholdName}`;
              return Boolean(this._activeWarnings.get(warningId));
            };
            StatsMonitor.prototype._addSample = function (sample) {
              const samples = this._sampleBuffer;
              samples.push(sample);
              if (samples.length > this._maxSampleCount) {
                samples.splice(0, samples.length - this._maxSampleCount);
              }
            };
            StatsMonitor.prototype._clearWarning = function (
              statName,
              thresholdName,
              data
            ) {
              const warningId = `${statName}:${thresholdName}`;
              const activeWarning = this._activeWarnings.get(warningId);
              if (
                !activeWarning ||
                Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT
              ) {
                return;
              }
              this._activeWarnings.delete(warningId);
              this.emit('warning-cleared', {
                ...data,
                name: statName,
                threshold: {
                  name: thresholdName,
                  value: this._thresholds[statName][thresholdName],
                },
              });
            };
            StatsMonitor.prototype._createSample = function (
              stats,
              previousSample
            ) {
              const previousBytesSent =
                (previousSample && previousSample.totals.bytesSent) || 0;
              const previousBytesReceived =
                (previousSample && previousSample.totals.bytesReceived) || 0;
              const previousPacketsSent =
                (previousSample && previousSample.totals.packetsSent) || 0;
              const previousPacketsReceived =
                (previousSample && previousSample.totals.packetsReceived) || 0;
              const previousPacketsLost =
                (previousSample && previousSample.totals.packetsLost) || 0;
              const currentBytesSent = stats.bytesSent - previousBytesSent;
              const currentBytesReceived =
                stats.bytesReceived - previousBytesReceived;
              const currentPacketsSent =
                stats.packetsSent - previousPacketsSent;
              const currentPacketsReceived =
                stats.packetsReceived - previousPacketsReceived;
              const currentPacketsLost =
                stats.packetsLost - previousPacketsLost;
              const currentInboundPackets =
                currentPacketsReceived + currentPacketsLost;
              const currentPacketsLostFraction =
                currentInboundPackets > 0
                  ? (currentPacketsLost / currentInboundPackets) * 100
                  : 0;
              const totalInboundPackets =
                stats.packetsReceived + stats.packetsLost;
              const totalPacketsLostFraction =
                totalInboundPackets > 0
                  ? (stats.packetsLost / totalInboundPackets) * 100
                  : 100;
              const rttValue =
                typeof stats.rtt === 'number' || !previousSample
                  ? stats.rtt
                  : previousSample.rtt;
              const audioInputLevelValues = this._inputVolumes.splice(0);
              this._supplementalSampleBuffers.audioInputLevel.push(
                audioInputLevelValues
              );
              const audioOutputLevelValues = this._outputVolumes.splice(0);
              this._supplementalSampleBuffers.audioOutputLevel.push(
                audioOutputLevelValues
              );
              return {
                audioInputLevel: Math.round(
                  util_1.average(audioInputLevelValues)
                ),
                audioOutputLevel: Math.round(
                  util_1.average(audioOutputLevelValues)
                ),
                bytesReceived: currentBytesReceived,
                bytesSent: currentBytesSent,
                codecName: stats.codecName,
                jitter: stats.jitter,
                mos: this._mos.calculate(
                  rttValue,
                  stats.jitter,
                  previousSample && currentPacketsLostFraction
                ),
                packetsLost: currentPacketsLost,
                packetsLostFraction: currentPacketsLostFraction,
                packetsReceived: currentPacketsReceived,
                packetsSent: currentPacketsSent,
                rtt: rttValue,
                timestamp: stats.timestamp,
                totals: {
                  bytesReceived: stats.bytesReceived,
                  bytesSent: stats.bytesSent,
                  packetsLost: stats.packetsLost,
                  packetsLostFraction: totalPacketsLostFraction,
                  packetsReceived: stats.packetsReceived,
                  packetsSent: stats.packetsSent,
                },
              };
            };
            StatsMonitor.prototype._fetchSample = function () {
              const _this = this;
              this._getSample()
                .then(function (sample) {
                  _this._addSample(sample);
                  _this._raiseWarnings();
                  _this.emit('sample', sample);
                })
                .catch(function (error) {
                  _this.disable();
                  _this.emit('error', error);
                });
            };
            StatsMonitor.prototype._getSample = function () {
              const _this = this;
              return this._getRTCStats(this._peerConnection).then(function (
                stats
              ) {
                let previousSample = null;
                if (_this._sampleBuffer.length) {
                  previousSample =
                    _this._sampleBuffer[_this._sampleBuffer.length - 1];
                }
                return _this._createSample(stats, previousSample);
              });
            };
            StatsMonitor.prototype._raiseWarning = function (
              statName,
              thresholdName,
              data
            ) {
              const warningId = `${statName}:${thresholdName}`;
              if (this._activeWarnings.has(warningId)) {
                return;
              }
              this._activeWarnings.set(warningId, { timeRaised: Date.now() });
              const thresholds = this._thresholds[statName];
              let thresholdValue;
              if (Array.isArray(thresholds)) {
                const foundThreshold = thresholds.find(function (threshold) {
                  return thresholdName in threshold;
                });
                if (foundThreshold) {
                  thresholdValue = foundThreshold[thresholdName];
                }
              } else {
                thresholdValue = this._thresholds[statName][thresholdName];
              }
              this.emit('warning', {
                ...data,
                name: statName,
                threshold: { name: thresholdName, value: thresholdValue },
              });
            };
            StatsMonitor.prototype._raiseWarnings = function () {
              const _this = this;
              if (!this._warningsEnabled) {
                return;
              }
              Object.keys(this._thresholds).forEach(function (name) {
                return _this._raiseWarningsForStat(name);
              });
            };
            StatsMonitor.prototype._raiseWarningsForStat = function (statName) {
              const _this = this;
              const limits = Array.isArray(this._thresholds[statName])
                ? this._thresholds[statName]
                : [this._thresholds[statName]];
              limits.forEach(function (limit) {
                const samples = _this._sampleBuffer;
                const clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;
                const raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;
                const sampleCount = limit.sampleCount || _this._maxSampleCount;
                let relevantSamples = samples.slice(-sampleCount);
                const values = relevantSamples.map(function (sample) {
                  return sample[statName];
                });
                const containsNull = values.some(function (value) {
                  return typeof value === 'undefined' || value === null;
                });
                if (containsNull) {
                  return;
                }
                let count;
                if (typeof limit.max === 'number') {
                  count = countHigh(limit.max, values);
                  if (count >= raiseCount) {
                    _this._raiseWarning(statName, 'max', {
                      values,
                      samples: relevantSamples,
                    });
                  } else if (count <= clearCount) {
                    _this._clearWarning(statName, 'max', {
                      values,
                      samples: relevantSamples,
                    });
                  }
                }
                if (typeof limit.min === 'number') {
                  count = countLow(limit.min, values);
                  if (count >= raiseCount) {
                    _this._raiseWarning(statName, 'min', {
                      values,
                      samples: relevantSamples,
                    });
                  } else if (count <= clearCount) {
                    _this._clearWarning(statName, 'min', {
                      values,
                      samples: relevantSamples,
                    });
                  }
                }
                if (
                  typeof limit.maxDuration === 'number' &&
                  samples.length > 1
                ) {
                  relevantSamples = samples.slice(-2);
                  const prevValue = relevantSamples[0][statName];
                  const curValue = relevantSamples[1][statName];
                  const prevStreak = _this._currentStreaks.get(statName) || 0;
                  const streak = prevValue === curValue ? prevStreak + 1 : 0;
                  _this._currentStreaks.set(statName, streak);
                  if (streak >= limit.maxDuration) {
                    _this._raiseWarning(statName, 'maxDuration', {
                      value: streak,
                    });
                  } else if (streak === 0) {
                    _this._clearWarning(statName, 'maxDuration', {
                      value: prevStreak,
                    });
                  }
                }
                if (typeof limit.minStandardDeviation === 'number') {
                  const sampleSets = _this._supplementalSampleBuffers[statName];
                  if (!sampleSets || sampleSets.length < limit.sampleCount) {
                    return;
                  }
                  if (sampleSets.length > limit.sampleCount) {
                    sampleSets.splice(0, sampleSets.length - limit.sampleCount);
                  }
                  const flatSamples = flattenSamples(
                    sampleSets.slice(-sampleCount)
                  );
                  const stdDev = calculateStandardDeviation(flatSamples);
                  if (typeof stdDev !== 'number') {
                    return;
                  }
                  if (stdDev < limit.minStandardDeviation) {
                    _this._raiseWarning(statName, 'minStandardDeviation', {
                      value: stdDev,
                    });
                  } else {
                    _this._clearWarning(statName, 'minStandardDeviation', {
                      value: stdDev,
                    });
                  }
                }
                [
                  [
                    'maxAverage',
                    function (x, y) {
                      return x > y;
                    },
                  ],
                  [
                    'minAverage',
                    function (x, y) {
                      return x < y;
                    },
                  ],
                ].forEach(function (_a) {
                  const thresholdName = _a[0];
                  const comparator = _a[1];
                  if (
                    typeof limit[thresholdName] === 'number' &&
                    values.length >= sampleCount
                  ) {
                    const avg = util_1.average(values);
                    if (comparator(avg, limit[thresholdName])) {
                      _this._raiseWarning(statName, thresholdName, {
                        values,
                        samples: relevantSamples,
                      });
                    } else if (
                      !comparator(avg, limit.clearValue || limit[thresholdName])
                    ) {
                      _this._clearWarning(statName, thresholdName, {
                        values,
                        samples: relevantSamples,
                      });
                    }
                  }
                });
              });
            };
            return StatsMonitor;
          })(events_1.EventEmitter);
          exports.default = StatsMonitor;
        },
        {
          './errors': 12,
          './rtc/mos': 25,
          './rtc/stats': 29,
          './util': 35,
          events: 48,
        },
      ],
      35: [
        function (require, module, exports) {
          (function (global) {
            (function () {
              function TwilioException(message) {
                if (!(this instanceof TwilioException)) {
                  return new TwilioException(message);
                }
                this.message = message;
              }
              TwilioException.prototype.toString = function () {
                return `Twilio.Exception: ${this.message}`;
              };
              function average(values) {
                return values && values.length
                  ? values.reduce(function (t, v) {
                      return t + v;
                    }) / values.length
                  : 0;
              }
              function difference(lefts, rights, getKey) {
                getKey =
                  getKey ||
                  function (a) {
                    return a;
                  };
                const rightKeys = new Set(rights.map(getKey));
                return lefts.filter(function (left) {
                  return !rightKeys.has(getKey(left));
                });
              }
              function isElectron(navigator) {
                return Boolean(navigator.userAgent.match('Electron'));
              }
              function isChrome(window, navigator) {
                const isCriOS = Boolean(navigator.userAgent.match('CriOS'));
                const isHeadlessChrome = Boolean(
                  navigator.userAgent.match('HeadlessChrome')
                );
                const isGoogle =
                  typeof window.chrome !== 'undefined' &&
                  navigator.vendor === 'Google Inc.' &&
                  navigator.userAgent.indexOf('OPR') === -1 &&
                  navigator.userAgent.indexOf('Edge') === -1;
                return (
                  isCriOS ||
                  isElectron(navigator) ||
                  isGoogle ||
                  isHeadlessChrome
                );
              }
              function isFirefox(navigator) {
                navigator =
                  navigator ||
                  (typeof window === 'undefined'
                    ? global.navigator
                    : window.navigator);
                return (
                  Boolean(navigator) &&
                  typeof navigator.userAgent === 'string' &&
                  /firefox|fxios/i.test(navigator.userAgent)
                );
              }
              function isLegacyEdge(navigator) {
                navigator =
                  navigator ||
                  (typeof window === 'undefined'
                    ? global.navigator
                    : window.navigator);
                return (
                  Boolean(navigator) &&
                  typeof navigator.userAgent === 'string' &&
                  /edge\/\d+/i.test(navigator.userAgent)
                );
              }
              function isSafari(navigator) {
                return (
                  Boolean(navigator.vendor) &&
                  navigator.vendor.indexOf('Apple') !== -1 &&
                  navigator.userAgent &&
                  navigator.userAgent.indexOf('CriOS') === -1 &&
                  navigator.userAgent.indexOf('FxiOS') === -1
                );
              }
              function isUnifiedPlanDefault(
                window,
                navigator,
                PeerConnection,
                RtpTransceiver
              ) {
                if (
                  typeof window === 'undefined' ||
                  typeof navigator === 'undefined' ||
                  typeof PeerConnection === 'undefined' ||
                  typeof RtpTransceiver === 'undefined' ||
                  typeof PeerConnection.prototype === 'undefined' ||
                  typeof RtpTransceiver.prototype === 'undefined'
                ) {
                  return false;
                }
                if (
                  isChrome(window, navigator) &&
                  PeerConnection.prototype.addTransceiver
                ) {
                  const pc = new PeerConnection();
                  let isUnifiedPlan = true;
                  try {
                    pc.addTransceiver('audio');
                  } catch (e) {
                    isUnifiedPlan = false;
                  }
                  pc.close();
                  return isUnifiedPlan;
                } else if (isFirefox(navigator)) {
                  return true;
                } else if (isSafari(navigator)) {
                  return 'currentDirection' in RtpTransceiver.prototype;
                }
                return false;
              }
              function queryToJson(params) {
                if (!params) {
                  return '';
                }
                return params.split('&').reduce(function (output, pair) {
                  const parts = pair.split('=');
                  const key = parts[0];
                  const value = decodeURIComponent(
                    (parts[1] || '').replace(/\+/g, '%20')
                  );
                  if (key) {
                    output[key] = value;
                  }
                  return output;
                }, {});
              }
              function flatMap(list, mapFn) {
                const listArray =
                  list instanceof Map || list instanceof Set
                    ? Array.from(list.values())
                    : list;
                mapFn =
                  mapFn ||
                  function (item) {
                    return item;
                  };
                return listArray.reduce(function (flattened, item) {
                  const mapped = mapFn(item);
                  return flattened.concat(mapped);
                }, []);
              }
              exports.Exception = TwilioException;
              exports.average = average;
              exports.difference = difference;
              exports.isElectron = isElectron;
              exports.isChrome = isChrome;
              exports.isFirefox = isFirefox;
              exports.isLegacyEdge = isLegacyEdge;
              exports.isSafari = isSafari;
              exports.isUnifiedPlanDefault = isUnifiedPlanDefault;
              exports.queryToJson = queryToJson;
              exports.flatMap = flatMap;
            }.call(this));
          }.call(
            this,
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        {},
      ],
      36: [
        function (require, module, exports) {
          const __extends =
            (this && this.__extends) ||
            (function () {
              var extendStatics = function (d, b) {
                extendStatics =
                  Object.setPrototypeOf ||
                  ({ __proto__: [] } instanceof Array &&
                    function (d, b) {
                      d.__proto__ = b;
                    }) ||
                  function (d, b) {
                    for (const p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
                  };
                return extendStatics(d, b);
              };
              return function (d, b) {
                extendStatics(d, b);
                function __() {
                  this.constructor = d;
                }
                d.prototype =
                  b === null
                    ? Object.create(b)
                    : ((__.prototype = b.prototype), new __());
              };
            })();
          Object.defineProperty(exports, '__esModule', { value: true });
          const events_1 = require('events');
          const WebSocket = require('ws');
          const errors_1 = require('./errors');
          const log_1 = require('./log');
          const Backoff = require('backoff');
          const CONNECT_SUCCESS_TIMEOUT = 1e4;
          const CONNECT_TIMEOUT = 5e3;
          const HEARTBEAT_TIMEOUT = 15e3;
          let WSTransportState;
          (function (WSTransportState) {
            WSTransportState.Connecting = 'connecting';
            WSTransportState.Closed = 'closed';
            WSTransportState.Open = 'open';
          })(
            (WSTransportState =
              exports.WSTransportState || (exports.WSTransportState = {}))
          );
          const WSTransport = (function (_super) {
            __extends(WSTransport, _super);
            function WSTransport(uris, options) {
              if (options === void 0) {
                options = {};
              }
              const _this = _super.call(this) || this;
              _this.state = WSTransportState.Closed;
              _this._log = log_1.default.getInstance();
              _this._shouldFallback = false;
              _this._uriIndex = 0;
              _this._moveUriIndex = function () {
                _this._uriIndex++;
                if (_this._uriIndex >= _this._uris.length) {
                  _this._uriIndex = 0;
                }
              };
              _this._onSocketClose = function (event) {
                _this._log.info(
                  `Received websocket close event code: ${event.code}. Reason: ${event.reason}`
                );
                if (event.code === 1006 || event.code === 1015) {
                  _this.emit('error', {
                    code: 31005,
                    message:
                      event.reason ||
                      "Websocket connection to Twilio's signaling servers were " +
                        'unexpectedly ended. If this is happening consistently, there may ' +
                        'be an issue resolving the hostname provided. If a region or an ' +
                        'edge is being specified in Device setup, ensure it is valid.',
                    twilioError: new errors_1.SignalingErrors.ConnectionError(),
                  });
                  const wasConnected =
                    _this.state === WSTransportState.Open ||
                    _this._previousState === WSTransportState.Open;
                  if (_this._shouldFallback || !wasConnected) {
                    _this._moveUriIndex();
                  }
                  _this._shouldFallback = true;
                }
                _this._closeSocket();
              };
              _this._onSocketError = function (err) {
                _this._log.info(`WebSocket received error: ${err.message}`);
                _this.emit('error', {
                  code: 31e3,
                  message: err.message || 'WSTransport socket error',
                  twilioError:
                    new errors_1.SignalingErrors.ConnectionDisconnected(),
                });
              };
              _this._onSocketMessage = function (message) {
                _this._setHeartbeatTimeout();
                if (_this._socket && message.data === '\n') {
                  _this._socket.send('\n');
                  return;
                }
                _this.emit('message', message);
              };
              _this._onSocketOpen = function () {
                _this._log.info('WebSocket opened successfully.');
                _this._timeOpened = Date.now();
                _this._shouldFallback = false;
                _this._setState(WSTransportState.Open);
                clearTimeout(_this._connectTimeout);
                _this._setHeartbeatTimeout();
                _this.emit('open');
              };
              _this._connectTimeoutMs =
                options.connectTimeoutMs || CONNECT_TIMEOUT;
              let initialDelay = 100;
              if (uris && uris.length > 1) {
                initialDelay =
                  Math.floor(Math.random() * (5e3 - 1e3 + 1)) + 1e3;
              }
              const backoffConfig = {
                factor: 2,
                initialDelay,
                maxDelay:
                  typeof options.backoffMaxMs === 'number'
                    ? Math.max(options.backoffMaxMs, 3e3)
                    : 2e4,
                randomisationFactor: 0.4,
              };
              _this._log.info(
                'Initializing transport backoff using config: ',
                backoffConfig
              );
              _this._backoff = Backoff.exponential(backoffConfig);
              _this._uris = uris;
              _this._WebSocket = options.WebSocket || WebSocket;
              _this._backoff.on('backoff', function (_, delay) {
                if (_this.state === WSTransportState.Closed) {
                  return;
                }
                _this._log.info(
                  `Will attempt to reconnect WebSocket in ${delay}ms`
                );
              });
              _this._backoff.on('ready', function (attempt) {
                if (_this.state === WSTransportState.Closed) {
                  return;
                }
                _this._connect(attempt + 1);
              });
              return _this;
            }
            WSTransport.prototype.close = function () {
              this._log.info('WSTransport.close() called...');
              this._close();
            };
            WSTransport.prototype.open = function () {
              this._log.info('WSTransport.open() called...');
              if (
                this._socket &&
                (this._socket.readyState === WebSocket.CONNECTING ||
                  this._socket.readyState === WebSocket.OPEN)
              ) {
                this._log.info('WebSocket already open.');
                return;
              }
              this._connect();
            };
            WSTransport.prototype.send = function (message) {
              if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {
                return false;
              }
              try {
                this._socket.send(message);
              } catch (e) {
                this._log.info('Error while sending message:', e.message);
                this._closeSocket();
                return false;
              }
              return true;
            };
            WSTransport.prototype._close = function () {
              this._setState(WSTransportState.Closed);
              this._closeSocket();
            };
            WSTransport.prototype._closeSocket = function () {
              clearTimeout(this._connectTimeout);
              clearTimeout(this._heartbeatTimeout);
              this._log.info('Closing and cleaning up WebSocket...');
              if (!this._socket) {
                this._log.info('No WebSocket to clean up.');
                return;
              }
              this._socket.removeEventListener('close', this._onSocketClose);
              this._socket.removeEventListener('error', this._onSocketError);
              this._socket.removeEventListener(
                'message',
                this._onSocketMessage
              );
              this._socket.removeEventListener('open', this._onSocketOpen);
              if (
                this._socket.readyState === WebSocket.CONNECTING ||
                this._socket.readyState === WebSocket.OPEN
              ) {
                this._socket.close();
              }
              if (
                this._timeOpened &&
                Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT
              ) {
                this._backoff.reset();
              }
              this._backoff.backoff();
              delete this._socket;
              this.emit('close');
            };
            WSTransport.prototype._connect = function (retryCount) {
              const _this = this;
              if (retryCount) {
                this._log.info(
                  `Attempting to reconnect (retry #${retryCount})...`
                );
              } else {
                this._log.info('Attempting to connect...');
              }
              this._closeSocket();
              this._setState(WSTransportState.Connecting);
              let socket = null;
              try {
                socket = new this._WebSocket(this._uris[this._uriIndex]);
              } catch (e) {
                this._log.info('Could not connect to endpoint:', e.message);
                this._close();
                this.emit('error', {
                  code: 31e3,
                  message:
                    e.message ||
                    `Could not connect to ${this._uris[this._uriIndex]}`,
                  twilioError:
                    new errors_1.SignalingErrors.ConnectionDisconnected(),
                });
                return;
              }
              delete this._timeOpened;
              this._connectTimeout = setTimeout(function () {
                _this._log.info('WebSocket connection attempt timed out.');
                _this._moveUriIndex();
                _this._closeSocket();
              }, this._connectTimeoutMs);
              socket.addEventListener('close', this._onSocketClose);
              socket.addEventListener('error', this._onSocketError);
              socket.addEventListener('message', this._onSocketMessage);
              socket.addEventListener('open', this._onSocketOpen);
              this._socket = socket;
            };
            WSTransport.prototype._setHeartbeatTimeout = function () {
              const _this = this;
              clearTimeout(this._heartbeatTimeout);
              this._heartbeatTimeout = setTimeout(function () {
                _this._log.info(
                  `No messages received in ${
                    HEARTBEAT_TIMEOUT / 1e3
                  } seconds. Reconnecting...`
                );
                _this._shouldFallback = true;
                _this._closeSocket();
              }, HEARTBEAT_TIMEOUT);
            };
            WSTransport.prototype._setState = function (state) {
              this._previousState = this.state;
              this.state = state;
            };
            Object.defineProperty(WSTransport.prototype, 'uri', {
              get() {
                return this._uris[this._uriIndex];
              },
              enumerable: true,
              configurable: true,
            });
            return WSTransport;
          })(events_1.EventEmitter);
          exports.default = WSTransport;
        },
        { './errors': 12, './log': 15, backoff: 42, events: 48, ws: 1 },
      ],
      37: [
        function (require, module, exports) {
          const _regenerator = require('babel-runtime/regenerator');
          const _regenerator2 = _interopRequireDefault(_regenerator);
          const _createClass = (function () {
            function defineProperties(target, props) {
              for (let i = 0; i < props.length; i++) {
                const descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          function _possibleConstructorReturn(self, call) {
            if (!self) {
              throw new ReferenceError(
                "this hasn't been initialised - super() hasn't been called"
              );
            }
            return call &&
              (typeof call === 'object' || typeof call === 'function')
              ? call
              : self;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== 'function' && superClass !== null) {
              throw new TypeError(
                `Super expression must either be null or a function, not ${typeof superClass}`
              );
            }
            subClass.prototype = Object.create(
              superClass && superClass.prototype,
              {
                constructor: {
                  value: subClass,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              }
            );
            if (superClass)
              Object.setPrototypeOf
                ? Object.setPrototypeOf(subClass, superClass)
                : (subClass.__proto__ = superClass);
          }
          const __awaiter =
            (undefined && undefined.__awaiter) ||
            function (thisArg, _arguments, P, generator) {
              return new (P || (P = Promise))(function (resolve, reject) {
                function fulfilled(value) {
                  try {
                    step(generator.next(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function rejected(value) {
                  try {
                    step(generator.throw(value));
                  } catch (e) {
                    reject(e);
                  }
                }
                function step(result) {
                  result.done
                    ? resolve(result.value)
                    : new P(function (resolve) {
                        resolve(result.value);
                      }).then(fulfilled, rejected);
                }
                step(
                  (generator = generator.apply(
                    thisArg,
                    _arguments || []
                  )).next()
                );
              });
            };
          Object.defineProperty(exports, '__esModule', { value: true });
          const Deferred_1 = require('./Deferred');
          const EventTarget_1 = require('./EventTarget');
          const AudioPlayer = (function (_EventTarget_1$defaul) {
            _inherits(AudioPlayer, _EventTarget_1$defaul);
            function AudioPlayer(audioContext) {
              const srcOrOptions =
                arguments.length > 1 && arguments[1] !== undefined
                  ? arguments[1]
                  : {};
              let options =
                arguments.length > 2 && arguments[2] !== undefined
                  ? arguments[2]
                  : {};
              _classCallCheck(this, AudioPlayer);
              const _this = _possibleConstructorReturn(
                this,
                (
                  AudioPlayer.__proto__ || Object.getPrototypeOf(AudioPlayer)
                ).call(this)
              );
              _this._audioNode = null;
              _this._pendingPlayDeferreds = [];
              _this._loop = false;
              _this._src = '';
              _this._sinkId = 'default';
              if (typeof srcOrOptions !== 'string') {
                options = srcOrOptions;
              }
              _this._audioContext = audioContext;
              _this._audioElement = new (options.AudioFactory || Audio)();
              _this._bufferPromise = _this._createPlayDeferred().promise;
              _this._destination = _this._audioContext.destination;
              _this._gainNode = _this._audioContext.createGain();
              _this._gainNode.connect(_this._destination);
              _this._XMLHttpRequest =
                options.XMLHttpRequestFactory || XMLHttpRequest;
              _this.addEventListener('canplaythrough', function () {
                _this._resolvePlayDeferreds();
              });
              if (typeof srcOrOptions === 'string') {
                _this.src = srcOrOptions;
              }
              return _this;
            }
            _createClass(AudioPlayer, [
              {
                key: 'load',
                value: function load() {
                  this._load(this._src);
                },
              },
              {
                key: 'pause',
                value: function pause() {
                  if (this.paused) {
                    return;
                  }
                  this._audioElement.pause();
                  this._audioNode.stop();
                  this._audioNode.disconnect(this._gainNode);
                  this._audioNode = null;
                  this._rejectPlayDeferreds(
                    new Error(
                      'The play() request was interrupted by a call to pause().'
                    )
                  );
                },
              },
              {
                key: 'play',
                value: function play() {
                  return __awaiter(
                    this,
                    void 0,
                    void 0,
                    _regenerator2.default.mark(function _callee() {
                      const _this2 = this;
                      let buffer;
                      return _regenerator2.default.wrap(
                        function _callee$(_context) {
                          while (1) {
                            switch ((_context.prev = _context.next)) {
                              case 0:
                                if (this.paused) {
                                  _context.next = 6;
                                  break;
                                }
                                _context.next = 3;
                                return this._bufferPromise;
                              case 3:
                                if (this.paused) {
                                  _context.next = 5;
                                  break;
                                }
                                return _context.abrupt('return');
                              case 5:
                                throw new Error(
                                  'The play() request was interrupted by a call to pause().'
                                );
                              case 6:
                                this._audioNode =
                                  this._audioContext.createBufferSource();
                                this._audioNode.loop = this.loop;
                                this._audioNode.addEventListener(
                                  'ended',
                                  function () {
                                    if (
                                      _this2._audioNode &&
                                      _this2._audioNode.loop
                                    ) {
                                      return;
                                    }
                                    _this2.dispatchEvent('ended');
                                  }
                                );
                                _context.next = 11;
                                return this._bufferPromise;
                              case 11:
                                buffer = _context.sent;
                                if (!this.paused) {
                                  _context.next = 14;
                                  break;
                                }
                                throw new Error(
                                  'The play() request was interrupted by a call to pause().'
                                );
                              case 14:
                                this._audioNode.buffer = buffer;
                                this._audioNode.connect(this._gainNode);
                                this._audioNode.start();
                                if (!this._audioElement.srcObject) {
                                  _context.next = 19;
                                  break;
                                }
                                return _context.abrupt(
                                  'return',
                                  this._audioElement.play()
                                );
                              case 19:
                              case 'end':
                                return _context.stop();
                            }
                          }
                        },
                        _callee,
                        this
                      );
                    })
                  );
                },
              },
              {
                key: 'setSinkId',
                value: function setSinkId(sinkId) {
                  return __awaiter(
                    this,
                    void 0,
                    void 0,
                    _regenerator2.default.mark(function _callee2() {
                      return _regenerator2.default.wrap(
                        function _callee2$(_context2) {
                          while (1) {
                            switch ((_context2.prev = _context2.next)) {
                              case 0:
                                if (
                                  typeof this._audioElement.setSinkId ===
                                  'function'
                                ) {
                                  _context2.next = 2;
                                  break;
                                }
                                throw new Error(
                                  'This browser does not support setSinkId.'
                                );
                              case 2:
                                if (sinkId !== this.sinkId) {
                                  _context2.next = 4;
                                  break;
                                }
                                return _context2.abrupt('return');
                              case 4:
                                if (sinkId !== 'default') {
                                  _context2.next = 11;
                                  break;
                                }
                                if (!this.paused) {
                                  this._gainNode.disconnect(this._destination);
                                }
                                this._audioElement.srcObject = null;
                                this._destination =
                                  this._audioContext.destination;
                                this._gainNode.connect(this._destination);
                                this._sinkId = sinkId;
                                return _context2.abrupt('return');
                              case 11:
                                _context2.next = 13;
                                return this._audioElement.setSinkId(sinkId);
                              case 13:
                                if (!this._audioElement.srcObject) {
                                  _context2.next = 15;
                                  break;
                                }
                                return _context2.abrupt('return');
                              case 15:
                                this._gainNode.disconnect(
                                  this._audioContext.destination
                                );
                                this._destination =
                                  this._audioContext.createMediaStreamDestination();
                                this._audioElement.srcObject =
                                  this._destination.stream;
                                this._sinkId = sinkId;
                                this._gainNode.connect(this._destination);
                              case 20:
                              case 'end':
                                return _context2.stop();
                            }
                          }
                        },
                        _callee2,
                        this
                      );
                    })
                  );
                },
              },
              {
                key: '_createPlayDeferred',
                value: function _createPlayDeferred() {
                  const deferred = new Deferred_1.default();
                  this._pendingPlayDeferreds.push(deferred);
                  return deferred;
                },
              },
              {
                key: '_load',
                value: function _load(src) {
                  const _this3 = this;
                  if (this._src && this._src !== src) {
                    this.pause();
                  }
                  this._src = src;
                  this._bufferPromise = new Promise(function (resolve, reject) {
                    return __awaiter(
                      _this3,
                      void 0,
                      void 0,
                      _regenerator2.default.mark(function _callee3() {
                        let buffer;
                        return _regenerator2.default.wrap(
                          function _callee3$(_context3) {
                            while (1) {
                              switch ((_context3.prev = _context3.next)) {
                                case 0:
                                  if (src) {
                                    _context3.next = 2;
                                    break;
                                  }
                                  return _context3.abrupt(
                                    'return',
                                    this._createPlayDeferred().promise
                                  );
                                case 2:
                                  _context3.next = 4;
                                  return bufferSound(
                                    this._audioContext,
                                    this._XMLHttpRequest,
                                    src
                                  );
                                case 4:
                                  buffer = _context3.sent;
                                  this.dispatchEvent('canplaythrough');
                                  resolve(buffer);
                                case 7:
                                case 'end':
                                  return _context3.stop();
                              }
                            }
                          },
                          _callee3,
                          this
                        );
                      })
                    );
                  });
                },
              },
              {
                key: '_rejectPlayDeferreds',
                value: function _rejectPlayDeferreds(reason) {
                  const deferreds = this._pendingPlayDeferreds;
                  deferreds
                    .splice(0, deferreds.length)
                    .forEach(function (_ref) {
                      const { reject } = _ref;
                      return reject(reason);
                    });
                },
              },
              {
                key: '_resolvePlayDeferreds',
                value: function _resolvePlayDeferreds(result) {
                  const deferreds = this._pendingPlayDeferreds;
                  deferreds
                    .splice(0, deferreds.length)
                    .forEach(function (_ref2) {
                      const { resolve } = _ref2;
                      return resolve(result);
                    });
                },
              },
              {
                key: 'destination',
                get: function get() {
                  return this._destination;
                },
              },
              {
                key: 'loop',
                get: function get() {
                  return this._loop;
                },
                set: function set(shouldLoop) {
                  if (!shouldLoop && this.loop && !this.paused) {
                    const _pauseAfterPlaythrough =
                      function _pauseAfterPlaythrough() {
                        self._audioNode.removeEventListener(
                          'ended',
                          _pauseAfterPlaythrough
                        );
                        self.pause();
                      };
                    var self = this;
                    this._audioNode.addEventListener(
                      'ended',
                      _pauseAfterPlaythrough
                    );
                  }
                  this._loop = shouldLoop;
                },
              },
              {
                key: 'muted',
                get: function get() {
                  return this._gainNode.gain.value === 0;
                },
                set: function set(shouldBeMuted) {
                  this._gainNode.gain.value = shouldBeMuted ? 0 : 1;
                },
              },
              {
                key: 'paused',
                get: function get() {
                  return this._audioNode === null;
                },
              },
              {
                key: 'src',
                get: function get() {
                  return this._src;
                },
                set: function set(src) {
                  this._load(src);
                },
              },
              {
                key: 'srcObject',
                get: function get() {
                  return this._audioElement.srcObject;
                },
                set: function set(srcObject) {
                  this._audioElement.srcObject = srcObject;
                },
              },
              {
                key: 'sinkId',
                get: function get() {
                  return this._sinkId;
                },
              },
            ]);
            return AudioPlayer;
          })(EventTarget_1.default);
          exports.default = AudioPlayer;
          function bufferSound(context, RequestFactory, src) {
            return __awaiter(
              this,
              void 0,
              void 0,
              _regenerator2.default.mark(function _callee4() {
                let request;
                let event;
                return _regenerator2.default.wrap(
                  function _callee4$(_context4) {
                    while (1) {
                      switch ((_context4.prev = _context4.next)) {
                        case 0:
                          request = new RequestFactory();
                          request.open('GET', src, true);
                          request.responseType = 'arraybuffer';
                          _context4.next = 5;
                          return new Promise(function (resolve) {
                            request.addEventListener('load', resolve);
                            request.send();
                          });
                        case 5:
                          event = _context4.sent;
                          _context4.prev = 6;
                          return _context4.abrupt(
                            'return',
                            context.decodeAudioData(event.target.response)
                          );
                        case 10:
                          _context4.prev = 10;
                          _context4.t0 = _context4.catch(6);
                          return _context4.abrupt(
                            'return',
                            new Promise(function (resolve) {
                              context.decodeAudioData(
                                event.target.response,
                                resolve
                              );
                            })
                          );
                        case 13:
                        case 'end':
                          return _context4.stop();
                      }
                    }
                  },
                  _callee4,
                  this,
                  [[6, 10]]
                );
              })
            );
          }
        },
        {
          './Deferred': 38,
          './EventTarget': 39,
          'babel-runtime/regenerator': 41,
        },
      ],
      38: [
        function (require, module, exports) {
          const _createClass = (function () {
            function defineProperties(target, props) {
              for (let i = 0; i < props.length; i++) {
                const descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          Object.defineProperty(exports, '__esModule', { value: true });
          const Deferred = (function () {
            function Deferred() {
              const _this = this;
              _classCallCheck(this, Deferred);
              this.promise = new Promise(function (resolve, reject) {
                _this._resolve = resolve;
                _this._reject = reject;
              });
            }
            _createClass(Deferred, [
              {
                key: 'reject',
                get: function get() {
                  return this._reject;
                },
              },
              {
                key: 'resolve',
                get: function get() {
                  return this._resolve;
                },
              },
            ]);
            return Deferred;
          })();
          exports.default = Deferred;
        },
        {},
      ],
      39: [
        function (require, module, exports) {
          const _createClass = (function () {
            function defineProperties(target, props) {
              for (let i = 0; i < props.length; i++) {
                const descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ('value' in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
              }
            }
            return function (Constructor, protoProps, staticProps) {
              if (protoProps)
                defineProperties(Constructor.prototype, protoProps);
              if (staticProps) defineProperties(Constructor, staticProps);
              return Constructor;
            };
          })();
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError('Cannot call a class as a function');
            }
          }
          Object.defineProperty(exports, '__esModule', { value: true });
          const events_1 = require('events');
          const EventTarget = (function () {
            function EventTarget() {
              _classCallCheck(this, EventTarget);
              this._eventEmitter = new events_1.EventEmitter();
            }
            _createClass(EventTarget, [
              {
                key: 'addEventListener',
                value: function addEventListener(name, handler) {
                  return this._eventEmitter.addListener(name, handler);
                },
              },
              {
                key: 'dispatchEvent',
                value: function dispatchEvent(name) {
                  let _eventEmitter;
                  for (
                    var _len = arguments.length,
                      args = Array(_len > 1 ? _len - 1 : 0),
                      _key = 1;
                    _key < _len;
                    _key++
                  ) {
                    args[_key - 1] = arguments[_key];
                  }
                  return (_eventEmitter = this._eventEmitter).emit.apply(
                    _eventEmitter,
                    [name].concat(args)
                  );
                },
              },
              {
                key: 'removeEventListener',
                value: function removeEventListener(name, handler) {
                  return this._eventEmitter.removeListener(name, handler);
                },
              },
            ]);
            return EventTarget;
          })();
          exports.default = EventTarget;
        },
        { events: 48 },
      ],
      40: [
        function (require, module, exports) {
          const AudioPlayer = require('./AudioPlayer');
          module.exports = AudioPlayer.default;
        },
        { './AudioPlayer': 37 },
      ],
      41: [
        function (require, module, exports) {
          module.exports = require('regenerator-runtime');
        },
        { 'regenerator-runtime': 54 },
      ],
      42: [
        function (require, module, exports) {
          const Backoff = require('./lib/backoff');
          const ExponentialBackoffStrategy = require('./lib/strategy/exponential');
          const FibonacciBackoffStrategy = require('./lib/strategy/fibonacci');
          const FunctionCall = require('./lib/function_call.js');
          module.exports.Backoff = Backoff;
          module.exports.FunctionCall = FunctionCall;
          module.exports.FibonacciStrategy = FibonacciBackoffStrategy;
          module.exports.ExponentialStrategy = ExponentialBackoffStrategy;
          module.exports.fibonacci = function (options) {
            return new Backoff(new FibonacciBackoffStrategy(options));
          };
          module.exports.exponential = function (options) {
            return new Backoff(new ExponentialBackoffStrategy(options));
          };
          module.exports.call = function (fn, vargs, callback) {
            const args = Array.prototype.slice.call(arguments);
            fn = args[0];
            vargs = args.slice(1, args.length - 1);
            callback = args[args.length - 1];
            return new FunctionCall(fn, vargs, callback);
          };
        },
        {
          './lib/backoff': 43,
          './lib/function_call.js': 44,
          './lib/strategy/exponential': 45,
          './lib/strategy/fibonacci': 46,
        },
      ],
      43: [
        function (require, module, exports) {
          const events = require('events');
          const precond = require('precond');
          const util = require('util');
          function Backoff(backoffStrategy) {
            events.EventEmitter.call(this);
            this.backoffStrategy_ = backoffStrategy;
            this.maxNumberOfRetry_ = -1;
            this.backoffNumber_ = 0;
            this.backoffDelay_ = 0;
            this.timeoutID_ = -1;
            this.handlers = { backoff: this.onBackoff_.bind(this) };
          }
          util.inherits(Backoff, events.EventEmitter);
          Backoff.prototype.failAfter = function (maxNumberOfRetry) {
            precond.checkArgument(
              maxNumberOfRetry > 0,
              'Expected a maximum number of retry greater than 0 but got %s.',
              maxNumberOfRetry
            );
            this.maxNumberOfRetry_ = maxNumberOfRetry;
          };
          Backoff.prototype.backoff = function (err) {
            precond.checkState(this.timeoutID_ === -1, 'Backoff in progress.');
            if (this.backoffNumber_ === this.maxNumberOfRetry_) {
              this.emit('fail', err);
              this.reset();
            } else {
              this.backoffDelay_ = this.backoffStrategy_.next();
              this.timeoutID_ = setTimeout(
                this.handlers.backoff,
                this.backoffDelay_
              );
              this.emit(
                'backoff',
                this.backoffNumber_,
                this.backoffDelay_,
                err
              );
            }
          };
          Backoff.prototype.onBackoff_ = function () {
            this.timeoutID_ = -1;
            this.emit('ready', this.backoffNumber_, this.backoffDelay_);
            this.backoffNumber_++;
          };
          Backoff.prototype.reset = function () {
            this.backoffNumber_ = 0;
            this.backoffStrategy_.reset();
            clearTimeout(this.timeoutID_);
            this.timeoutID_ = -1;
          };
          module.exports = Backoff;
        },
        { events: 48, precond: 50, util: 60 },
      ],
      44: [
        function (require, module, exports) {
          const events = require('events');
          const precond = require('precond');
          const util = require('util');
          const Backoff = require('./backoff');
          const FibonacciBackoffStrategy = require('./strategy/fibonacci');
          function FunctionCall(fn, args, callback) {
            events.EventEmitter.call(this);
            precond.checkIsFunction(fn, 'Expected fn to be a function.');
            precond.checkIsArray(args, 'Expected args to be an array.');
            precond.checkIsFunction(
              callback,
              'Expected callback to be a function.'
            );
            this.function_ = fn;
            this.arguments_ = args;
            this.callback_ = callback;
            this.lastResult_ = [];
            this.numRetries_ = 0;
            this.backoff_ = null;
            this.strategy_ = null;
            this.failAfter_ = -1;
            this.retryPredicate_ = FunctionCall.DEFAULT_RETRY_PREDICATE_;
            this.state_ = FunctionCall.State_.PENDING;
          }
          util.inherits(FunctionCall, events.EventEmitter);
          FunctionCall.State_ = {
            PENDING: 0,
            RUNNING: 1,
            COMPLETED: 2,
            ABORTED: 3,
          };
          FunctionCall.DEFAULT_RETRY_PREDICATE_ = function (err) {
            return true;
          };
          FunctionCall.prototype.isPending = function () {
            return this.state_ == FunctionCall.State_.PENDING;
          };
          FunctionCall.prototype.isRunning = function () {
            return this.state_ == FunctionCall.State_.RUNNING;
          };
          FunctionCall.prototype.isCompleted = function () {
            return this.state_ == FunctionCall.State_.COMPLETED;
          };
          FunctionCall.prototype.isAborted = function () {
            return this.state_ == FunctionCall.State_.ABORTED;
          };
          FunctionCall.prototype.setStrategy = function (strategy) {
            precond.checkState(this.isPending(), 'FunctionCall in progress.');
            this.strategy_ = strategy;
            return this;
          };
          FunctionCall.prototype.retryIf = function (retryPredicate) {
            precond.checkState(this.isPending(), 'FunctionCall in progress.');
            this.retryPredicate_ = retryPredicate;
            return this;
          };
          FunctionCall.prototype.getLastResult = function () {
            return this.lastResult_.concat();
          };
          FunctionCall.prototype.getNumRetries = function () {
            return this.numRetries_;
          };
          FunctionCall.prototype.failAfter = function (maxNumberOfRetry) {
            precond.checkState(this.isPending(), 'FunctionCall in progress.');
            this.failAfter_ = maxNumberOfRetry;
            return this;
          };
          FunctionCall.prototype.abort = function () {
            if (this.isCompleted() || this.isAborted()) {
              return;
            }
            if (this.isRunning()) {
              this.backoff_.reset();
            }
            this.state_ = FunctionCall.State_.ABORTED;
            this.lastResult_ = [new Error('Backoff aborted.')];
            this.emit('abort');
            this.doCallback_();
          };
          FunctionCall.prototype.start = function (backoffFactory) {
            precond.checkState(!this.isAborted(), 'FunctionCall is aborted.');
            precond.checkState(
              this.isPending(),
              'FunctionCall already started.'
            );
            const strategy = this.strategy_ || new FibonacciBackoffStrategy();
            this.backoff_ = backoffFactory
              ? backoffFactory(strategy)
              : new Backoff(strategy);
            this.backoff_.on('ready', this.doCall_.bind(this, true));
            this.backoff_.on('fail', this.doCallback_.bind(this));
            this.backoff_.on('backoff', this.handleBackoff_.bind(this));
            if (this.failAfter_ > 0) {
              this.backoff_.failAfter(this.failAfter_);
            }
            this.state_ = FunctionCall.State_.RUNNING;
            this.doCall_(false);
          };
          FunctionCall.prototype.doCall_ = function (isRetry) {
            if (isRetry) {
              this.numRetries_++;
            }
            const eventArgs = ['call'].concat(this.arguments_);
            events.EventEmitter.prototype.emit.apply(this, eventArgs);
            const callback = this.handleFunctionCallback_.bind(this);
            this.function_.apply(null, this.arguments_.concat(callback));
          };
          FunctionCall.prototype.doCallback_ = function () {
            this.callback_.apply(null, this.lastResult_);
          };
          FunctionCall.prototype.handleFunctionCallback_ = function () {
            if (this.isAborted()) {
              return;
            }
            const args = Array.prototype.slice.call(arguments);
            this.lastResult_ = args;
            events.EventEmitter.prototype.emit.apply(
              this,
              ['callback'].concat(args)
            );
            const err = args[0];
            if (err && this.retryPredicate_(err)) {
              this.backoff_.backoff(err);
            } else {
              this.state_ = FunctionCall.State_.COMPLETED;
              this.doCallback_();
            }
          };
          FunctionCall.prototype.handleBackoff_ = function (
            number,
            delay,
            err
          ) {
            this.emit('backoff', number, delay, err);
          };
          module.exports = FunctionCall;
        },
        {
          './backoff': 43,
          './strategy/fibonacci': 46,
          events: 48,
          precond: 50,
          util: 60,
        },
      ],
      45: [
        function (require, module, exports) {
          const util = require('util');
          const precond = require('precond');
          const BackoffStrategy = require('./strategy');
          function ExponentialBackoffStrategy(options) {
            BackoffStrategy.call(this, options);
            this.backoffDelay_ = 0;
            this.nextBackoffDelay_ = this.getInitialDelay();
            this.factor_ = ExponentialBackoffStrategy.DEFAULT_FACTOR;
            if (options && options.factor !== undefined) {
              precond.checkArgument(
                options.factor > 1,
                'Exponential factor should be greater than 1 but got %s.',
                options.factor
              );
              this.factor_ = options.factor;
            }
          }
          util.inherits(ExponentialBackoffStrategy, BackoffStrategy);
          ExponentialBackoffStrategy.DEFAULT_FACTOR = 2;
          ExponentialBackoffStrategy.prototype.next_ = function () {
            this.backoffDelay_ = Math.min(
              this.nextBackoffDelay_,
              this.getMaxDelay()
            );
            this.nextBackoffDelay_ = this.backoffDelay_ * this.factor_;
            return this.backoffDelay_;
          };
          ExponentialBackoffStrategy.prototype.reset_ = function () {
            this.backoffDelay_ = 0;
            this.nextBackoffDelay_ = this.getInitialDelay();
          };
          module.exports = ExponentialBackoffStrategy;
        },
        { './strategy': 47, precond: 50, util: 60 },
      ],
      46: [
        function (require, module, exports) {
          const util = require('util');
          const BackoffStrategy = require('./strategy');
          function FibonacciBackoffStrategy(options) {
            BackoffStrategy.call(this, options);
            this.backoffDelay_ = 0;
            this.nextBackoffDelay_ = this.getInitialDelay();
          }
          util.inherits(FibonacciBackoffStrategy, BackoffStrategy);
          FibonacciBackoffStrategy.prototype.next_ = function () {
            const backoffDelay = Math.min(
              this.nextBackoffDelay_,
              this.getMaxDelay()
            );
            this.nextBackoffDelay_ += this.backoffDelay_;
            this.backoffDelay_ = backoffDelay;
            return backoffDelay;
          };
          FibonacciBackoffStrategy.prototype.reset_ = function () {
            this.nextBackoffDelay_ = this.getInitialDelay();
            this.backoffDelay_ = 0;
          };
          module.exports = FibonacciBackoffStrategy;
        },
        { './strategy': 47, util: 60 },
      ],
      47: [
        function (require, module, exports) {
          const events = require('events');
          const util = require('util');
          function isDef(value) {
            return value !== undefined && value !== null;
          }
          function BackoffStrategy(options) {
            options = options || {};
            if (isDef(options.initialDelay) && options.initialDelay < 1) {
              throw new Error('The initial timeout must be greater than 0.');
            } else if (isDef(options.maxDelay) && options.maxDelay < 1) {
              throw new Error('The maximal timeout must be greater than 0.');
            }
            this.initialDelay_ = options.initialDelay || 100;
            this.maxDelay_ = options.maxDelay || 1e4;
            if (this.maxDelay_ <= this.initialDelay_) {
              throw new Error(
                'The maximal backoff delay must be ' +
                  'greater than the initial backoff delay.'
              );
            }
            if (
              isDef(options.randomisationFactor) &&
              (options.randomisationFactor < 0 ||
                options.randomisationFactor > 1)
            ) {
              throw new Error(
                'The randomisation factor must be between 0 and 1.'
              );
            }
            this.randomisationFactor_ = options.randomisationFactor || 0;
          }
          BackoffStrategy.prototype.getMaxDelay = function () {
            return this.maxDelay_;
          };
          BackoffStrategy.prototype.getInitialDelay = function () {
            return this.initialDelay_;
          };
          BackoffStrategy.prototype.next = function () {
            const backoffDelay = this.next_();
            const randomisationMultiple =
              1 + Math.random() * this.randomisationFactor_;
            return Math.round(backoffDelay * randomisationMultiple);
          };
          BackoffStrategy.prototype.next_ = function () {
            throw new Error('BackoffStrategy.next_() unimplemented.');
          };
          BackoffStrategy.prototype.reset = function () {
            this.reset_();
          };
          BackoffStrategy.prototype.reset_ = function () {
            throw new Error('BackoffStrategy.reset_() unimplemented.');
          };
          module.exports = BackoffStrategy;
        },
        { events: 48, util: 60 },
      ],
      48: [
        function (require, module, exports) {
          const objectCreate = Object.create || objectCreatePolyfill;
          const objectKeys = Object.keys || objectKeysPolyfill;
          const bind = Function.prototype.bind || functionBindPolyfill;
          function EventEmitter() {
            if (
              !this._events ||
              !Object.prototype.hasOwnProperty.call(this, '_events')
            ) {
              this._events = objectCreate(null);
              this._eventsCount = 0;
            }
            this._maxListeners = this._maxListeners || undefined;
          }
          module.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = undefined;
          EventEmitter.prototype._maxListeners = undefined;
          let defaultMaxListeners = 10;
          let hasDefineProperty;
          try {
            const o = {};
            if (Object.defineProperty)
              Object.defineProperty(o, 'x', { value: 0 });
            hasDefineProperty = o.x === 0;
          } catch (err) {
            hasDefineProperty = false;
          }
          if (hasDefineProperty) {
            Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
              enumerable: true,
              get() {
                return defaultMaxListeners;
              },
              set(arg) {
                if (typeof arg !== 'number' || arg < 0 || arg !== arg)
                  throw new TypeError(
                    '"defaultMaxListeners" must be a positive number'
                  );
                defaultMaxListeners = arg;
              },
            });
          } else {
            EventEmitter.defaultMaxListeners = defaultMaxListeners;
          }
          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
            if (typeof n !== 'number' || n < 0 || isNaN(n))
              throw new TypeError('"n" argument must be a positive number');
            this._maxListeners = n;
            return this;
          };
          function $getMaxListeners(that) {
            if (that._maxListeners === undefined)
              return EventEmitter.defaultMaxListeners;
            return that._maxListeners;
          }
          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
            return $getMaxListeners(this);
          };
          function emitNone(handler, isFn, self) {
            if (isFn) handler.call(self);
            else {
              const len = handler.length;
              const listeners = arrayClone(handler, len);
              for (let i = 0; i < len; ++i) listeners[i].call(self);
            }
          }
          function emitOne(handler, isFn, self, arg1) {
            if (isFn) handler.call(self, arg1);
            else {
              const len = handler.length;
              const listeners = arrayClone(handler, len);
              for (let i = 0; i < len; ++i) listeners[i].call(self, arg1);
            }
          }
          function emitTwo(handler, isFn, self, arg1, arg2) {
            if (isFn) handler.call(self, arg1, arg2);
            else {
              const len = handler.length;
              const listeners = arrayClone(handler, len);
              for (let i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
            }
          }
          function emitThree(handler, isFn, self, arg1, arg2, arg3) {
            if (isFn) handler.call(self, arg1, arg2, arg3);
            else {
              const len = handler.length;
              const listeners = arrayClone(handler, len);
              for (let i = 0; i < len; ++i)
                listeners[i].call(self, arg1, arg2, arg3);
            }
          }
          function emitMany(handler, isFn, self, args) {
            if (isFn) handler.apply(self, args);
            else {
              const len = handler.length;
              const listeners = arrayClone(handler, len);
              for (let i = 0; i < len; ++i) listeners[i].apply(self, args);
            }
          }
          EventEmitter.prototype.emit = function emit(type) {
            let er;
            let handler;
            let len;
            let args;
            let i;
            let events;
            let doError = type === 'error';
            events = this._events;
            if (events) doError = doError && events.error == null;
            else if (!doError) return false;
            if (doError) {
              if (arguments.length > 1) er = arguments[1];
              if (er instanceof Error) {
                throw er;
              } else {
                const err = new Error(`Unhandled "error" event. (${er})`);
                err.context = er;
                throw err;
              }
              return false;
            }
            handler = events[type];
            if (!handler) return false;
            const isFn = typeof handler === 'function';
            len = arguments.length;
            switch (len) {
              case 1:
                emitNone(handler, isFn, this);
                break;
              case 2:
                emitOne(handler, isFn, this, arguments[1]);
                break;
              case 3:
                emitTwo(handler, isFn, this, arguments[1], arguments[2]);
                break;
              case 4:
                emitThree(
                  handler,
                  isFn,
                  this,
                  arguments[1],
                  arguments[2],
                  arguments[3]
                );
                break;
              default:
                args = new Array(len - 1);
                for (i = 1; i < len; i++) args[i - 1] = arguments[i];
                emitMany(handler, isFn, this, args);
            }
            return true;
          };
          function _addListener(target, type, listener, prepend) {
            let m;
            let events;
            let existing;
            if (typeof listener !== 'function')
              throw new TypeError('"listener" argument must be a function');
            events = target._events;
            if (!events) {
              events = target._events = objectCreate(null);
              target._eventsCount = 0;
            } else {
              if (events.newListener) {
                target.emit(
                  'newListener',
                  type,
                  listener.listener ? listener.listener : listener
                );
                events = target._events;
              }
              existing = events[type];
            }
            if (!existing) {
              existing = events[type] = listener;
              ++target._eventsCount;
            } else {
              if (typeof existing === 'function') {
                existing = events[type] = prepend
                  ? [listener, existing]
                  : [existing, listener];
              } else if (prepend) {
                existing.unshift(listener);
              } else {
                existing.push(listener);
              }
              if (!existing.warned) {
                m = $getMaxListeners(target);
                if (m && m > 0 && existing.length > m) {
                  existing.warned = true;
                  const w = new Error(
                    `Possible EventEmitter memory leak detected. ${
                      existing.length
                    } "${String(type)}" listeners ` +
                      `added. Use emitter.setMaxListeners() to ` +
                      `increase limit.`
                  );
                  w.name = 'MaxListenersExceededWarning';
                  w.emitter = target;
                  w.type = type;
                  w.count = existing.length;
                  if (typeof console === 'object' && console.warn) {
                    console.warn('%s: %s', w.name, w.message);
                  }
                }
              }
            }
            return target;
          }
          EventEmitter.prototype.addListener = function addListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, false);
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.prependListener = function prependListener(
            type,
            listener
          ) {
            return _addListener(this, type, listener, true);
          };
          function onceWrapper() {
            if (!this.fired) {
              this.target.removeListener(this.type, this.wrapFn);
              this.fired = true;
              switch (arguments.length) {
                case 0:
                  return this.listener.call(this.target);
                case 1:
                  return this.listener.call(this.target, arguments[0]);
                case 2:
                  return this.listener.call(
                    this.target,
                    arguments[0],
                    arguments[1]
                  );
                case 3:
                  return this.listener.call(
                    this.target,
                    arguments[0],
                    arguments[1],
                    arguments[2]
                  );
                default:
                  var args = new Array(arguments.length);
                  for (let i = 0; i < args.length; ++i) args[i] = arguments[i];
                  this.listener.apply(this.target, args);
              }
            }
          }
          function _onceWrap(target, type, listener) {
            const state = {
              fired: false,
              wrapFn: undefined,
              target,
              type,
              listener,
            };
            const wrapped = bind.call(onceWrapper, state);
            wrapped.listener = listener;
            state.wrapFn = wrapped;
            return wrapped;
          }
          EventEmitter.prototype.once = function once(type, listener) {
            if (typeof listener !== 'function')
              throw new TypeError('"listener" argument must be a function');
            this.on(type, _onceWrap(this, type, listener));
            return this;
          };
          EventEmitter.prototype.prependOnceListener =
            function prependOnceListener(type, listener) {
              if (typeof listener !== 'function')
                throw new TypeError('"listener" argument must be a function');
              this.prependListener(type, _onceWrap(this, type, listener));
              return this;
            };
          EventEmitter.prototype.removeListener = function removeListener(
            type,
            listener
          ) {
            let list;
            let events;
            let position;
            let i;
            let originalListener;
            if (typeof listener !== 'function')
              throw new TypeError('"listener" argument must be a function');
            events = this._events;
            if (!events) return this;
            list = events[type];
            if (!list) return this;
            if (list === listener || list.listener === listener) {
              if (--this._eventsCount === 0) this._events = objectCreate(null);
              else {
                delete events[type];
                if (events.removeListener)
                  this.emit('removeListener', type, list.listener || listener);
              }
            } else if (typeof list !== 'function') {
              position = -1;
              for (i = list.length - 1; i >= 0; i--) {
                if (list[i] === listener || list[i].listener === listener) {
                  originalListener = list[i].listener;
                  position = i;
                  break;
                }
              }
              if (position < 0) return this;
              if (position === 0) list.shift();
              else spliceOne(list, position);
              if (list.length === 1) events[type] = list[0];
              if (events.removeListener)
                this.emit('removeListener', type, originalListener || listener);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners =
            function removeAllListeners(type) {
              let listeners;
              let events;
              let i;
              events = this._events;
              if (!events) return this;
              if (!events.removeListener) {
                if (arguments.length === 0) {
                  this._events = objectCreate(null);
                  this._eventsCount = 0;
                } else if (events[type]) {
                  if (--this._eventsCount === 0)
                    this._events = objectCreate(null);
                  else delete events[type];
                }
                return this;
              }
              if (arguments.length === 0) {
                const keys = objectKeys(events);
                let key;
                for (i = 0; i < keys.length; ++i) {
                  key = keys[i];
                  if (key === 'removeListener') continue;
                  this.removeAllListeners(key);
                }
                this.removeAllListeners('removeListener');
                this._events = objectCreate(null);
                this._eventsCount = 0;
                return this;
              }
              listeners = events[type];
              if (typeof listeners === 'function') {
                this.removeListener(type, listeners);
              } else if (listeners) {
                for (i = listeners.length - 1; i >= 0; i--) {
                  this.removeListener(type, listeners[i]);
                }
              }
              return this;
            };
          function _listeners(target, type, unwrap) {
            const events = target._events;
            if (!events) return [];
            const evlistener = events[type];
            if (!evlistener) return [];
            if (typeof evlistener === 'function')
              return unwrap
                ? [evlistener.listener || evlistener]
                : [evlistener];
            return unwrap
              ? unwrapListeners(evlistener)
              : arrayClone(evlistener, evlistener.length);
          }
          EventEmitter.prototype.listeners = function listeners(type) {
            return _listeners(this, type, true);
          };
          EventEmitter.prototype.rawListeners = function rawListeners(type) {
            return _listeners(this, type, false);
          };
          EventEmitter.listenerCount = function (emitter, type) {
            if (typeof emitter.listenerCount === 'function') {
              return emitter.listenerCount(type);
            }
            return listenerCount.call(emitter, type);
          };
          EventEmitter.prototype.listenerCount = listenerCount;
          function listenerCount(type) {
            const events = this._events;
            if (events) {
              const evlistener = events[type];
              if (typeof evlistener === 'function') {
                return 1;
              } else if (evlistener) {
                return evlistener.length;
              }
            }
            return 0;
          }
          EventEmitter.prototype.eventNames = function eventNames() {
            return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
          };
          function spliceOne(list, index) {
            for (
              let i = index, k = i + 1, n = list.length;
              k < n;
              i += 1, k += 1
            )
              list[i] = list[k];
            list.pop();
          }
          function arrayClone(arr, n) {
            const copy = new Array(n);
            for (let i = 0; i < n; ++i) copy[i] = arr[i];
            return copy;
          }
          function unwrapListeners(arr) {
            const ret = new Array(arr.length);
            for (let i = 0; i < ret.length; ++i) {
              ret[i] = arr[i].listener || arr[i];
            }
            return ret;
          }
          function objectCreatePolyfill(proto) {
            const F = function () {};
            F.prototype = proto;
            return new F();
          }
          function objectKeysPolyfill(obj) {
            const keys = [];
            for (var k in obj)
              if (Object.prototype.hasOwnProperty.call(obj, k)) {
                keys.push(k);
              }
            return k;
          }
          function functionBindPolyfill(context) {
            const fn = this;
            return function () {
              return fn.apply(context, arguments);
            };
          }
        },
        {},
      ],
      49: [
        function (require, module, exports) {
          (function (root, definition) {
            if (typeof define === 'function' && define.amd) {
              define(definition);
            } else if (typeof module === 'object' && module.exports) {
              module.exports = definition();
            } else {
              root.log = definition();
            }
          })(this, function () {
            const noop = function () {};
            const undefinedType = 'undefined';
            const isIE =
              typeof window !== undefinedType &&
              typeof window.navigator !== undefinedType &&
              /Trident\/|MSIE /.test(window.navigator.userAgent);
            const logMethods = ['trace', 'debug', 'info', 'warn', 'error'];
            function bindMethod(obj, methodName) {
              const method = obj[methodName];
              if (typeof method.bind === 'function') {
                return method.bind(obj);
              }
              try {
                return Function.prototype.bind.call(method, obj);
              } catch (e) {
                return function () {
                  return Function.prototype.apply.apply(method, [
                    obj,
                    arguments,
                  ]);
                };
              }
            }
            function traceForIE() {
              if (console.log) {
                if (console.log.apply) {
                  console.log.apply(console, arguments);
                } else {
                  Function.prototype.apply.apply(console.log, [
                    console,
                    arguments,
                  ]);
                }
              }
              if (console.trace) console.trace();
            }
            function realMethod(methodName) {
              if (methodName === 'debug') {
                methodName = 'log';
              }
              if (typeof console === undefinedType) {
                return false;
              } else if (methodName === 'trace' && isIE) {
                return traceForIE;
              } else if (console[methodName] !== undefined) {
                return bindMethod(console, methodName);
              } else if (console.log !== undefined) {
                return bindMethod(console, 'log');
              }
              return noop;
            }
            function replaceLoggingMethods(level, loggerName) {
              for (let i = 0; i < logMethods.length; i++) {
                const methodName = logMethods[i];
                this[methodName] =
                  i < level
                    ? noop
                    : this.methodFactory(methodName, level, loggerName);
              }
              this.log = this.debug;
            }
            function enableLoggingWhenConsoleArrives(
              methodName,
              level,
              loggerName
            ) {
              return function () {
                if (typeof console !== undefinedType) {
                  replaceLoggingMethods.call(this, level, loggerName);
                  this[methodName].apply(this, arguments);
                }
              };
            }
            function defaultMethodFactory(methodName, level, loggerName) {
              return (
                realMethod(methodName) ||
                enableLoggingWhenConsoleArrives.apply(this, arguments)
              );
            }
            function Logger(name, defaultLevel, factory) {
              const self = this;
              let currentLevel;
              let storageKey = 'loglevel';
              if (name) {
                storageKey += `:${name}`;
              }
              function persistLevelIfPossible(levelNum) {
                const levelName = (
                  logMethods[levelNum] || 'silent'
                ).toUpperCase();
                if (typeof window === undefinedType) return;
                try {
                  window.localStorage[storageKey] = levelName;
                  return;
                } catch (ignore) {}
                try {
                  window.document.cookie = `${encodeURIComponent(
                    storageKey
                  )}=${levelName};`;
                } catch (ignore) {}
              }
              function getPersistedLevel() {
                let storedLevel;
                if (typeof window === undefinedType) return;
                try {
                  storedLevel = window.localStorage[storageKey];
                } catch (ignore) {}
                if (typeof storedLevel === undefinedType) {
                  try {
                    const { cookie } = window.document;
                    const location = cookie.indexOf(
                      `${encodeURIComponent(storageKey)}=`
                    );
                    if (location !== -1) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                    }
                  } catch (ignore) {}
                }
                if (self.levels[storedLevel] === undefined) {
                  storedLevel = undefined;
                }
                return storedLevel;
              }
              self.name = name;
              self.levels = {
                TRACE: 0,
                DEBUG: 1,
                INFO: 2,
                WARN: 3,
                ERROR: 4,
                SILENT: 5,
              };
              self.methodFactory = factory || defaultMethodFactory;
              self.getLevel = function () {
                return currentLevel;
              };
              self.setLevel = function (level, persist) {
                if (
                  typeof level === 'string' &&
                  self.levels[level.toUpperCase()] !== undefined
                ) {
                  level = self.levels[level.toUpperCase()];
                }
                if (
                  typeof level === 'number' &&
                  level >= 0 &&
                  level <= self.levels.SILENT
                ) {
                  currentLevel = level;
                  if (persist !== false) {
                    persistLevelIfPossible(level);
                  }
                  replaceLoggingMethods.call(self, level, name);
                  if (
                    typeof console === undefinedType &&
                    level < self.levels.SILENT
                  ) {
                    return 'No console available for logging';
                  }
                } else {
                  throw `log.setLevel() called with invalid level: ${level}`;
                }
              };
              self.setDefaultLevel = function (level) {
                if (!getPersistedLevel()) {
                  self.setLevel(level, false);
                }
              };
              self.enableAll = function (persist) {
                self.setLevel(self.levels.TRACE, persist);
              };
              self.disableAll = function (persist) {
                self.setLevel(self.levels.SILENT, persist);
              };
              let initialLevel = getPersistedLevel();
              if (initialLevel == null) {
                initialLevel = defaultLevel == null ? 'WARN' : defaultLevel;
              }
              self.setLevel(initialLevel, false);
            }
            const defaultLogger = new Logger();
            const _loggersByName = {};
            defaultLogger.getLogger = function getLogger(name) {
              if (typeof name !== 'string' || name === '') {
                throw new TypeError(
                  'You must supply a name when creating a logger.'
                );
              }
              let logger = _loggersByName[name];
              if (!logger) {
                logger = _loggersByName[name] = new Logger(
                  name,
                  defaultLogger.getLevel(),
                  defaultLogger.methodFactory
                );
              }
              return logger;
            };
            const _log =
              typeof window !== undefinedType ? window.log : undefined;
            defaultLogger.noConflict = function () {
              if (
                typeof window !== undefinedType &&
                window.log === defaultLogger
              ) {
                window.log = _log;
              }
              return defaultLogger;
            };
            defaultLogger.getLoggers = function getLoggers() {
              return _loggersByName;
            };
            return defaultLogger;
          });
        },
        {},
      ],
      50: [
        function (require, module, exports) {
          module.exports = require('./lib/checks');
        },
        { './lib/checks': 51 },
      ],
      51: [
        function (require, module, exports) {
          const util = require('util');
          const errors = (module.exports = require('./errors'));
          function failCheck(
            ExceptionConstructor,
            callee,
            messageFormat,
            formatArgs
          ) {
            messageFormat = messageFormat || '';
            const message = util.format.apply(
              this,
              [messageFormat].concat(formatArgs)
            );
            const error = new ExceptionConstructor(message);
            Error.captureStackTrace(error, callee);
            throw error;
          }
          function failArgumentCheck(callee, message, formatArgs) {
            failCheck(errors.IllegalArgumentError, callee, message, formatArgs);
          }
          function failStateCheck(callee, message, formatArgs) {
            failCheck(errors.IllegalStateError, callee, message, formatArgs);
          }
          module.exports.checkArgument = function (value, message) {
            if (!value) {
              failArgumentCheck(
                arguments.callee,
                message,
                Array.prototype.slice.call(arguments, 2)
              );
            }
          };
          module.exports.checkState = function (value, message) {
            if (!value) {
              failStateCheck(
                arguments.callee,
                message,
                Array.prototype.slice.call(arguments, 2)
              );
            }
          };
          module.exports.checkIsDef = function (value, message) {
            if (value !== undefined) {
              return value;
            }
            failArgumentCheck(
              arguments.callee,
              message || 'Expected value to be defined but was undefined.',
              Array.prototype.slice.call(arguments, 2)
            );
          };
          module.exports.checkIsDefAndNotNull = function (value, message) {
            if (value != null) {
              return value;
            }
            failArgumentCheck(
              arguments.callee,
              message ||
                `Expected value to be defined and not null but got "${typeOf(
                  value
                )}".`,
              Array.prototype.slice.call(arguments, 2)
            );
          };
          function typeOf(value) {
            const s = typeof value;
            if (s == 'object') {
              if (!value) {
                return 'null';
              } else if (value instanceof Array) {
                return 'array';
              }
            }
            return s;
          }
          function typeCheck(expect) {
            return function (value, message) {
              const type = typeOf(value);
              if (type == expect) {
                return value;
              }
              failArgumentCheck(
                arguments.callee,
                message || `Expected "${expect}" but got "${type}".`,
                Array.prototype.slice.call(arguments, 2)
              );
            };
          }
          module.exports.checkIsString = typeCheck('string');
          module.exports.checkIsArray = typeCheck('array');
          module.exports.checkIsNumber = typeCheck('number');
          module.exports.checkIsBoolean = typeCheck('boolean');
          module.exports.checkIsFunction = typeCheck('function');
          module.exports.checkIsObject = typeCheck('object');
        },
        { './errors': 52, util: 60 },
      ],
      52: [
        function (require, module, exports) {
          const util = require('util');
          function IllegalArgumentError(message) {
            Error.call(this, message);
            this.message = message;
          }
          util.inherits(IllegalArgumentError, Error);
          IllegalArgumentError.prototype.name = 'IllegalArgumentError';
          function IllegalStateError(message) {
            Error.call(this, message);
            this.message = message;
          }
          util.inherits(IllegalStateError, Error);
          IllegalStateError.prototype.name = 'IllegalStateError';
          module.exports.IllegalStateError = IllegalStateError;
          module.exports.IllegalArgumentError = IllegalArgumentError;
        },
        { util: 60 },
      ],
      53: [
        function (require, module, exports) {
          const process = (module.exports = {});
          let cachedSetTimeout;
          let cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error('setTimeout has not been defined');
          }
          function defaultClearTimeout() {
            throw new Error('clearTimeout has not been defined');
          }
          (function () {
            try {
              if (typeof setTimeout === 'function') {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === 'function') {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if (
              (cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) &&
              setTimeout
            ) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if (
              (cachedClearTimeout === defaultClearTimeout ||
                !cachedClearTimeout) &&
              clearTimeout
            ) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          let queue = [];
          let draining = false;
          let currentQueue;
          let queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            const timeout = runTimeout(cleanUpNextTick);
            draining = true;
            let len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function (fun) {
            const args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (let i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function () {
            this.fun.apply(null, this.array);
          };
          process.title = 'browser';
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = '';
          process.versions = {};
          function noop() {}
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;
          process.listeners = function (name) {
            return [];
          };
          process.binding = function (name) {
            throw new Error('process.binding is not supported');
          };
          process.cwd = function () {
            return '/';
          };
          process.chdir = function (dir) {
            throw new Error('process.chdir is not supported');
          };
          process.umask = function () {
            return 0;
          };
        },
        {},
      ],
      54: [
        function (require, module, exports) {
          const g =
            (function () {
              return this;
            })() || Function('return this')();
          const hadRuntime =
            g.regeneratorRuntime &&
            Object.getOwnPropertyNames(g).indexOf('regeneratorRuntime') >= 0;
          const oldRuntime = hadRuntime && g.regeneratorRuntime;
          g.regeneratorRuntime = undefined;
          module.exports = require('./runtime');
          if (hadRuntime) {
            g.regeneratorRuntime = oldRuntime;
          } else {
            try {
              delete g.regeneratorRuntime;
            } catch (e) {
              g.regeneratorRuntime = undefined;
            }
          }
        },
        { './runtime': 55 },
      ],
      55: [
        function (require, module, exports) {
          !(function (global) {
            const Op = Object.prototype;
            const hasOwn = Op.hasOwnProperty;
            let undefined;
            const $Symbol = typeof Symbol === 'function' ? Symbol : {};
            const iteratorSymbol = $Symbol.iterator || '@@iterator';
            const asyncIteratorSymbol =
              $Symbol.asyncIterator || '@@asyncIterator';
            const toStringTagSymbol = $Symbol.toStringTag || '@@toStringTag';
            const inModule = typeof module === 'object';
            let runtime = global.regeneratorRuntime;
            if (runtime) {
              if (inModule) {
                module.exports = runtime;
              }
              return;
            }
            runtime = global.regeneratorRuntime = inModule
              ? module.exports
              : {};
            function wrap(innerFn, outerFn, self, tryLocsList) {
              const protoGenerator =
                outerFn && outerFn.prototype instanceof Generator
                  ? outerFn
                  : Generator;
              const generator = Object.create(protoGenerator.prototype);
              const context = new Context(tryLocsList || []);
              generator._invoke = makeInvokeMethod(innerFn, self, context);
              return generator;
            }
            runtime.wrap = wrap;
            function tryCatch(fn, obj, arg) {
              try {
                return { type: 'normal', arg: fn.call(obj, arg) };
              } catch (err) {
                return { type: 'throw', arg: err };
              }
            }
            const GenStateSuspendedStart = 'suspendedStart';
            const GenStateSuspendedYield = 'suspendedYield';
            const GenStateExecuting = 'executing';
            const GenStateCompleted = 'completed';
            const ContinueSentinel = {};
            function Generator() {}
            function GeneratorFunction() {}
            function GeneratorFunctionPrototype() {}
            let IteratorPrototype = {};
            IteratorPrototype[iteratorSymbol] = function () {
              return this;
            };
            const getProto = Object.getPrototypeOf;
            const NativeIteratorPrototype =
              getProto && getProto(getProto(values([])));
            if (
              NativeIteratorPrototype &&
              NativeIteratorPrototype !== Op &&
              hasOwn.call(NativeIteratorPrototype, iteratorSymbol)
            ) {
              IteratorPrototype = NativeIteratorPrototype;
            }
            const Gp =
              (GeneratorFunctionPrototype.prototype =
              Generator.prototype =
                Object.create(IteratorPrototype));
            GeneratorFunction.prototype = Gp.constructor =
              GeneratorFunctionPrototype;
            GeneratorFunctionPrototype.constructor = GeneratorFunction;
            GeneratorFunctionPrototype[toStringTagSymbol] =
              GeneratorFunction.displayName = 'GeneratorFunction';
            function defineIteratorMethods(prototype) {
              ['next', 'throw', 'return'].forEach(function (method) {
                prototype[method] = function (arg) {
                  return this._invoke(method, arg);
                };
              });
            }
            runtime.isGeneratorFunction = function (genFun) {
              const ctor = typeof genFun === 'function' && genFun.constructor;
              return ctor
                ? ctor === GeneratorFunction ||
                    (ctor.displayName || ctor.name) === 'GeneratorFunction'
                : false;
            };
            runtime.mark = function (genFun) {
              if (Object.setPrototypeOf) {
                Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
              } else {
                genFun.__proto__ = GeneratorFunctionPrototype;
                if (!(toStringTagSymbol in genFun)) {
                  genFun[toStringTagSymbol] = 'GeneratorFunction';
                }
              }
              genFun.prototype = Object.create(Gp);
              return genFun;
            };
            runtime.awrap = function (arg) {
              return { __await: arg };
            };
            function AsyncIterator(generator) {
              function invoke(method, arg, resolve, reject) {
                const record = tryCatch(generator[method], generator, arg);
                if (record.type === 'throw') {
                  reject(record.arg);
                } else {
                  const result = record.arg;
                  const { value } = result;
                  if (
                    value &&
                    typeof value === 'object' &&
                    hasOwn.call(value, '__await')
                  ) {
                    return Promise.resolve(value.__await).then(
                      function (value) {
                        invoke('next', value, resolve, reject);
                      },
                      function (err) {
                        invoke('throw', err, resolve, reject);
                      }
                    );
                  }
                  return Promise.resolve(value).then(function (unwrapped) {
                    result.value = unwrapped;
                    resolve(result);
                  }, reject);
                }
              }
              let previousPromise;
              function enqueue(method, arg) {
                function callInvokeWithMethodAndArg() {
                  return new Promise(function (resolve, reject) {
                    invoke(method, arg, resolve, reject);
                  });
                }
                return (previousPromise = previousPromise
                  ? previousPromise.then(
                      callInvokeWithMethodAndArg,
                      callInvokeWithMethodAndArg
                    )
                  : callInvokeWithMethodAndArg());
              }
              this._invoke = enqueue;
            }
            defineIteratorMethods(AsyncIterator.prototype);
            AsyncIterator.prototype[asyncIteratorSymbol] = function () {
              return this;
            };
            runtime.AsyncIterator = AsyncIterator;
            runtime.async = function (innerFn, outerFn, self, tryLocsList) {
              const iter = new AsyncIterator(
                wrap(innerFn, outerFn, self, tryLocsList)
              );
              return runtime.isGeneratorFunction(outerFn)
                ? iter
                : iter.next().then(function (result) {
                    return result.done ? result.value : iter.next();
                  });
            };
            function makeInvokeMethod(innerFn, self, context) {
              let state = GenStateSuspendedStart;
              return function invoke(method, arg) {
                if (state === GenStateExecuting) {
                  throw new Error('Generator is already running');
                }
                if (state === GenStateCompleted) {
                  if (method === 'throw') {
                    throw arg;
                  }
                  return doneResult();
                }
                context.method = method;
                context.arg = arg;
                while (true) {
                  const { delegate } = context;
                  if (delegate) {
                    const delegateResult = maybeInvokeDelegate(
                      delegate,
                      context
                    );
                    if (delegateResult) {
                      if (delegateResult === ContinueSentinel) continue;
                      return delegateResult;
                    }
                  }
                  if (context.method === 'next') {
                    context.sent = context._sent = context.arg;
                  } else if (context.method === 'throw') {
                    if (state === GenStateSuspendedStart) {
                      state = GenStateCompleted;
                      throw context.arg;
                    }
                    context.dispatchException(context.arg);
                  } else if (context.method === 'return') {
                    context.abrupt('return', context.arg);
                  }
                  state = GenStateExecuting;
                  const record = tryCatch(innerFn, self, context);
                  if (record.type === 'normal') {
                    state = context.done
                      ? GenStateCompleted
                      : GenStateSuspendedYield;
                    if (record.arg === ContinueSentinel) {
                      continue;
                    }
                    return { value: record.arg, done: context.done };
                  } else if (record.type === 'throw') {
                    state = GenStateCompleted;
                    context.method = 'throw';
                    context.arg = record.arg;
                  }
                }
              };
            }
            function maybeInvokeDelegate(delegate, context) {
              const method = delegate.iterator[context.method];
              if (method === undefined) {
                context.delegate = null;
                if (context.method === 'throw') {
                  if (delegate.iterator.return) {
                    context.method = 'return';
                    context.arg = undefined;
                    maybeInvokeDelegate(delegate, context);
                    if (context.method === 'throw') {
                      return ContinueSentinel;
                    }
                  }
                  context.method = 'throw';
                  context.arg = new TypeError(
                    "The iterator does not provide a 'throw' method"
                  );
                }
                return ContinueSentinel;
              }
              const record = tryCatch(method, delegate.iterator, context.arg);
              if (record.type === 'throw') {
                context.method = 'throw';
                context.arg = record.arg;
                context.delegate = null;
                return ContinueSentinel;
              }
              const info = record.arg;
              if (!info) {
                context.method = 'throw';
                context.arg = new TypeError('iterator result is not an object');
                context.delegate = null;
                return ContinueSentinel;
              }
              if (info.done) {
                context[delegate.resultName] = info.value;
                context.next = delegate.nextLoc;
                if (context.method !== 'return') {
                  context.method = 'next';
                  context.arg = undefined;
                }
              } else {
                return info;
              }
              context.delegate = null;
              return ContinueSentinel;
            }
            defineIteratorMethods(Gp);
            Gp[toStringTagSymbol] = 'Generator';
            Gp[iteratorSymbol] = function () {
              return this;
            };
            Gp.toString = function () {
              return '[object Generator]';
            };
            function pushTryEntry(locs) {
              const entry = { tryLoc: locs[0] };
              if (1 in locs) {
                entry.catchLoc = locs[1];
              }
              if (2 in locs) {
                entry.finallyLoc = locs[2];
                entry.afterLoc = locs[3];
              }
              this.tryEntries.push(entry);
            }
            function resetTryEntry(entry) {
              const record = entry.completion || {};
              record.type = 'normal';
              delete record.arg;
              entry.completion = record;
            }
            function Context(tryLocsList) {
              this.tryEntries = [{ tryLoc: 'root' }];
              tryLocsList.forEach(pushTryEntry, this);
              this.reset(true);
            }
            runtime.keys = function (object) {
              const keys = [];
              for (const key in object) {
                keys.push(key);
              }
              keys.reverse();
              return function next() {
                while (keys.length) {
                  const key = keys.pop();
                  if (key in object) {
                    next.value = key;
                    next.done = false;
                    return next;
                  }
                }
                next.done = true;
                return next;
              };
            };
            function values(iterable) {
              if (iterable) {
                const iteratorMethod = iterable[iteratorSymbol];
                if (iteratorMethod) {
                  return iteratorMethod.call(iterable);
                }
                if (typeof iterable.next === 'function') {
                  return iterable;
                }
                if (!isNaN(iterable.length)) {
                  let i = -1;
                  const next = function next() {
                    while (++i < iterable.length) {
                      if (hasOwn.call(iterable, i)) {
                        next.value = iterable[i];
                        next.done = false;
                        return next;
                      }
                    }
                    next.value = undefined;
                    next.done = true;
                    return next;
                  };
                  return (next.next = next);
                }
              }
              return { next: doneResult };
            }
            runtime.values = values;
            function doneResult() {
              return { value: undefined, done: true };
            }
            Context.prototype = {
              constructor: Context,
              reset(skipTempReset) {
                this.prev = 0;
                this.next = 0;
                this.sent = this._sent = undefined;
                this.done = false;
                this.delegate = null;
                this.method = 'next';
                this.arg = undefined;
                this.tryEntries.forEach(resetTryEntry);
                if (!skipTempReset) {
                  for (const name in this) {
                    if (
                      name.charAt(0) === 't' &&
                      hasOwn.call(this, name) &&
                      !isNaN(Number(name.slice(1)))
                    ) {
                      this[name] = undefined;
                    }
                  }
                }
              },
              stop() {
                this.done = true;
                const rootEntry = this.tryEntries[0];
                const rootRecord = rootEntry.completion;
                if (rootRecord.type === 'throw') {
                  throw rootRecord.arg;
                }
                return this.rval;
              },
              dispatchException(exception) {
                if (this.done) {
                  throw exception;
                }
                const context = this;
                function handle(loc, caught) {
                  record.type = 'throw';
                  record.arg = exception;
                  context.next = loc;
                  if (caught) {
                    context.method = 'next';
                    context.arg = undefined;
                  }
                  return Boolean(caught);
                }
                for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                  const entry = this.tryEntries[i];
                  var record = entry.completion;
                  if (entry.tryLoc === 'root') {
                    return handle('end');
                  }
                  if (entry.tryLoc <= this.prev) {
                    const hasCatch = hasOwn.call(entry, 'catchLoc');
                    const hasFinally = hasOwn.call(entry, 'finallyLoc');
                    if (hasCatch && hasFinally) {
                      if (this.prev < entry.catchLoc) {
                        return handle(entry.catchLoc, true);
                      } else if (this.prev < entry.finallyLoc) {
                        return handle(entry.finallyLoc);
                      }
                    } else if (hasCatch) {
                      if (this.prev < entry.catchLoc) {
                        return handle(entry.catchLoc, true);
                      }
                    } else if (hasFinally) {
                      if (this.prev < entry.finallyLoc) {
                        return handle(entry.finallyLoc);
                      }
                    } else {
                      throw new Error('try statement without catch or finally');
                    }
                  }
                }
              },
              abrupt(type, arg) {
                for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                  const entry = this.tryEntries[i];
                  if (
                    entry.tryLoc <= this.prev &&
                    hasOwn.call(entry, 'finallyLoc') &&
                    this.prev < entry.finallyLoc
                  ) {
                    var finallyEntry = entry;
                    break;
                  }
                }
                if (
                  finallyEntry &&
                  (type === 'break' || type === 'continue') &&
                  finallyEntry.tryLoc <= arg &&
                  arg <= finallyEntry.finallyLoc
                ) {
                  finallyEntry = null;
                }
                const record = finallyEntry ? finallyEntry.completion : {};
                record.type = type;
                record.arg = arg;
                if (finallyEntry) {
                  this.method = 'next';
                  this.next = finallyEntry.finallyLoc;
                  return ContinueSentinel;
                }
                return this.complete(record);
              },
              complete(record, afterLoc) {
                if (record.type === 'throw') {
                  throw record.arg;
                }
                if (record.type === 'break' || record.type === 'continue') {
                  this.next = record.arg;
                } else if (record.type === 'return') {
                  this.rval = this.arg = record.arg;
                  this.method = 'return';
                  this.next = 'end';
                } else if (record.type === 'normal' && afterLoc) {
                  this.next = afterLoc;
                }
                return ContinueSentinel;
              },
              finish(finallyLoc) {
                for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                  const entry = this.tryEntries[i];
                  if (entry.finallyLoc === finallyLoc) {
                    this.complete(entry.completion, entry.afterLoc);
                    resetTryEntry(entry);
                    return ContinueSentinel;
                  }
                }
              },
              catch(tryLoc) {
                for (let i = this.tryEntries.length - 1; i >= 0; --i) {
                  const entry = this.tryEntries[i];
                  if (entry.tryLoc === tryLoc) {
                    const record = entry.completion;
                    if (record.type === 'throw') {
                      var thrown = record.arg;
                      resetTryEntry(entry);
                    }
                    return thrown;
                  }
                }
                throw new Error('illegal catch attempt');
              },
              delegateYield(iterable, resultName, nextLoc) {
                this.delegate = {
                  iterator: values(iterable),
                  resultName,
                  nextLoc,
                };
                if (this.method === 'next') {
                  this.arg = undefined;
                }
                return ContinueSentinel;
              },
            };
          })(
            (function () {
              return this;
            })() || Function('return this')()
          );
        },
        {},
      ],
      56: [
        function (require, module, exports) {
          const SDPUtils = require('sdp');
          function writeMediaSection(
            transceiver,
            caps,
            type,
            stream,
            dtlsRole
          ) {
            let sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);
            sdp += SDPUtils.writeIceParameters(
              transceiver.iceGatherer.getLocalParameters()
            );
            sdp += SDPUtils.writeDtlsParameters(
              transceiver.dtlsTransport.getLocalParameters(),
              type === 'offer' ? 'actpass' : dtlsRole || 'active'
            );
            sdp += `a=mid:${transceiver.mid}\r\n`;
            if (transceiver.rtpSender && transceiver.rtpReceiver) {
              sdp += 'a=sendrecv\r\n';
            } else if (transceiver.rtpSender) {
              sdp += 'a=sendonly\r\n';
            } else if (transceiver.rtpReceiver) {
              sdp += 'a=recvonly\r\n';
            } else {
              sdp += 'a=inactive\r\n';
            }
            if (transceiver.rtpSender) {
              const trackId =
                transceiver.rtpSender._initialTrackId ||
                transceiver.rtpSender.track.id;
              transceiver.rtpSender._initialTrackId = trackId;
              const msid = `msid:${stream ? stream.id : '-'} ${trackId}\r\n`;
              sdp += `a=${msid}`;
              sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc} ${msid}`;
              if (transceiver.sendEncodingParameters[0].rtx) {
                sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc} ${msid}`;
                sdp += `a=ssrc-group:FID ${transceiver.sendEncodingParameters[0].ssrc} ${transceiver.sendEncodingParameters[0].rtx.ssrc}\r\n`;
              }
            }
            sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc} cname:${SDPUtils.localCName}\r\n`;
            if (
              transceiver.rtpSender &&
              transceiver.sendEncodingParameters[0].rtx
            ) {
              sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc} cname:${SDPUtils.localCName}\r\n`;
            }
            return sdp;
          }
          function filterIceServers(iceServers, edgeVersion) {
            let hasTurn = false;
            iceServers = JSON.parse(JSON.stringify(iceServers));
            return iceServers.filter(function (server) {
              if (server && (server.urls || server.url)) {
                let urls = server.urls || server.url;
                if (server.url && !server.urls) {
                  console.warn(
                    'RTCIceServer.url is deprecated! Use urls instead.'
                  );
                }
                const isString = typeof urls === 'string';
                if (isString) {
                  urls = [urls];
                }
                urls = urls.filter(function (url) {
                  const validTurn =
                    url.indexOf('turn:') === 0 &&
                    url.indexOf('transport=udp') !== -1 &&
                    url.indexOf('turn:[') === -1 &&
                    !hasTurn;
                  if (validTurn) {
                    hasTurn = true;
                    return true;
                  }
                  return (
                    url.indexOf('stun:') === 0 &&
                    edgeVersion >= 14393 &&
                    url.indexOf('?transport=udp') === -1
                  );
                });
                delete server.url;
                server.urls = isString ? urls[0] : urls;
                return Boolean(urls.length);
              }
            });
          }
          function getCommonCapabilities(
            localCapabilities,
            remoteCapabilities
          ) {
            const commonCapabilities = {
              codecs: [],
              headerExtensions: [],
              fecMechanisms: [],
            };
            const findCodecByPayloadType = function (pt, codecs) {
              pt = parseInt(pt, 10);
              for (let i = 0; i < codecs.length; i++) {
                if (
                  codecs[i].payloadType === pt ||
                  codecs[i].preferredPayloadType === pt
                ) {
                  return codecs[i];
                }
              }
            };
            const rtxCapabilityMatches = function (
              lRtx,
              rRtx,
              lCodecs,
              rCodecs
            ) {
              const lCodec = findCodecByPayloadType(
                lRtx.parameters.apt,
                lCodecs
              );
              const rCodec = findCodecByPayloadType(
                rRtx.parameters.apt,
                rCodecs
              );
              return (
                lCodec &&
                rCodec &&
                lCodec.name.toLowerCase() === rCodec.name.toLowerCase()
              );
            };
            localCapabilities.codecs.forEach(function (lCodec) {
              for (let i = 0; i < remoteCapabilities.codecs.length; i++) {
                let rCodec = remoteCapabilities.codecs[i];
                if (
                  lCodec.name.toLowerCase() === rCodec.name.toLowerCase() &&
                  lCodec.clockRate === rCodec.clockRate
                ) {
                  if (
                    lCodec.name.toLowerCase() === 'rtx' &&
                    lCodec.parameters &&
                    rCodec.parameters.apt
                  ) {
                    if (
                      !rtxCapabilityMatches(
                        lCodec,
                        rCodec,
                        localCapabilities.codecs,
                        remoteCapabilities.codecs
                      )
                    ) {
                      continue;
                    }
                  }
                  rCodec = JSON.parse(JSON.stringify(rCodec));
                  rCodec.numChannels = Math.min(
                    lCodec.numChannels,
                    rCodec.numChannels
                  );
                  commonCapabilities.codecs.push(rCodec);
                  rCodec.rtcpFeedback = rCodec.rtcpFeedback.filter(function (
                    fb
                  ) {
                    for (let j = 0; j < lCodec.rtcpFeedback.length; j++) {
                      if (
                        lCodec.rtcpFeedback[j].type === fb.type &&
                        lCodec.rtcpFeedback[j].parameter === fb.parameter
                      ) {
                        return true;
                      }
                    }
                    return false;
                  });
                  break;
                }
              }
            });
            localCapabilities.headerExtensions.forEach(function (
              lHeaderExtension
            ) {
              for (
                let i = 0;
                i < remoteCapabilities.headerExtensions.length;
                i++
              ) {
                const rHeaderExtension = remoteCapabilities.headerExtensions[i];
                if (lHeaderExtension.uri === rHeaderExtension.uri) {
                  commonCapabilities.headerExtensions.push(rHeaderExtension);
                  break;
                }
              }
            });
            return commonCapabilities;
          }
          function isActionAllowedInSignalingState(
            action,
            type,
            signalingState
          ) {
            return (
              {
                offer: {
                  setLocalDescription: ['stable', 'have-local-offer'],
                  setRemoteDescription: ['stable', 'have-remote-offer'],
                },
                answer: {
                  setLocalDescription: [
                    'have-remote-offer',
                    'have-local-pranswer',
                  ],
                  setRemoteDescription: [
                    'have-local-offer',
                    'have-remote-pranswer',
                  ],
                },
              }[type][action].indexOf(signalingState) !== -1
            );
          }
          function maybeAddCandidate(iceTransport, candidate) {
            const alreadyAdded = iceTransport
              .getRemoteCandidates()
              .find(function (remoteCandidate) {
                return (
                  candidate.foundation === remoteCandidate.foundation &&
                  candidate.ip === remoteCandidate.ip &&
                  candidate.port === remoteCandidate.port &&
                  candidate.priority === remoteCandidate.priority &&
                  candidate.protocol === remoteCandidate.protocol &&
                  candidate.type === remoteCandidate.type
                );
              });
            if (!alreadyAdded) {
              iceTransport.addRemoteCandidate(candidate);
            }
            return !alreadyAdded;
          }
          function makeError(name, description) {
            const e = new Error(description);
            e.name = name;
            return e;
          }
          module.exports = function (window, edgeVersion) {
            function addTrackToStreamAndFireEvent(track, stream) {
              stream.addTrack(track);
              stream.dispatchEvent(
                new window.MediaStreamTrackEvent('addtrack', { track })
              );
            }
            function removeTrackFromStreamAndFireEvent(track, stream) {
              stream.removeTrack(track);
              stream.dispatchEvent(
                new window.MediaStreamTrackEvent('removetrack', {
                  track,
                })
              );
            }
            function fireAddTrack(pc, track, receiver, streams) {
              const trackEvent = new Event('track');
              trackEvent.track = track;
              trackEvent.receiver = receiver;
              trackEvent.transceiver = { receiver };
              trackEvent.streams = streams;
              window.setTimeout(function () {
                pc._dispatchEvent('track', trackEvent);
              });
            }
            const RTCPeerConnection = function (config) {
              const pc = this;
              const _eventTarget = document.createDocumentFragment();
              [
                'addEventListener',
                'removeEventListener',
                'dispatchEvent',
              ].forEach(function (method) {
                pc[method] = _eventTarget[method].bind(_eventTarget);
              });
              this.canTrickleIceCandidates = null;
              this.needNegotiation = false;
              this.localStreams = [];
              this.remoteStreams = [];
              this.localDescription = null;
              this.remoteDescription = null;
              this.signalingState = 'stable';
              this.iceConnectionState = 'new';
              this.iceGatheringState = 'new';
              config = JSON.parse(JSON.stringify(config || {}));
              this.usingBundle = config.bundlePolicy === 'max-bundle';
              if (config.rtcpMuxPolicy === 'negotiate') {
                throw makeError(
                  'NotSupportedError',
                  "rtcpMuxPolicy 'negotiate' is not supported"
                );
              } else if (!config.rtcpMuxPolicy) {
                config.rtcpMuxPolicy = 'require';
              }
              switch (config.iceTransportPolicy) {
                case 'all':
                case 'relay':
                  break;
                default:
                  config.iceTransportPolicy = 'all';
                  break;
              }
              switch (config.bundlePolicy) {
                case 'balanced':
                case 'max-compat':
                case 'max-bundle':
                  break;
                default:
                  config.bundlePolicy = 'balanced';
                  break;
              }
              config.iceServers = filterIceServers(
                config.iceServers || [],
                edgeVersion
              );
              this._iceGatherers = [];
              if (config.iceCandidatePoolSize) {
                for (let i = config.iceCandidatePoolSize; i > 0; i--) {
                  this._iceGatherers.push(
                    new window.RTCIceGatherer({
                      iceServers: config.iceServers,
                      gatherPolicy: config.iceTransportPolicy,
                    })
                  );
                }
              } else {
                config.iceCandidatePoolSize = 0;
              }
              this._config = config;
              this.transceivers = [];
              this._sdpSessionId = SDPUtils.generateSessionId();
              this._sdpSessionVersion = 0;
              this._dtlsRole = undefined;
              this._isClosed = false;
            };
            RTCPeerConnection.prototype.onicecandidate = null;
            RTCPeerConnection.prototype.onaddstream = null;
            RTCPeerConnection.prototype.ontrack = null;
            RTCPeerConnection.prototype.onremovestream = null;
            RTCPeerConnection.prototype.onsignalingstatechange = null;
            RTCPeerConnection.prototype.oniceconnectionstatechange = null;
            RTCPeerConnection.prototype.onicegatheringstatechange = null;
            RTCPeerConnection.prototype.onnegotiationneeded = null;
            RTCPeerConnection.prototype.ondatachannel = null;
            RTCPeerConnection.prototype._dispatchEvent = function (
              name,
              event
            ) {
              if (this._isClosed) {
                return;
              }
              this.dispatchEvent(event);
              if (typeof this[`on${name}`] === 'function') {
                this[`on${name}`](event);
              }
            };
            RTCPeerConnection.prototype._emitGatheringStateChange =
              function () {
                const event = new Event('icegatheringstatechange');
                this._dispatchEvent('icegatheringstatechange', event);
              };
            RTCPeerConnection.prototype.getConfiguration = function () {
              return this._config;
            };
            RTCPeerConnection.prototype.getLocalStreams = function () {
              return this.localStreams;
            };
            RTCPeerConnection.prototype.getRemoteStreams = function () {
              return this.remoteStreams;
            };
            RTCPeerConnection.prototype._createTransceiver = function (kind) {
              const hasBundleTransport = this.transceivers.length > 0;
              const transceiver = {
                track: null,
                iceGatherer: null,
                iceTransport: null,
                dtlsTransport: null,
                localCapabilities: null,
                remoteCapabilities: null,
                rtpSender: null,
                rtpReceiver: null,
                kind,
                mid: null,
                sendEncodingParameters: null,
                recvEncodingParameters: null,
                stream: null,
                associatedRemoteMediaStreams: [],
                wantReceive: true,
              };
              if (this.usingBundle && hasBundleTransport) {
                transceiver.iceTransport = this.transceivers[0].iceTransport;
                transceiver.dtlsTransport = this.transceivers[0].dtlsTransport;
              } else {
                const transports = this._createIceAndDtlsTransports();
                transceiver.iceTransport = transports.iceTransport;
                transceiver.dtlsTransport = transports.dtlsTransport;
              }
              this.transceivers.push(transceiver);
              return transceiver;
            };
            RTCPeerConnection.prototype.addTrack = function (track, stream) {
              if (this._isClosed) {
                throw makeError(
                  'InvalidStateError',
                  'Attempted to call addTrack on a closed peerconnection.'
                );
              }
              const alreadyExists = this.transceivers.find(function (s) {
                return s.track === track;
              });
              if (alreadyExists) {
                throw makeError('InvalidAccessError', 'Track already exists.');
              }
              let transceiver;
              for (let i = 0; i < this.transceivers.length; i++) {
                if (
                  !this.transceivers[i].track &&
                  this.transceivers[i].kind === track.kind
                ) {
                  transceiver = this.transceivers[i];
                }
              }
              if (!transceiver) {
                transceiver = this._createTransceiver(track.kind);
              }
              this._maybeFireNegotiationNeeded();
              if (this.localStreams.indexOf(stream) === -1) {
                this.localStreams.push(stream);
              }
              transceiver.track = track;
              transceiver.stream = stream;
              transceiver.rtpSender = new window.RTCRtpSender(
                track,
                transceiver.dtlsTransport
              );
              return transceiver.rtpSender;
            };
            RTCPeerConnection.prototype.addStream = function (stream) {
              const pc = this;
              if (edgeVersion >= 15025) {
                stream.getTracks().forEach(function (track) {
                  pc.addTrack(track, stream);
                });
              } else {
                const clonedStream = stream.clone();
                stream.getTracks().forEach(function (track, idx) {
                  const clonedTrack = clonedStream.getTracks()[idx];
                  track.addEventListener('enabled', function (event) {
                    clonedTrack.enabled = event.enabled;
                  });
                });
                clonedStream.getTracks().forEach(function (track) {
                  pc.addTrack(track, clonedStream);
                });
              }
            };
            RTCPeerConnection.prototype.removeTrack = function (sender) {
              if (this._isClosed) {
                throw makeError(
                  'InvalidStateError',
                  'Attempted to call removeTrack on a closed peerconnection.'
                );
              }
              if (!(sender instanceof window.RTCRtpSender)) {
                throw new TypeError(
                  'Argument 1 of RTCPeerConnection.removeTrack ' +
                    'does not implement interface RTCRtpSender.'
                );
              }
              const transceiver = this.transceivers.find(function (t) {
                return t.rtpSender === sender;
              });
              if (!transceiver) {
                throw makeError(
                  'InvalidAccessError',
                  'Sender was not created by this connection.'
                );
              }
              const { stream } = transceiver;
              transceiver.rtpSender.stop();
              transceiver.rtpSender = null;
              transceiver.track = null;
              transceiver.stream = null;
              const localStreams = this.transceivers.map(function (t) {
                return t.stream;
              });
              if (
                localStreams.indexOf(stream) === -1 &&
                this.localStreams.indexOf(stream) > -1
              ) {
                this.localStreams.splice(this.localStreams.indexOf(stream), 1);
              }
              this._maybeFireNegotiationNeeded();
            };
            RTCPeerConnection.prototype.removeStream = function (stream) {
              const pc = this;
              stream.getTracks().forEach(function (track) {
                const sender = pc.getSenders().find(function (s) {
                  return s.track === track;
                });
                if (sender) {
                  pc.removeTrack(sender);
                }
              });
            };
            RTCPeerConnection.prototype.getSenders = function () {
              return this.transceivers
                .filter(function (transceiver) {
                  return Boolean(transceiver.rtpSender);
                })
                .map(function (transceiver) {
                  return transceiver.rtpSender;
                });
            };
            RTCPeerConnection.prototype.getReceivers = function () {
              return this.transceivers
                .filter(function (transceiver) {
                  return Boolean(transceiver.rtpReceiver);
                })
                .map(function (transceiver) {
                  return transceiver.rtpReceiver;
                });
            };
            RTCPeerConnection.prototype._createIceGatherer = function (
              sdpMLineIndex,
              usingBundle
            ) {
              const pc = this;
              if (usingBundle && sdpMLineIndex > 0) {
                return this.transceivers[0].iceGatherer;
              } else if (this._iceGatherers.length) {
                return this._iceGatherers.shift();
              }
              const iceGatherer = new window.RTCIceGatherer({
                iceServers: this._config.iceServers,
                gatherPolicy: this._config.iceTransportPolicy,
              });
              Object.defineProperty(iceGatherer, 'state', {
                value: 'new',
                writable: true,
              });
              this.transceivers[sdpMLineIndex].bufferedCandidateEvents = [];
              this.transceivers[sdpMLineIndex].bufferCandidates = function (
                event
              ) {
                const end =
                  !event.candidate || Object.keys(event.candidate).length === 0;
                iceGatherer.state = end ? 'completed' : 'gathering';
                if (
                  pc.transceivers[sdpMLineIndex].bufferedCandidateEvents !==
                  null
                ) {
                  pc.transceivers[sdpMLineIndex].bufferedCandidateEvents.push(
                    event
                  );
                }
              };
              iceGatherer.addEventListener(
                'localcandidate',
                this.transceivers[sdpMLineIndex].bufferCandidates
              );
              return iceGatherer;
            };
            RTCPeerConnection.prototype._gather = function (
              mid,
              sdpMLineIndex
            ) {
              const pc = this;
              const { iceGatherer } = this.transceivers[sdpMLineIndex];
              if (iceGatherer.onlocalcandidate) {
                return;
              }
              const { bufferedCandidateEvents } =
                this.transceivers[sdpMLineIndex];
              this.transceivers[sdpMLineIndex].bufferedCandidateEvents = null;
              iceGatherer.removeEventListener(
                'localcandidate',
                this.transceivers[sdpMLineIndex].bufferCandidates
              );
              iceGatherer.onlocalcandidate = function (evt) {
                if (pc.usingBundle && sdpMLineIndex > 0) {
                  return;
                }
                const event = new Event('icecandidate');
                event.candidate = { sdpMid: mid, sdpMLineIndex };
                const cand = evt.candidate;
                const end = !cand || Object.keys(cand).length === 0;
                if (end) {
                  if (
                    iceGatherer.state === 'new' ||
                    iceGatherer.state === 'gathering'
                  ) {
                    iceGatherer.state = 'completed';
                  }
                } else {
                  if (iceGatherer.state === 'new') {
                    iceGatherer.state = 'gathering';
                  }
                  cand.component = 1;
                  const serializedCandidate = SDPUtils.writeCandidate(cand);
                  event.candidate = Object.assign(
                    event.candidate,
                    SDPUtils.parseCandidate(serializedCandidate)
                  );
                  event.candidate.candidate = serializedCandidate;
                }
                const sections = SDPUtils.getMediaSections(
                  pc.localDescription.sdp
                );
                if (!end) {
                  sections[
                    event.candidate.sdpMLineIndex
                  ] += `a=${event.candidate.candidate}\r\n`;
                } else {
                  sections[event.candidate.sdpMLineIndex] +=
                    'a=end-of-candidates\r\n';
                }
                pc.localDescription.sdp =
                  SDPUtils.getDescription(pc.localDescription.sdp) +
                  sections.join('');
                const complete = pc.transceivers.every(function (transceiver) {
                  return (
                    transceiver.iceGatherer &&
                    transceiver.iceGatherer.state === 'completed'
                  );
                });
                if (pc.iceGatheringState !== 'gathering') {
                  pc.iceGatheringState = 'gathering';
                  pc._emitGatheringStateChange();
                }
                if (!end) {
                  pc._dispatchEvent('icecandidate', event);
                }
                if (complete) {
                  pc._dispatchEvent('icecandidate', new Event('icecandidate'));
                  pc.iceGatheringState = 'complete';
                  pc._emitGatheringStateChange();
                }
              };
              window.setTimeout(function () {
                bufferedCandidateEvents.forEach(function (e) {
                  iceGatherer.onlocalcandidate(e);
                });
              }, 0);
            };
            RTCPeerConnection.prototype._createIceAndDtlsTransports =
              function () {
                const pc = this;
                const iceTransport = new window.RTCIceTransport(null);
                iceTransport.onicestatechange = function () {
                  pc._updateConnectionState();
                };
                const dtlsTransport = new window.RTCDtlsTransport(iceTransport);
                dtlsTransport.ondtlsstatechange = function () {
                  pc._updateConnectionState();
                };
                dtlsTransport.onerror = function () {
                  Object.defineProperty(dtlsTransport, 'state', {
                    value: 'failed',
                    writable: true,
                  });
                  pc._updateConnectionState();
                };
                return {
                  iceTransport,
                  dtlsTransport,
                };
              };
            RTCPeerConnection.prototype._disposeIceAndDtlsTransports =
              function (sdpMLineIndex) {
                const { iceGatherer } = this.transceivers[sdpMLineIndex];
                if (iceGatherer) {
                  delete iceGatherer.onlocalcandidate;
                  delete this.transceivers[sdpMLineIndex].iceGatherer;
                }
                const { iceTransport } = this.transceivers[sdpMLineIndex];
                if (iceTransport) {
                  delete iceTransport.onicestatechange;
                  delete this.transceivers[sdpMLineIndex].iceTransport;
                }
                const { dtlsTransport } = this.transceivers[sdpMLineIndex];
                if (dtlsTransport) {
                  delete dtlsTransport.ondtlsstatechange;
                  delete dtlsTransport.onerror;
                  delete this.transceivers[sdpMLineIndex].dtlsTransport;
                }
              };
            RTCPeerConnection.prototype._transceive = function (
              transceiver,
              send,
              recv
            ) {
              const params = getCommonCapabilities(
                transceiver.localCapabilities,
                transceiver.remoteCapabilities
              );
              if (send && transceiver.rtpSender) {
                params.encodings = transceiver.sendEncodingParameters;
                params.rtcp = {
                  cname: SDPUtils.localCName,
                  compound: transceiver.rtcpParameters.compound,
                };
                if (transceiver.recvEncodingParameters.length) {
                  params.rtcp.ssrc = transceiver.recvEncodingParameters[0].ssrc;
                }
                transceiver.rtpSender.send(params);
              }
              if (recv && transceiver.rtpReceiver && params.codecs.length > 0) {
                if (
                  transceiver.kind === 'video' &&
                  transceiver.recvEncodingParameters &&
                  edgeVersion < 15019
                ) {
                  transceiver.recvEncodingParameters.forEach(function (p) {
                    delete p.rtx;
                  });
                }
                if (transceiver.recvEncodingParameters.length) {
                  params.encodings = transceiver.recvEncodingParameters;
                } else {
                  params.encodings = [{}];
                }
                params.rtcp = { compound: transceiver.rtcpParameters.compound };
                if (transceiver.rtcpParameters.cname) {
                  params.rtcp.cname = transceiver.rtcpParameters.cname;
                }
                if (transceiver.sendEncodingParameters.length) {
                  params.rtcp.ssrc = transceiver.sendEncodingParameters[0].ssrc;
                }
                transceiver.rtpReceiver.receive(params);
              }
            };
            RTCPeerConnection.prototype.setLocalDescription = function (
              description
            ) {
              const pc = this;
              if (['offer', 'answer'].indexOf(description.type) === -1) {
                return Promise.reject(
                  makeError(
                    'TypeError',
                    `Unsupported type "${description.type}"`
                  )
                );
              }
              if (
                !isActionAllowedInSignalingState(
                  'setLocalDescription',
                  description.type,
                  pc.signalingState
                ) ||
                pc._isClosed
              ) {
                return Promise.reject(
                  makeError(
                    'InvalidStateError',
                    `Can not set local ${description.type} in state ${pc.signalingState}`
                  )
                );
              }
              let sections;
              let sessionpart;
              if (description.type === 'offer') {
                sections = SDPUtils.splitSections(description.sdp);
                sessionpart = sections.shift();
                sections.forEach(function (mediaSection, sdpMLineIndex) {
                  const caps = SDPUtils.parseRtpParameters(mediaSection);
                  pc.transceivers[sdpMLineIndex].localCapabilities = caps;
                });
                pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                  pc._gather(transceiver.mid, sdpMLineIndex);
                });
              } else if (description.type === 'answer') {
                sections = SDPUtils.splitSections(pc.remoteDescription.sdp);
                sessionpart = sections.shift();
                const isIceLite =
                  SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
                sections.forEach(function (mediaSection, sdpMLineIndex) {
                  const transceiver = pc.transceivers[sdpMLineIndex];
                  const { iceGatherer } = transceiver;
                  const { iceTransport } = transceiver;
                  const { dtlsTransport } = transceiver;
                  const { localCapabilities } = transceiver;
                  const { remoteCapabilities } = transceiver;
                  const rejected =
                    SDPUtils.isRejected(mediaSection) &&
                    SDPUtils.matchPrefix(mediaSection, 'a=bundle-only')
                      .length === 0;
                  if (!rejected && !transceiver.isDatachannel) {
                    const remoteIceParameters = SDPUtils.getIceParameters(
                      mediaSection,
                      sessionpart
                    );
                    const remoteDtlsParameters = SDPUtils.getDtlsParameters(
                      mediaSection,
                      sessionpart
                    );
                    if (isIceLite) {
                      remoteDtlsParameters.role = 'server';
                    }
                    if (!pc.usingBundle || sdpMLineIndex === 0) {
                      pc._gather(transceiver.mid, sdpMLineIndex);
                      if (iceTransport.state === 'new') {
                        iceTransport.start(
                          iceGatherer,
                          remoteIceParameters,
                          isIceLite ? 'controlling' : 'controlled'
                        );
                      }
                      if (dtlsTransport.state === 'new') {
                        dtlsTransport.start(remoteDtlsParameters);
                      }
                    }
                    const params = getCommonCapabilities(
                      localCapabilities,
                      remoteCapabilities
                    );
                    pc._transceive(
                      transceiver,
                      params.codecs.length > 0,
                      false
                    );
                  }
                });
              }
              pc.localDescription = {
                type: description.type,
                sdp: description.sdp,
              };
              if (description.type === 'offer') {
                pc._updateSignalingState('have-local-offer');
              } else {
                pc._updateSignalingState('stable');
              }
              return Promise.resolve();
            };
            RTCPeerConnection.prototype.setRemoteDescription = function (
              description
            ) {
              const pc = this;
              if (['offer', 'answer'].indexOf(description.type) === -1) {
                return Promise.reject(
                  makeError(
                    'TypeError',
                    `Unsupported type "${description.type}"`
                  )
                );
              }
              if (
                !isActionAllowedInSignalingState(
                  'setRemoteDescription',
                  description.type,
                  pc.signalingState
                ) ||
                pc._isClosed
              ) {
                return Promise.reject(
                  makeError(
                    'InvalidStateError',
                    `Can not set remote ${description.type} in state ${pc.signalingState}`
                  )
                );
              }
              const streams = {};
              pc.remoteStreams.forEach(function (stream) {
                streams[stream.id] = stream;
              });
              const receiverList = [];
              const sections = SDPUtils.splitSections(description.sdp);
              const sessionpart = sections.shift();
              const isIceLite =
                SDPUtils.matchPrefix(sessionpart, 'a=ice-lite').length > 0;
              const usingBundle =
                SDPUtils.matchPrefix(sessionpart, 'a=group:BUNDLE ').length > 0;
              pc.usingBundle = usingBundle;
              const iceOptions = SDPUtils.matchPrefix(
                sessionpart,
                'a=ice-options:'
              )[0];
              if (iceOptions) {
                pc.canTrickleIceCandidates =
                  iceOptions.substr(14).split(' ').indexOf('trickle') >= 0;
              } else {
                pc.canTrickleIceCandidates = false;
              }
              sections.forEach(function (mediaSection, sdpMLineIndex) {
                const lines = SDPUtils.splitLines(mediaSection);
                const kind = SDPUtils.getKind(mediaSection);
                const rejected =
                  SDPUtils.isRejected(mediaSection) &&
                  SDPUtils.matchPrefix(mediaSection, 'a=bundle-only').length ===
                    0;
                const protocol = lines[0].substr(2).split(' ')[2];
                const direction = SDPUtils.getDirection(
                  mediaSection,
                  sessionpart
                );
                const remoteMsid = SDPUtils.parseMsid(mediaSection);
                const mid =
                  SDPUtils.getMid(mediaSection) ||
                  SDPUtils.generateIdentifier();
                if (kind === 'application' && protocol === 'DTLS/SCTP') {
                  pc.transceivers[sdpMLineIndex] = {
                    mid,
                    isDatachannel: true,
                  };
                  return;
                }
                let transceiver;
                let iceGatherer;
                let iceTransport;
                let dtlsTransport;
                let rtpReceiver;
                let sendEncodingParameters;
                let recvEncodingParameters;
                let localCapabilities;
                let track;
                const remoteCapabilities =
                  SDPUtils.parseRtpParameters(mediaSection);
                let remoteIceParameters;
                let remoteDtlsParameters;
                if (!rejected) {
                  remoteIceParameters = SDPUtils.getIceParameters(
                    mediaSection,
                    sessionpart
                  );
                  remoteDtlsParameters = SDPUtils.getDtlsParameters(
                    mediaSection,
                    sessionpart
                  );
                  remoteDtlsParameters.role = 'client';
                }
                recvEncodingParameters =
                  SDPUtils.parseRtpEncodingParameters(mediaSection);
                const rtcpParameters =
                  SDPUtils.parseRtcpParameters(mediaSection);
                const isComplete =
                  SDPUtils.matchPrefix(
                    mediaSection,
                    'a=end-of-candidates',
                    sessionpart
                  ).length > 0;
                const cands = SDPUtils.matchPrefix(mediaSection, 'a=candidate:')
                  .map(function (cand) {
                    return SDPUtils.parseCandidate(cand);
                  })
                  .filter(function (cand) {
                    return cand.component === 1;
                  });
                if (
                  (description.type === 'offer' ||
                    description.type === 'answer') &&
                  !rejected &&
                  usingBundle &&
                  sdpMLineIndex > 0 &&
                  pc.transceivers[sdpMLineIndex]
                ) {
                  pc._disposeIceAndDtlsTransports(sdpMLineIndex);
                  pc.transceivers[sdpMLineIndex].iceGatherer =
                    pc.transceivers[0].iceGatherer;
                  pc.transceivers[sdpMLineIndex].iceTransport =
                    pc.transceivers[0].iceTransport;
                  pc.transceivers[sdpMLineIndex].dtlsTransport =
                    pc.transceivers[0].dtlsTransport;
                  if (pc.transceivers[sdpMLineIndex].rtpSender) {
                    pc.transceivers[sdpMLineIndex].rtpSender.setTransport(
                      pc.transceivers[0].dtlsTransport
                    );
                  }
                  if (pc.transceivers[sdpMLineIndex].rtpReceiver) {
                    pc.transceivers[sdpMLineIndex].rtpReceiver.setTransport(
                      pc.transceivers[0].dtlsTransport
                    );
                  }
                }
                if (description.type === 'offer' && !rejected) {
                  transceiver =
                    pc.transceivers[sdpMLineIndex] ||
                    pc._createTransceiver(kind);
                  transceiver.mid = mid;
                  if (!transceiver.iceGatherer) {
                    transceiver.iceGatherer = pc._createIceGatherer(
                      sdpMLineIndex,
                      usingBundle
                    );
                  }
                  if (
                    cands.length &&
                    transceiver.iceTransport.state === 'new'
                  ) {
                    if (isComplete && (!usingBundle || sdpMLineIndex === 0)) {
                      transceiver.iceTransport.setRemoteCandidates(cands);
                    } else {
                      cands.forEach(function (candidate) {
                        maybeAddCandidate(transceiver.iceTransport, candidate);
                      });
                    }
                  }
                  localCapabilities =
                    window.RTCRtpReceiver.getCapabilities(kind);
                  if (edgeVersion < 15019) {
                    localCapabilities.codecs = localCapabilities.codecs.filter(
                      function (codec) {
                        return codec.name !== 'rtx';
                      }
                    );
                  }
                  sendEncodingParameters =
                    transceiver.sendEncodingParameters || [
                      { ssrc: (2 * sdpMLineIndex + 2) * 1001 },
                    ];
                  let isNewTrack = false;
                  if (direction === 'sendrecv' || direction === 'sendonly') {
                    isNewTrack = !transceiver.rtpReceiver;
                    rtpReceiver =
                      transceiver.rtpReceiver ||
                      new window.RTCRtpReceiver(
                        transceiver.dtlsTransport,
                        kind
                      );
                    if (isNewTrack) {
                      let stream;
                      track = rtpReceiver.track;
                      if (remoteMsid && remoteMsid.stream === '-') {
                      } else if (remoteMsid) {
                        if (!streams[remoteMsid.stream]) {
                          streams[remoteMsid.stream] = new window.MediaStream();
                          Object.defineProperty(
                            streams[remoteMsid.stream],
                            'id',
                            {
                              get() {
                                return remoteMsid.stream;
                              },
                            }
                          );
                        }
                        Object.defineProperty(track, 'id', {
                          get() {
                            return remoteMsid.track;
                          },
                        });
                        stream = streams[remoteMsid.stream];
                      } else {
                        if (!streams.default) {
                          streams.default = new window.MediaStream();
                        }
                        stream = streams.default;
                      }
                      if (stream) {
                        addTrackToStreamAndFireEvent(track, stream);
                        transceiver.associatedRemoteMediaStreams.push(stream);
                      }
                      receiverList.push([track, rtpReceiver, stream]);
                    }
                  } else if (
                    transceiver.rtpReceiver &&
                    transceiver.rtpReceiver.track
                  ) {
                    transceiver.associatedRemoteMediaStreams.forEach(function (
                      s
                    ) {
                      const nativeTrack = s.getTracks().find(function (t) {
                        return t.id === transceiver.rtpReceiver.track.id;
                      });
                      if (nativeTrack) {
                        removeTrackFromStreamAndFireEvent(nativeTrack, s);
                      }
                    });
                    transceiver.associatedRemoteMediaStreams = [];
                  }
                  transceiver.localCapabilities = localCapabilities;
                  transceiver.remoteCapabilities = remoteCapabilities;
                  transceiver.rtpReceiver = rtpReceiver;
                  transceiver.rtcpParameters = rtcpParameters;
                  transceiver.sendEncodingParameters = sendEncodingParameters;
                  transceiver.recvEncodingParameters = recvEncodingParameters;
                  pc._transceive(
                    pc.transceivers[sdpMLineIndex],
                    false,
                    isNewTrack
                  );
                } else if (description.type === 'answer' && !rejected) {
                  transceiver = pc.transceivers[sdpMLineIndex];
                  iceGatherer = transceiver.iceGatherer;
                  iceTransport = transceiver.iceTransport;
                  dtlsTransport = transceiver.dtlsTransport;
                  rtpReceiver = transceiver.rtpReceiver;
                  sendEncodingParameters = transceiver.sendEncodingParameters;
                  localCapabilities = transceiver.localCapabilities;
                  pc.transceivers[sdpMLineIndex].recvEncodingParameters =
                    recvEncodingParameters;
                  pc.transceivers[sdpMLineIndex].remoteCapabilities =
                    remoteCapabilities;
                  pc.transceivers[sdpMLineIndex].rtcpParameters =
                    rtcpParameters;
                  if (cands.length && iceTransport.state === 'new') {
                    if (
                      (isIceLite || isComplete) &&
                      (!usingBundle || sdpMLineIndex === 0)
                    ) {
                      iceTransport.setRemoteCandidates(cands);
                    } else {
                      cands.forEach(function (candidate) {
                        maybeAddCandidate(transceiver.iceTransport, candidate);
                      });
                    }
                  }
                  if (!usingBundle || sdpMLineIndex === 0) {
                    if (iceTransport.state === 'new') {
                      iceTransport.start(
                        iceGatherer,
                        remoteIceParameters,
                        'controlling'
                      );
                    }
                    if (dtlsTransport.state === 'new') {
                      dtlsTransport.start(remoteDtlsParameters);
                    }
                  }
                  pc._transceive(
                    transceiver,
                    direction === 'sendrecv' || direction === 'recvonly',
                    direction === 'sendrecv' || direction === 'sendonly'
                  );
                  if (
                    rtpReceiver &&
                    (direction === 'sendrecv' || direction === 'sendonly')
                  ) {
                    track = rtpReceiver.track;
                    if (remoteMsid) {
                      if (!streams[remoteMsid.stream]) {
                        streams[remoteMsid.stream] = new window.MediaStream();
                      }
                      addTrackToStreamAndFireEvent(
                        track,
                        streams[remoteMsid.stream]
                      );
                      receiverList.push([
                        track,
                        rtpReceiver,
                        streams[remoteMsid.stream],
                      ]);
                    } else {
                      if (!streams.default) {
                        streams.default = new window.MediaStream();
                      }
                      addTrackToStreamAndFireEvent(track, streams.default);
                      receiverList.push([track, rtpReceiver, streams.default]);
                    }
                  } else {
                    delete transceiver.rtpReceiver;
                  }
                }
              });
              if (pc._dtlsRole === undefined) {
                pc._dtlsRole =
                  description.type === 'offer' ? 'active' : 'passive';
              }
              pc.remoteDescription = {
                type: description.type,
                sdp: description.sdp,
              };
              if (description.type === 'offer') {
                pc._updateSignalingState('have-remote-offer');
              } else {
                pc._updateSignalingState('stable');
              }
              Object.keys(streams).forEach(function (sid) {
                const stream = streams[sid];
                if (stream.getTracks().length) {
                  if (pc.remoteStreams.indexOf(stream) === -1) {
                    pc.remoteStreams.push(stream);
                    const event = new Event('addstream');
                    event.stream = stream;
                    window.setTimeout(function () {
                      pc._dispatchEvent('addstream', event);
                    });
                  }
                  receiverList.forEach(function (item) {
                    const track = item[0];
                    const receiver = item[1];
                    if (stream.id !== item[2].id) {
                      return;
                    }
                    fireAddTrack(pc, track, receiver, [stream]);
                  });
                }
              });
              receiverList.forEach(function (item) {
                if (item[2]) {
                  return;
                }
                fireAddTrack(pc, item[0], item[1], []);
              });
              window.setTimeout(function () {
                if (!(pc && pc.transceivers)) {
                  return;
                }
                pc.transceivers.forEach(function (transceiver) {
                  if (
                    transceiver.iceTransport &&
                    transceiver.iceTransport.state === 'new' &&
                    transceiver.iceTransport.getRemoteCandidates().length > 0
                  ) {
                    console.warn(
                      'Timeout for addRemoteCandidate. Consider sending ' +
                        'an end-of-candidates notification'
                    );
                    transceiver.iceTransport.addRemoteCandidate({});
                  }
                });
              }, 4e3);
              return Promise.resolve();
            };
            RTCPeerConnection.prototype.close = function () {
              this.transceivers.forEach(function (transceiver) {
                if (transceiver.iceTransport) {
                  transceiver.iceTransport.stop();
                }
                if (transceiver.dtlsTransport) {
                  transceiver.dtlsTransport.stop();
                }
                if (transceiver.rtpSender) {
                  transceiver.rtpSender.stop();
                }
                if (transceiver.rtpReceiver) {
                  transceiver.rtpReceiver.stop();
                }
              });
              this._isClosed = true;
              this._updateSignalingState('closed');
            };
            RTCPeerConnection.prototype._updateSignalingState = function (
              newState
            ) {
              this.signalingState = newState;
              const event = new Event('signalingstatechange');
              this._dispatchEvent('signalingstatechange', event);
            };
            RTCPeerConnection.prototype._maybeFireNegotiationNeeded =
              function () {
                const pc = this;
                if (
                  this.signalingState !== 'stable' ||
                  this.needNegotiation === true
                ) {
                  return;
                }
                this.needNegotiation = true;
                window.setTimeout(function () {
                  if (pc.needNegotiation) {
                    pc.needNegotiation = false;
                    const event = new Event('negotiationneeded');
                    pc._dispatchEvent('negotiationneeded', event);
                  }
                }, 0);
              };
            RTCPeerConnection.prototype._updateConnectionState = function () {
              let newState;
              const states = {
                new: 0,
                closed: 0,
                connecting: 0,
                checking: 0,
                connected: 0,
                completed: 0,
                disconnected: 0,
                failed: 0,
              };
              this.transceivers.forEach(function (transceiver) {
                states[transceiver.iceTransport.state]++;
                states[transceiver.dtlsTransport.state]++;
              });
              states.connected += states.completed;
              newState = 'new';
              if (states.failed > 0) {
                newState = 'failed';
              } else if (states.connecting > 0 || states.checking > 0) {
                newState = 'connecting';
              } else if (states.disconnected > 0) {
                newState = 'disconnected';
              } else if (states.new > 0) {
                newState = 'new';
              } else if (states.connected > 0 || states.completed > 0) {
                newState = 'connected';
              }
              if (newState !== this.iceConnectionState) {
                this.iceConnectionState = newState;
                const event = new Event('iceconnectionstatechange');
                this._dispatchEvent('iceconnectionstatechange', event);
              }
            };
            RTCPeerConnection.prototype.createOffer = function () {
              const pc = this;
              if (pc._isClosed) {
                return Promise.reject(
                  makeError(
                    'InvalidStateError',
                    'Can not call createOffer after close'
                  )
                );
              }
              let numAudioTracks = pc.transceivers.filter(function (t) {
                return t.kind === 'audio';
              }).length;
              let numVideoTracks = pc.transceivers.filter(function (t) {
                return t.kind === 'video';
              }).length;
              const offerOptions = arguments[0];
              if (offerOptions) {
                if (offerOptions.mandatory || offerOptions.optional) {
                  throw new TypeError(
                    'Legacy mandatory/optional constraints not supported.'
                  );
                }
                if (offerOptions.offerToReceiveAudio !== undefined) {
                  if (offerOptions.offerToReceiveAudio === true) {
                    numAudioTracks = 1;
                  } else if (offerOptions.offerToReceiveAudio === false) {
                    numAudioTracks = 0;
                  } else {
                    numAudioTracks = offerOptions.offerToReceiveAudio;
                  }
                }
                if (offerOptions.offerToReceiveVideo !== undefined) {
                  if (offerOptions.offerToReceiveVideo === true) {
                    numVideoTracks = 1;
                  } else if (offerOptions.offerToReceiveVideo === false) {
                    numVideoTracks = 0;
                  } else {
                    numVideoTracks = offerOptions.offerToReceiveVideo;
                  }
                }
              }
              pc.transceivers.forEach(function (transceiver) {
                if (transceiver.kind === 'audio') {
                  numAudioTracks--;
                  if (numAudioTracks < 0) {
                    transceiver.wantReceive = false;
                  }
                } else if (transceiver.kind === 'video') {
                  numVideoTracks--;
                  if (numVideoTracks < 0) {
                    transceiver.wantReceive = false;
                  }
                }
              });
              while (numAudioTracks > 0 || numVideoTracks > 0) {
                if (numAudioTracks > 0) {
                  pc._createTransceiver('audio');
                  numAudioTracks--;
                }
                if (numVideoTracks > 0) {
                  pc._createTransceiver('video');
                  numVideoTracks--;
                }
              }
              let sdp = SDPUtils.writeSessionBoilerplate(
                pc._sdpSessionId,
                pc._sdpSessionVersion++
              );
              pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                const { track } = transceiver;
                const { kind } = transceiver;
                const mid = transceiver.mid || SDPUtils.generateIdentifier();
                transceiver.mid = mid;
                if (!transceiver.iceGatherer) {
                  transceiver.iceGatherer = pc._createIceGatherer(
                    sdpMLineIndex,
                    pc.usingBundle
                  );
                }
                const localCapabilities =
                  window.RTCRtpSender.getCapabilities(kind);
                if (edgeVersion < 15019) {
                  localCapabilities.codecs = localCapabilities.codecs.filter(
                    function (codec) {
                      return codec.name !== 'rtx';
                    }
                  );
                }
                localCapabilities.codecs.forEach(function (codec) {
                  if (
                    codec.name === 'H264' &&
                    codec.parameters['level-asymmetry-allowed'] === undefined
                  ) {
                    codec.parameters['level-asymmetry-allowed'] = '1';
                  }
                  if (
                    transceiver.remoteCapabilities &&
                    transceiver.remoteCapabilities.codecs
                  ) {
                    transceiver.remoteCapabilities.codecs.forEach(function (
                      remoteCodec
                    ) {
                      if (
                        codec.name.toLowerCase() ===
                          remoteCodec.name.toLowerCase() &&
                        codec.clockRate === remoteCodec.clockRate
                      ) {
                        codec.preferredPayloadType = remoteCodec.payloadType;
                      }
                    });
                  }
                });
                localCapabilities.headerExtensions.forEach(function (hdrExt) {
                  const remoteExtensions =
                    (transceiver.remoteCapabilities &&
                      transceiver.remoteCapabilities.headerExtensions) ||
                    [];
                  remoteExtensions.forEach(function (rHdrExt) {
                    if (hdrExt.uri === rHdrExt.uri) {
                      hdrExt.id = rHdrExt.id;
                    }
                  });
                });
                const sendEncodingParameters =
                  transceiver.sendEncodingParameters || [
                    { ssrc: (2 * sdpMLineIndex + 1) * 1001 },
                  ];
                if (track) {
                  if (
                    edgeVersion >= 15019 &&
                    kind === 'video' &&
                    !sendEncodingParameters[0].rtx
                  ) {
                    sendEncodingParameters[0].rtx = {
                      ssrc: sendEncodingParameters[0].ssrc + 1,
                    };
                  }
                }
                if (transceiver.wantReceive) {
                  transceiver.rtpReceiver = new window.RTCRtpReceiver(
                    transceiver.dtlsTransport,
                    kind
                  );
                }
                transceiver.localCapabilities = localCapabilities;
                transceiver.sendEncodingParameters = sendEncodingParameters;
              });
              if (pc._config.bundlePolicy !== 'max-compat') {
                sdp += `a=group:BUNDLE ${pc.transceivers
                  .map(function (t) {
                    return t.mid;
                  })
                  .join(' ')}\r\n`;
              }
              sdp += 'a=ice-options:trickle\r\n';
              pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                sdp += writeMediaSection(
                  transceiver,
                  transceiver.localCapabilities,
                  'offer',
                  transceiver.stream,
                  pc._dtlsRole
                );
                sdp += 'a=rtcp-rsize\r\n';
                if (
                  transceiver.iceGatherer &&
                  pc.iceGatheringState !== 'new' &&
                  (sdpMLineIndex === 0 || !pc.usingBundle)
                ) {
                  transceiver.iceGatherer
                    .getLocalCandidates()
                    .forEach(function (cand) {
                      cand.component = 1;
                      sdp += `a=${SDPUtils.writeCandidate(cand)}\r\n`;
                    });
                  if (transceiver.iceGatherer.state === 'completed') {
                    sdp += 'a=end-of-candidates\r\n';
                  }
                }
              });
              const desc = new window.RTCSessionDescription({
                type: 'offer',
                sdp,
              });
              return Promise.resolve(desc);
            };
            RTCPeerConnection.prototype.createAnswer = function () {
              const pc = this;
              if (pc._isClosed) {
                return Promise.reject(
                  makeError(
                    'InvalidStateError',
                    'Can not call createAnswer after close'
                  )
                );
              }
              let sdp = SDPUtils.writeSessionBoilerplate(
                pc._sdpSessionId,
                pc._sdpSessionVersion++
              );
              if (pc.usingBundle) {
                sdp += `a=group:BUNDLE ${pc.transceivers
                  .map(function (t) {
                    return t.mid;
                  })
                  .join(' ')}\r\n`;
              }
              const mediaSectionsInOffer = SDPUtils.getMediaSections(
                pc.remoteDescription.sdp
              ).length;
              pc.transceivers.forEach(function (transceiver, sdpMLineIndex) {
                if (sdpMLineIndex + 1 > mediaSectionsInOffer) {
                  return;
                }
                if (transceiver.isDatachannel) {
                  sdp += `${
                    'm=application 0 DTLS/SCTP 5000\r\n' +
                    'c=IN IP4 0.0.0.0\r\n' +
                    'a=mid:'
                  }${transceiver.mid}\r\n`;
                  return;
                }
                if (transceiver.stream) {
                  let localTrack;
                  if (transceiver.kind === 'audio') {
                    localTrack = transceiver.stream.getAudioTracks()[0];
                  } else if (transceiver.kind === 'video') {
                    localTrack = transceiver.stream.getVideoTracks()[0];
                  }
                  if (localTrack) {
                    if (
                      edgeVersion >= 15019 &&
                      transceiver.kind === 'video' &&
                      !transceiver.sendEncodingParameters[0].rtx
                    ) {
                      transceiver.sendEncodingParameters[0].rtx = {
                        ssrc: transceiver.sendEncodingParameters[0].ssrc + 1,
                      };
                    }
                  }
                }
                const commonCapabilities = getCommonCapabilities(
                  transceiver.localCapabilities,
                  transceiver.remoteCapabilities
                );
                const hasRtx = commonCapabilities.codecs.filter(function (c) {
                  return c.name.toLowerCase() === 'rtx';
                }).length;
                if (!hasRtx && transceiver.sendEncodingParameters[0].rtx) {
                  delete transceiver.sendEncodingParameters[0].rtx;
                }
                sdp += writeMediaSection(
                  transceiver,
                  commonCapabilities,
                  'answer',
                  transceiver.stream,
                  pc._dtlsRole
                );
                if (
                  transceiver.rtcpParameters &&
                  transceiver.rtcpParameters.reducedSize
                ) {
                  sdp += 'a=rtcp-rsize\r\n';
                }
              });
              const desc = new window.RTCSessionDescription({
                type: 'answer',
                sdp,
              });
              return Promise.resolve(desc);
            };
            RTCPeerConnection.prototype.addIceCandidate = function (candidate) {
              const pc = this;
              let sections;
              if (
                candidate &&
                !(candidate.sdpMLineIndex !== undefined || candidate.sdpMid)
              ) {
                return Promise.reject(
                  new TypeError('sdpMLineIndex or sdpMid required')
                );
              }
              return new Promise(function (resolve, reject) {
                if (!pc.remoteDescription) {
                  return reject(
                    makeError(
                      'InvalidStateError',
                      'Can not add ICE candidate without a remote description'
                    )
                  );
                } else if (!candidate || candidate.candidate === '') {
                  for (let j = 0; j < pc.transceivers.length; j++) {
                    if (pc.transceivers[j].isDatachannel) {
                      continue;
                    }
                    pc.transceivers[j].iceTransport.addRemoteCandidate({});
                    sections = SDPUtils.getMediaSections(
                      pc.remoteDescription.sdp
                    );
                    sections[j] += 'a=end-of-candidates\r\n';
                    pc.remoteDescription.sdp =
                      SDPUtils.getDescription(pc.remoteDescription.sdp) +
                      sections.join('');
                    if (pc.usingBundle) {
                      break;
                    }
                  }
                } else {
                  let { sdpMLineIndex } = candidate;
                  if (candidate.sdpMid) {
                    for (let i = 0; i < pc.transceivers.length; i++) {
                      if (pc.transceivers[i].mid === candidate.sdpMid) {
                        sdpMLineIndex = i;
                        break;
                      }
                    }
                  }
                  const transceiver = pc.transceivers[sdpMLineIndex];
                  if (transceiver) {
                    if (transceiver.isDatachannel) {
                      return resolve();
                    }
                    const cand =
                      Object.keys(candidate.candidate).length > 0
                        ? SDPUtils.parseCandidate(candidate.candidate)
                        : {};
                    if (
                      cand.protocol === 'tcp' &&
                      (cand.port === 0 || cand.port === 9)
                    ) {
                      return resolve();
                    }
                    if (cand.component && cand.component !== 1) {
                      return resolve();
                    }
                    if (
                      sdpMLineIndex === 0 ||
                      (sdpMLineIndex > 0 &&
                        transceiver.iceTransport !==
                          pc.transceivers[0].iceTransport)
                    ) {
                      if (!maybeAddCandidate(transceiver.iceTransport, cand)) {
                        return reject(
                          makeError(
                            'OperationError',
                            'Can not add ICE candidate'
                          )
                        );
                      }
                    }
                    let candidateString = candidate.candidate.trim();
                    if (candidateString.indexOf('a=') === 0) {
                      candidateString = candidateString.substr(2);
                    }
                    sections = SDPUtils.getMediaSections(
                      pc.remoteDescription.sdp
                    );
                    sections[sdpMLineIndex] += `a=${
                      cand.type ? candidateString : 'end-of-candidates'
                    }\r\n`;
                    pc.remoteDescription.sdp = sections.join('');
                  } else {
                    return reject(
                      makeError('OperationError', 'Can not add ICE candidate')
                    );
                  }
                }
                resolve();
              });
            };
            RTCPeerConnection.prototype.getStats = function () {
              const promises = [];
              this.transceivers.forEach(function (transceiver) {
                [
                  'rtpSender',
                  'rtpReceiver',
                  'iceGatherer',
                  'iceTransport',
                  'dtlsTransport',
                ].forEach(function (method) {
                  if (transceiver[method]) {
                    promises.push(transceiver[method].getStats());
                  }
                });
              });
              const fixStatsType = function (stat) {
                return (
                  {
                    inboundrtp: 'inbound-rtp',
                    outboundrtp: 'outbound-rtp',
                    candidatepair: 'candidate-pair',
                    localcandidate: 'local-candidate',
                    remotecandidate: 'remote-candidate',
                  }[stat.type] || stat.type
                );
              };
              return new Promise(function (resolve) {
                const results = new Map();
                Promise.all(promises).then(function (res) {
                  res.forEach(function (result) {
                    Object.keys(result).forEach(function (id) {
                      result[id].type = fixStatsType(result[id]);
                      results.set(id, result[id]);
                    });
                  });
                  resolve(results);
                });
              });
            };
            let methods = ['createOffer', 'createAnswer'];
            methods.forEach(function (method) {
              const nativeMethod = RTCPeerConnection.prototype[method];
              RTCPeerConnection.prototype[method] = function () {
                const args = arguments;
                if (
                  typeof args[0] === 'function' ||
                  typeof args[1] === 'function'
                ) {
                  return nativeMethod.apply(this, [arguments[2]]).then(
                    function (description) {
                      if (typeof args[0] === 'function') {
                        args[0].apply(null, [description]);
                      }
                    },
                    function (error) {
                      if (typeof args[1] === 'function') {
                        args[1].apply(null, [error]);
                      }
                    }
                  );
                }
                return nativeMethod.apply(this, arguments);
              };
            });
            methods = [
              'setLocalDescription',
              'setRemoteDescription',
              'addIceCandidate',
            ];
            methods.forEach(function (method) {
              const nativeMethod = RTCPeerConnection.prototype[method];
              RTCPeerConnection.prototype[method] = function () {
                const args = arguments;
                if (
                  typeof args[1] === 'function' ||
                  typeof args[2] === 'function'
                ) {
                  return nativeMethod.apply(this, arguments).then(
                    function () {
                      if (typeof args[1] === 'function') {
                        args[1].apply(null);
                      }
                    },
                    function (error) {
                      if (typeof args[2] === 'function') {
                        args[2].apply(null, [error]);
                      }
                    }
                  );
                }
                return nativeMethod.apply(this, arguments);
              };
            });
            ['getStats'].forEach(function (method) {
              const nativeMethod = RTCPeerConnection.prototype[method];
              RTCPeerConnection.prototype[method] = function () {
                const args = arguments;
                if (typeof args[1] === 'function') {
                  return nativeMethod.apply(this, arguments).then(function () {
                    if (typeof args[1] === 'function') {
                      args[1].apply(null);
                    }
                  });
                }
                return nativeMethod.apply(this, arguments);
              };
            });
            return RTCPeerConnection;
          };
        },
        { sdp: 57 },
      ],
      57: [
        function (require, module, exports) {
          const SDPUtils = {};
          SDPUtils.generateIdentifier = function () {
            return Math.random().toString(36).substr(2, 10);
          };
          SDPUtils.localCName = SDPUtils.generateIdentifier();
          SDPUtils.splitLines = function (blob) {
            return blob
              .trim()
              .split('\n')
              .map(function (line) {
                return line.trim();
              });
          };
          SDPUtils.splitSections = function (blob) {
            const parts = blob.split('\nm=');
            return parts.map(function (part, index) {
              return `${(index > 0 ? `m=${part}` : part).trim()}\r\n`;
            });
          };
          SDPUtils.getDescription = function (blob) {
            const sections = SDPUtils.splitSections(blob);
            return sections && sections[0];
          };
          SDPUtils.getMediaSections = function (blob) {
            const sections = SDPUtils.splitSections(blob);
            sections.shift();
            return sections;
          };
          SDPUtils.matchPrefix = function (blob, prefix) {
            return SDPUtils.splitLines(blob).filter(function (line) {
              return line.indexOf(prefix) === 0;
            });
          };
          SDPUtils.parseCandidate = function (line) {
            let parts;
            if (line.indexOf('a=candidate:') === 0) {
              parts = line.substring(12).split(' ');
            } else {
              parts = line.substring(10).split(' ');
            }
            const candidate = {
              foundation: parts[0],
              component: parseInt(parts[1], 10),
              protocol: parts[2].toLowerCase(),
              priority: parseInt(parts[3], 10),
              ip: parts[4],
              address: parts[4],
              port: parseInt(parts[5], 10),
              type: parts[7],
            };
            for (let i = 8; i < parts.length; i += 2) {
              switch (parts[i]) {
                case 'raddr':
                  candidate.relatedAddress = parts[i + 1];
                  break;
                case 'rport':
                  candidate.relatedPort = parseInt(parts[i + 1], 10);
                  break;
                case 'tcptype':
                  candidate.tcpType = parts[i + 1];
                  break;
                case 'ufrag':
                  candidate.ufrag = parts[i + 1];
                  candidate.usernameFragment = parts[i + 1];
                  break;
                default:
                  candidate[parts[i]] = parts[i + 1];
                  break;
              }
            }
            return candidate;
          };
          SDPUtils.writeCandidate = function (candidate) {
            const sdp = [];
            sdp.push(candidate.foundation);
            sdp.push(candidate.component);
            sdp.push(candidate.protocol.toUpperCase());
            sdp.push(candidate.priority);
            sdp.push(candidate.address || candidate.ip);
            sdp.push(candidate.port);
            const { type } = candidate;
            sdp.push('typ');
            sdp.push(type);
            if (
              type !== 'host' &&
              candidate.relatedAddress &&
              candidate.relatedPort
            ) {
              sdp.push('raddr');
              sdp.push(candidate.relatedAddress);
              sdp.push('rport');
              sdp.push(candidate.relatedPort);
            }
            if (
              candidate.tcpType &&
              candidate.protocol.toLowerCase() === 'tcp'
            ) {
              sdp.push('tcptype');
              sdp.push(candidate.tcpType);
            }
            if (candidate.usernameFragment || candidate.ufrag) {
              sdp.push('ufrag');
              sdp.push(candidate.usernameFragment || candidate.ufrag);
            }
            return `candidate:${sdp.join(' ')}`;
          };
          SDPUtils.parseIceOptions = function (line) {
            return line.substr(14).split(' ');
          };
          SDPUtils.parseRtpMap = function (line) {
            let parts = line.substr(9).split(' ');
            const parsed = { payloadType: parseInt(parts.shift(), 10) };
            parts = parts[0].split('/');
            parsed.name = parts[0];
            parsed.clockRate = parseInt(parts[1], 10);
            parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;
            parsed.numChannels = parsed.channels;
            return parsed;
          };
          SDPUtils.writeRtpMap = function (codec) {
            let pt = codec.payloadType;
            if (codec.preferredPayloadType !== undefined) {
              pt = codec.preferredPayloadType;
            }
            const channels = codec.channels || codec.numChannels || 1;
            return `a=rtpmap:${pt} ${codec.name}/${codec.clockRate}${
              channels !== 1 ? `/${channels}` : ''
            }\r\n`;
          };
          SDPUtils.parseExtmap = function (line) {
            const parts = line.substr(9).split(' ');
            return {
              id: parseInt(parts[0], 10),
              direction:
                parts[0].indexOf('/') > 0 ? parts[0].split('/')[1] : 'sendrecv',
              uri: parts[1],
            };
          };
          SDPUtils.writeExtmap = function (headerExtension) {
            return `a=extmap:${
              headerExtension.id || headerExtension.preferredId
            }${
              headerExtension.direction &&
              headerExtension.direction !== 'sendrecv'
                ? `/${headerExtension.direction}`
                : ''
            } ${headerExtension.uri}\r\n`;
          };
          SDPUtils.parseFmtp = function (line) {
            const parsed = {};
            let kv;
            const parts = line.substr(line.indexOf(' ') + 1).split(';');
            for (let j = 0; j < parts.length; j++) {
              kv = parts[j].trim().split('=');
              parsed[kv[0].trim()] = kv[1];
            }
            return parsed;
          };
          SDPUtils.writeFmtp = function (codec) {
            let line = '';
            let pt = codec.payloadType;
            if (codec.preferredPayloadType !== undefined) {
              pt = codec.preferredPayloadType;
            }
            if (codec.parameters && Object.keys(codec.parameters).length) {
              const params = [];
              Object.keys(codec.parameters).forEach(function (param) {
                if (codec.parameters[param]) {
                  params.push(`${param}=${codec.parameters[param]}`);
                } else {
                  params.push(param);
                }
              });
              line += `a=fmtp:${pt} ${params.join(';')}\r\n`;
            }
            return line;
          };
          SDPUtils.parseRtcpFb = function (line) {
            const parts = line.substr(line.indexOf(' ') + 1).split(' ');
            return { type: parts.shift(), parameter: parts.join(' ') };
          };
          SDPUtils.writeRtcpFb = function (codec) {
            let lines = '';
            let pt = codec.payloadType;
            if (codec.preferredPayloadType !== undefined) {
              pt = codec.preferredPayloadType;
            }
            if (codec.rtcpFeedback && codec.rtcpFeedback.length) {
              codec.rtcpFeedback.forEach(function (fb) {
                lines += `a=rtcp-fb:${pt} ${fb.type}${
                  fb.parameter && fb.parameter.length ? ` ${fb.parameter}` : ''
                }\r\n`;
              });
            }
            return lines;
          };
          SDPUtils.parseSsrcMedia = function (line) {
            const sp = line.indexOf(' ');
            const parts = { ssrc: parseInt(line.substr(7, sp - 7), 10) };
            const colon = line.indexOf(':', sp);
            if (colon > -1) {
              parts.attribute = line.substr(sp + 1, colon - sp - 1);
              parts.value = line.substr(colon + 1);
            } else {
              parts.attribute = line.substr(sp + 1);
            }
            return parts;
          };
          SDPUtils.parseSsrcGroup = function (line) {
            const parts = line.substr(13).split(' ');
            return {
              semantics: parts.shift(),
              ssrcs: parts.map(function (ssrc) {
                return parseInt(ssrc, 10);
              }),
            };
          };
          SDPUtils.getMid = function (mediaSection) {
            const mid = SDPUtils.matchPrefix(mediaSection, 'a=mid:')[0];
            if (mid) {
              return mid.substr(6);
            }
          };
          SDPUtils.parseFingerprint = function (line) {
            const parts = line.substr(14).split(' ');
            return { algorithm: parts[0].toLowerCase(), value: parts[1] };
          };
          SDPUtils.getDtlsParameters = function (mediaSection, sessionpart) {
            const lines = SDPUtils.matchPrefix(
              mediaSection + sessionpart,
              'a=fingerprint:'
            );
            return {
              role: 'auto',
              fingerprints: lines.map(SDPUtils.parseFingerprint),
            };
          };
          SDPUtils.writeDtlsParameters = function (params, setupType) {
            let sdp = `a=setup:${setupType}\r\n`;
            params.fingerprints.forEach(function (fp) {
              sdp += `a=fingerprint:${fp.algorithm} ${fp.value}\r\n`;
            });
            return sdp;
          };
          SDPUtils.parseCryptoLine = function (line) {
            const parts = line.substr(9).split(' ');
            return {
              tag: parseInt(parts[0], 10),
              cryptoSuite: parts[1],
              keyParams: parts[2],
              sessionParams: parts.slice(3),
            };
          };
          SDPUtils.writeCryptoLine = function (parameters) {
            return `a=crypto:${parameters.tag} ${parameters.cryptoSuite} ${
              typeof parameters.keyParams === 'object'
                ? SDPUtils.writeCryptoKeyParams(parameters.keyParams)
                : parameters.keyParams
            }${
              parameters.sessionParams
                ? ` ${parameters.sessionParams.join(' ')}`
                : ''
            }\r\n`;
          };
          SDPUtils.parseCryptoKeyParams = function (keyParams) {
            if (keyParams.indexOf('inline:') !== 0) {
              return null;
            }
            const parts = keyParams.substr(7).split('|');
            return {
              keyMethod: 'inline',
              keySalt: parts[0],
              lifeTime: parts[1],
              mkiValue: parts[2] ? parts[2].split(':')[0] : undefined,
              mkiLength: parts[2] ? parts[2].split(':')[1] : undefined,
            };
          };
          SDPUtils.writeCryptoKeyParams = function (keyParams) {
            return `${keyParams.keyMethod}:${keyParams.keySalt}${
              keyParams.lifeTime ? `|${keyParams.lifeTime}` : ''
            }${
              keyParams.mkiValue && keyParams.mkiLength
                ? `|${keyParams.mkiValue}:${keyParams.mkiLength}`
                : ''
            }`;
          };
          SDPUtils.getCryptoParameters = function (mediaSection, sessionpart) {
            const lines = SDPUtils.matchPrefix(
              mediaSection + sessionpart,
              'a=crypto:'
            );
            return lines.map(SDPUtils.parseCryptoLine);
          };
          SDPUtils.getIceParameters = function (mediaSection, sessionpart) {
            const ufrag = SDPUtils.matchPrefix(
              mediaSection + sessionpart,
              'a=ice-ufrag:'
            )[0];
            const pwd = SDPUtils.matchPrefix(
              mediaSection + sessionpart,
              'a=ice-pwd:'
            )[0];
            if (!(ufrag && pwd)) {
              return null;
            }
            return {
              usernameFragment: ufrag.substr(12),
              password: pwd.substr(10),
            };
          };
          SDPUtils.writeIceParameters = function (params) {
            return (
              `a=ice-ufrag:${params.usernameFragment}\r\n` +
              `a=ice-pwd:${params.password}\r\n`
            );
          };
          SDPUtils.parseRtpParameters = function (mediaSection) {
            const description = {
              codecs: [],
              headerExtensions: [],
              fecMechanisms: [],
              rtcp: [],
            };
            const lines = SDPUtils.splitLines(mediaSection);
            const mline = lines[0].split(' ');
            for (let i = 3; i < mline.length; i++) {
              const pt = mline[i];
              const rtpmapline = SDPUtils.matchPrefix(
                mediaSection,
                `a=rtpmap:${pt} `
              )[0];
              if (rtpmapline) {
                const codec = SDPUtils.parseRtpMap(rtpmapline);
                const fmtps = SDPUtils.matchPrefix(
                  mediaSection,
                  `a=fmtp:${pt} `
                );
                codec.parameters = fmtps.length
                  ? SDPUtils.parseFmtp(fmtps[0])
                  : {};
                codec.rtcpFeedback = SDPUtils.matchPrefix(
                  mediaSection,
                  `a=rtcp-fb:${pt} `
                ).map(SDPUtils.parseRtcpFb);
                description.codecs.push(codec);
                switch (codec.name.toUpperCase()) {
                  case 'RED':
                  case 'ULPFEC':
                    description.fecMechanisms.push(codec.name.toUpperCase());
                    break;
                  default:
                    break;
                }
              }
            }
            SDPUtils.matchPrefix(mediaSection, 'a=extmap:').forEach(function (
              line
            ) {
              description.headerExtensions.push(SDPUtils.parseExtmap(line));
            });
            return description;
          };
          SDPUtils.writeRtpDescription = function (kind, caps) {
            let sdp = '';
            sdp += `m=${kind} `;
            sdp += caps.codecs.length > 0 ? '9' : '0';
            sdp += ' UDP/TLS/RTP/SAVPF ';
            sdp += `${caps.codecs
              .map(function (codec) {
                if (codec.preferredPayloadType !== undefined) {
                  return codec.preferredPayloadType;
                }
                return codec.payloadType;
              })
              .join(' ')}\r\n`;
            sdp += 'c=IN IP4 0.0.0.0\r\n';
            sdp += 'a=rtcp:9 IN IP4 0.0.0.0\r\n';
            caps.codecs.forEach(function (codec) {
              sdp += SDPUtils.writeRtpMap(codec);
              sdp += SDPUtils.writeFmtp(codec);
              sdp += SDPUtils.writeRtcpFb(codec);
            });
            let maxptime = 0;
            caps.codecs.forEach(function (codec) {
              if (codec.maxptime > maxptime) {
                maxptime = codec.maxptime;
              }
            });
            if (maxptime > 0) {
              sdp += `a=maxptime:${maxptime}\r\n`;
            }
            sdp += 'a=rtcp-mux\r\n';
            if (caps.headerExtensions) {
              caps.headerExtensions.forEach(function (extension) {
                sdp += SDPUtils.writeExtmap(extension);
              });
            }
            return sdp;
          };
          SDPUtils.parseRtpEncodingParameters = function (mediaSection) {
            const encodingParameters = [];
            const description = SDPUtils.parseRtpParameters(mediaSection);
            const hasRed = description.fecMechanisms.indexOf('RED') !== -1;
            const hasUlpfec =
              description.fecMechanisms.indexOf('ULPFEC') !== -1;
            const ssrcs = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
              .map(function (line) {
                return SDPUtils.parseSsrcMedia(line);
              })
              .filter(function (parts) {
                return parts.attribute === 'cname';
              });
            const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;
            let secondarySsrc;
            const flows = SDPUtils.matchPrefix(
              mediaSection,
              'a=ssrc-group:FID'
            ).map(function (line) {
              const parts = line.substr(17).split(' ');
              return parts.map(function (part) {
                return parseInt(part, 10);
              });
            });
            if (
              flows.length > 0 &&
              flows[0].length > 1 &&
              flows[0][0] === primarySsrc
            ) {
              secondarySsrc = flows[0][1];
            }
            description.codecs.forEach(function (codec) {
              if (codec.name.toUpperCase() === 'RTX' && codec.parameters.apt) {
                let encParam = {
                  ssrc: primarySsrc,
                  codecPayloadType: parseInt(codec.parameters.apt, 10),
                };
                if (primarySsrc && secondarySsrc) {
                  encParam.rtx = { ssrc: secondarySsrc };
                }
                encodingParameters.push(encParam);
                if (hasRed) {
                  encParam = JSON.parse(JSON.stringify(encParam));
                  encParam.fec = {
                    ssrc: primarySsrc,
                    mechanism: hasUlpfec ? 'red+ulpfec' : 'red',
                  };
                  encodingParameters.push(encParam);
                }
              }
            });
            if (encodingParameters.length === 0 && primarySsrc) {
              encodingParameters.push({ ssrc: primarySsrc });
            }
            let bandwidth = SDPUtils.matchPrefix(mediaSection, 'b=');
            if (bandwidth.length) {
              if (bandwidth[0].indexOf('b=TIAS:') === 0) {
                bandwidth = parseInt(bandwidth[0].substr(7), 10);
              } else if (bandwidth[0].indexOf('b=AS:') === 0) {
                bandwidth =
                  parseInt(bandwidth[0].substr(5), 10) * 1e3 * 0.95 -
                  50 * 40 * 8;
              } else {
                bandwidth = undefined;
              }
              encodingParameters.forEach(function (params) {
                params.maxBitrate = bandwidth;
              });
            }
            return encodingParameters;
          };
          SDPUtils.parseRtcpParameters = function (mediaSection) {
            const rtcpParameters = {};
            const remoteSsrc = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
              .map(function (line) {
                return SDPUtils.parseSsrcMedia(line);
              })
              .filter(function (obj) {
                return obj.attribute === 'cname';
              })[0];
            if (remoteSsrc) {
              rtcpParameters.cname = remoteSsrc.value;
              rtcpParameters.ssrc = remoteSsrc.ssrc;
            }
            const rsize = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-rsize');
            rtcpParameters.reducedSize = rsize.length > 0;
            rtcpParameters.compound = rsize.length === 0;
            const mux = SDPUtils.matchPrefix(mediaSection, 'a=rtcp-mux');
            rtcpParameters.mux = mux.length > 0;
            return rtcpParameters;
          };
          SDPUtils.parseMsid = function (mediaSection) {
            let parts;
            const spec = SDPUtils.matchPrefix(mediaSection, 'a=msid:');
            if (spec.length === 1) {
              parts = spec[0].substr(7).split(' ');
              return { stream: parts[0], track: parts[1] };
            }
            const planB = SDPUtils.matchPrefix(mediaSection, 'a=ssrc:')
              .map(function (line) {
                return SDPUtils.parseSsrcMedia(line);
              })
              .filter(function (msidParts) {
                return msidParts.attribute === 'msid';
              });
            if (planB.length > 0) {
              parts = planB[0].value.split(' ');
              return { stream: parts[0], track: parts[1] };
            }
          };
          SDPUtils.parseSctpDescription = function (mediaSection) {
            const mline = SDPUtils.parseMLine(mediaSection);
            const maxSizeLine = SDPUtils.matchPrefix(
              mediaSection,
              'a=max-message-size:'
            );
            let maxMessageSize;
            if (maxSizeLine.length > 0) {
              maxMessageSize = parseInt(maxSizeLine[0].substr(19), 10);
            }
            if (isNaN(maxMessageSize)) {
              maxMessageSize = 65536;
            }
            const sctpPort = SDPUtils.matchPrefix(mediaSection, 'a=sctp-port:');
            if (sctpPort.length > 0) {
              return {
                port: parseInt(sctpPort[0].substr(12), 10),
                protocol: mline.fmt,
                maxMessageSize,
              };
            }
            const sctpMapLines = SDPUtils.matchPrefix(
              mediaSection,
              'a=sctpmap:'
            );
            if (sctpMapLines.length > 0) {
              const parts = SDPUtils.matchPrefix(mediaSection, 'a=sctpmap:')[0]
                .substr(10)
                .split(' ');
              return {
                port: parseInt(parts[0], 10),
                protocol: parts[1],
                maxMessageSize,
              };
            }
          };
          SDPUtils.writeSctpDescription = function (media, sctp) {
            let output = [];
            if (media.protocol !== 'DTLS/SCTP') {
              output = [
                `m=${media.kind} 9 ${media.protocol} ${sctp.protocol}\r\n`,
                'c=IN IP4 0.0.0.0\r\n',
                `a=sctp-port:${sctp.port}\r\n`,
              ];
            } else {
              output = [
                `m=${media.kind} 9 ${media.protocol} ${sctp.port}\r\n`,
                'c=IN IP4 0.0.0.0\r\n',
                `a=sctpmap:${sctp.port} ${sctp.protocol} 65535\r\n`,
              ];
            }
            if (sctp.maxMessageSize !== undefined) {
              output.push(`a=max-message-size:${sctp.maxMessageSize}\r\n`);
            }
            return output.join('');
          };
          SDPUtils.generateSessionId = function () {
            return Math.random().toString().substr(2, 21);
          };
          SDPUtils.writeSessionBoilerplate = function (
            sessId,
            sessVer,
            sessUser
          ) {
            let sessionId;
            const version = sessVer !== undefined ? sessVer : 2;
            if (sessId) {
              sessionId = sessId;
            } else {
              sessionId = SDPUtils.generateSessionId();
            }
            const user = sessUser || 'thisisadapterortc';
            return (
              `${
                'v=0\r\n' + 'o='
              }${user} ${sessionId} ${version} IN IP4 127.0.0.1\r\n` +
              `s=-\r\n` +
              `t=0 0\r\n`
            );
          };
          SDPUtils.writeMediaSection = function (
            transceiver,
            caps,
            type,
            stream
          ) {
            let sdp = SDPUtils.writeRtpDescription(transceiver.kind, caps);
            sdp += SDPUtils.writeIceParameters(
              transceiver.iceGatherer.getLocalParameters()
            );
            sdp += SDPUtils.writeDtlsParameters(
              transceiver.dtlsTransport.getLocalParameters(),
              type === 'offer' ? 'actpass' : 'active'
            );
            sdp += `a=mid:${transceiver.mid}\r\n`;
            if (transceiver.direction) {
              sdp += `a=${transceiver.direction}\r\n`;
            } else if (transceiver.rtpSender && transceiver.rtpReceiver) {
              sdp += 'a=sendrecv\r\n';
            } else if (transceiver.rtpSender) {
              sdp += 'a=sendonly\r\n';
            } else if (transceiver.rtpReceiver) {
              sdp += 'a=recvonly\r\n';
            } else {
              sdp += 'a=inactive\r\n';
            }
            if (transceiver.rtpSender) {
              const msid = `msid:${stream.id} ${transceiver.rtpSender.track.id}\r\n`;
              sdp += `a=${msid}`;
              sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc} ${msid}`;
              if (transceiver.sendEncodingParameters[0].rtx) {
                sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc} ${msid}`;
                sdp += `a=ssrc-group:FID ${transceiver.sendEncodingParameters[0].ssrc} ${transceiver.sendEncodingParameters[0].rtx.ssrc}\r\n`;
              }
            }
            sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].ssrc} cname:${SDPUtils.localCName}\r\n`;
            if (
              transceiver.rtpSender &&
              transceiver.sendEncodingParameters[0].rtx
            ) {
              sdp += `a=ssrc:${transceiver.sendEncodingParameters[0].rtx.ssrc} cname:${SDPUtils.localCName}\r\n`;
            }
            return sdp;
          };
          SDPUtils.getDirection = function (mediaSection, sessionpart) {
            const lines = SDPUtils.splitLines(mediaSection);
            for (let i = 0; i < lines.length; i++) {
              switch (lines[i]) {
                case 'a=sendrecv':
                case 'a=sendonly':
                case 'a=recvonly':
                case 'a=inactive':
                  return lines[i].substr(2);
                default:
              }
            }
            if (sessionpart) {
              return SDPUtils.getDirection(sessionpart);
            }
            return 'sendrecv';
          };
          SDPUtils.getKind = function (mediaSection) {
            const lines = SDPUtils.splitLines(mediaSection);
            const mline = lines[0].split(' ');
            return mline[0].substr(2);
          };
          SDPUtils.isRejected = function (mediaSection) {
            return mediaSection.split(' ', 2)[1] === '0';
          };
          SDPUtils.parseMLine = function (mediaSection) {
            const lines = SDPUtils.splitLines(mediaSection);
            const parts = lines[0].substr(2).split(' ');
            return {
              kind: parts[0],
              port: parseInt(parts[1], 10),
              protocol: parts[2],
              fmt: parts.slice(3).join(' '),
            };
          };
          SDPUtils.parseOLine = function (mediaSection) {
            const line = SDPUtils.matchPrefix(mediaSection, 'o=')[0];
            const parts = line.substr(2).split(' ');
            return {
              username: parts[0],
              sessionId: parts[1],
              sessionVersion: parseInt(parts[2], 10),
              netType: parts[3],
              addressType: parts[4],
              address: parts[5],
            };
          };
          SDPUtils.isValidSDP = function (blob) {
            if (typeof blob !== 'string' || blob.length === 0) {
              return false;
            }
            const lines = SDPUtils.splitLines(blob);
            for (let i = 0; i < lines.length; i++) {
              if (lines[i].length < 2 || lines[i].charAt(1) !== '=') {
                return false;
              }
            }
            return true;
          };
          if (typeof module === 'object') {
            module.exports = SDPUtils;
          }
        },
        {},
      ],
      58: [
        function (require, module, exports) {
          if (typeof Object.create === 'function') {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true,
                },
              });
            };
          } else {
            module.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              const TempCtor = function () {};
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
        },
        {},
      ],
      59: [
        function (require, module, exports) {
          module.exports = function isBuffer(arg) {
            return (
              arg &&
              typeof arg === 'object' &&
              typeof arg.copy === 'function' &&
              typeof arg.fill === 'function' &&
              typeof arg.readUInt8 === 'function'
            );
          };
        },
        {},
      ],
      60: [
        function (require, module, exports) {
          (function (process, global) {
            (function () {
              const formatRegExp = /%[sdj%]/g;
              exports.format = function (f) {
                if (!isString(f)) {
                  const objects = [];
                  for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                  }
                  return objects.join(' ');
                }
                var i = 1;
                const args = arguments;
                const len = args.length;
                let str = String(f).replace(formatRegExp, function (x) {
                  if (x === '%%') return '%';
                  if (i >= len) return x;
                  switch (x) {
                    case '%s':
                      return String(args[i++]);
                    case '%d':
                      return Number(args[i++]);
                    case '%j':
                      try {
                        return JSON.stringify(args[i++]);
                      } catch (_) {
                        return '[Circular]';
                      }
                    default:
                      return x;
                  }
                });
                for (let x = args[i]; i < len; x = args[++i]) {
                  if (isNull(x) || !isObject(x)) {
                    str += ` ${x}`;
                  } else {
                    str += ` ${inspect(x)}`;
                  }
                }
                return str;
              };
              exports.deprecate = function (fn, msg) {
                if (isUndefined(global.process)) {
                  return function () {
                    return exports.deprecate(fn, msg).apply(this, arguments);
                  };
                }
                if (process.noDeprecation === true) {
                  return fn;
                }
                let warned = false;
                function deprecated() {
                  if (!warned) {
                    if (process.throwDeprecation) {
                      throw new Error(msg);
                    } else if (process.traceDeprecation) {
                      console.trace(msg);
                    } else {
                      console.error(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              };
              const debugs = {};
              let debugEnviron;
              exports.debuglog = function (set) {
                if (isUndefined(debugEnviron))
                  debugEnviron = process.env.NODE_DEBUG || '';
                set = set.toUpperCase();
                if (!debugs[set]) {
                  if (new RegExp(`\\b${set}\\b`, 'i').test(debugEnviron)) {
                    const { pid } = process;
                    debugs[set] = function () {
                      const msg = exports.format.apply(exports, arguments);
                      console.error('%s %d: %s', set, pid, msg);
                    };
                  } else {
                    debugs[set] = function () {};
                  }
                }
                return debugs[set];
              };
              function inspect(obj, opts) {
                const ctx = { seen: [], stylize: stylizeNoColor };
                if (arguments.length >= 3) ctx.depth = arguments[2];
                if (arguments.length >= 4) ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                  ctx.showHidden = opts;
                } else if (opts) {
                  exports._extend(ctx, opts);
                }
                if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
                if (isUndefined(ctx.depth)) ctx.depth = 2;
                if (isUndefined(ctx.colors)) ctx.colors = false;
                if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
                if (ctx.colors) ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
              }
              exports.inspect = inspect;
              inspect.colors = {
                bold: [1, 22],
                italic: [3, 23],
                underline: [4, 24],
                inverse: [7, 27],
                white: [37, 39],
                grey: [90, 39],
                black: [30, 39],
                blue: [34, 39],
                cyan: [36, 39],
                green: [32, 39],
                magenta: [35, 39],
                red: [31, 39],
                yellow: [33, 39],
              };
              inspect.styles = {
                special: 'cyan',
                number: 'yellow',
                boolean: 'yellow',
                undefined: 'grey',
                null: 'bold',
                string: 'green',
                date: 'magenta',
                regexp: 'red',
              };
              function stylizeWithColor(str, styleType) {
                const style = inspect.styles[styleType];
                if (style) {
                  return `\x1b[${inspect.colors[style][0]}m${str}\x1b[${inspect.colors[style][1]}m`;
                }
                return str;
              }
              function stylizeNoColor(str, styleType) {
                return str;
              }
              function arrayToHash(array) {
                const hash = {};
                array.forEach(function (val, idx) {
                  hash[val] = true;
                });
                return hash;
              }
              function formatValue(ctx, value, recurseTimes) {
                if (
                  ctx.customInspect &&
                  value &&
                  isFunction(value.inspect) &&
                  value.inspect !== exports.inspect &&
                  !(value.constructor && value.constructor.prototype === value)
                ) {
                  let ret = value.inspect(recurseTimes, ctx);
                  if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                  }
                  return ret;
                }
                const primitive = formatPrimitive(ctx, value);
                if (primitive) {
                  return primitive;
                }
                let keys = Object.keys(value);
                const visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                  keys = Object.getOwnPropertyNames(value);
                }
                if (
                  isError(value) &&
                  (keys.indexOf('message') >= 0 ||
                    keys.indexOf('description') >= 0)
                ) {
                  return formatError(value);
                }
                if (keys.length === 0) {
                  if (isFunction(value)) {
                    const name = value.name ? `: ${value.name}` : '';
                    return ctx.stylize(`[Function${name}]`, 'special');
                  }
                  if (isRegExp(value)) {
                    return ctx.stylize(
                      RegExp.prototype.toString.call(value),
                      'regexp'
                    );
                  }
                  if (isDate(value)) {
                    return ctx.stylize(
                      Date.prototype.toString.call(value),
                      'date'
                    );
                  }
                  if (isError(value)) {
                    return formatError(value);
                  }
                }
                let base = '';
                let array = false;
                let braces = ['{', '}'];
                if (isArray(value)) {
                  array = true;
                  braces = ['[', ']'];
                }
                if (isFunction(value)) {
                  const n = value.name ? `: ${value.name}` : '';
                  base = ` [Function${n}]`;
                }
                if (isRegExp(value)) {
                  base = ` ${RegExp.prototype.toString.call(value)}`;
                }
                if (isDate(value)) {
                  base = ` ${Date.prototype.toUTCString.call(value)}`;
                }
                if (isError(value)) {
                  base = ` ${formatError(value)}`;
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                  return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                  if (isRegExp(value)) {
                    return ctx.stylize(
                      RegExp.prototype.toString.call(value),
                      'regexp'
                    );
                  }
                  return ctx.stylize('[Object]', 'special');
                }
                ctx.seen.push(value);
                let output;
                if (array) {
                  output = formatArray(
                    ctx,
                    value,
                    recurseTimes,
                    visibleKeys,
                    keys
                  );
                } else {
                  output = keys.map(function (key) {
                    return formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      array
                    );
                  });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
              }
              function formatPrimitive(ctx, value) {
                if (isUndefined(value))
                  return ctx.stylize('undefined', 'undefined');
                if (isString(value)) {
                  const simple = `'${JSON.stringify(value)
                    .replace(/^"|"$/g, '')
                    .replace(/'/g, "\\'")
                    .replace(/\\"/g, '"')}'`;
                  return ctx.stylize(simple, 'string');
                }
                if (isNumber(value)) return ctx.stylize(`${value}`, 'number');
                if (isBoolean(value)) return ctx.stylize(`${value}`, 'boolean');
                if (isNull(value)) return ctx.stylize('null', 'null');
              }
              function formatError(value) {
                return `[${Error.prototype.toString.call(value)}]`;
              }
              function formatArray(
                ctx,
                value,
                recurseTimes,
                visibleKeys,
                keys
              ) {
                const output = [];
                for (let i = 0, l = value.length; i < l; ++i) {
                  if (hasOwnProperty(value, String(i))) {
                    output.push(
                      formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        String(i),
                        true
                      )
                    );
                  } else {
                    output.push('');
                  }
                }
                keys.forEach(function (key) {
                  if (!key.match(/^\d+$/)) {
                    output.push(
                      formatProperty(
                        ctx,
                        value,
                        recurseTimes,
                        visibleKeys,
                        key,
                        true
                      )
                    );
                  }
                });
                return output;
              }
              function formatProperty(
                ctx,
                value,
                recurseTimes,
                visibleKeys,
                key,
                array
              ) {
                let name;
                let str;
                let desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || {
                  value: value[key],
                };
                if (desc.get) {
                  if (desc.set) {
                    str = ctx.stylize('[Getter/Setter]', 'special');
                  } else {
                    str = ctx.stylize('[Getter]', 'special');
                  }
                } else if (desc.set) {
                  str = ctx.stylize('[Setter]', 'special');
                }
                if (!hasOwnProperty(visibleKeys, key)) {
                  name = `[${key}]`;
                }
                if (!str) {
                  if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                      str = formatValue(ctx, desc.value, null);
                    } else {
                      str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf('\n') > -1) {
                      if (array) {
                        str = str
                          .split('\n')
                          .map(function (line) {
                            return `  ${line}`;
                          })
                          .join('\n')
                          .substr(2);
                      } else {
                        str = `\n${str
                          .split('\n')
                          .map(function (line) {
                            return `   ${line}`;
                          })
                          .join('\n')}`;
                      }
                    }
                  } else {
                    str = ctx.stylize('[Circular]', 'special');
                  }
                }
                if (isUndefined(name)) {
                  if (array && key.match(/^\d+$/)) {
                    return str;
                  }
                  name = JSON.stringify(`${key}`);
                  if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, 'name');
                  } else {
                    name = name
                      .replace(/'/g, "\\'")
                      .replace(/\\"/g, '"')
                      .replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, 'string');
                  }
                }
                return `${name}: ${str}`;
              }
              function reduceToSingleString(output, base, braces) {
                let numLinesEst = 0;
                const length = output.reduce(function (prev, cur) {
                  numLinesEst++;
                  if (cur.indexOf('\n') >= 0) numLinesEst++;
                  return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
                }, 0);
                if (length > 60) {
                  return `${
                    braces[0] + (base === '' ? '' : `${base}\n `)
                  } ${output.join(',\n  ')} ${braces[1]}`;
                }
                return `${braces[0] + base} ${output.join(', ')} ${braces[1]}`;
              }
              function isArray(ar) {
                return Array.isArray(ar);
              }
              exports.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === 'boolean';
              }
              exports.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === 'number';
              }
              exports.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === 'string';
              }
              exports.isString = isString;
              function isSymbol(arg) {
                return typeof arg === 'symbol';
              }
              exports.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports.isUndefined = isUndefined;
              function isRegExp(re) {
                return isObject(re) && objectToString(re) === '[object RegExp]';
              }
              exports.isRegExp = isRegExp;
              function isObject(arg) {
                return typeof arg === 'object' && arg !== null;
              }
              exports.isObject = isObject;
              function isDate(d) {
                return isObject(d) && objectToString(d) === '[object Date]';
              }
              exports.isDate = isDate;
              function isError(e) {
                return (
                  isObject(e) &&
                  (objectToString(e) === '[object Error]' || e instanceof Error)
                );
              }
              exports.isError = isError;
              function isFunction(arg) {
                return typeof arg === 'function';
              }
              exports.isFunction = isFunction;
              function isPrimitive(arg) {
                return (
                  arg === null ||
                  typeof arg === 'boolean' ||
                  typeof arg === 'number' ||
                  typeof arg === 'string' ||
                  typeof arg === 'symbol' ||
                  typeof arg === 'undefined'
                );
              }
              exports.isPrimitive = isPrimitive;
              exports.isBuffer = require('./support/isBuffer');
              function objectToString(o) {
                return Object.prototype.toString.call(o);
              }
              function pad(n) {
                return n < 10 ? `0${n.toString(10)}` : n.toString(10);
              }
              const months = [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec',
              ];
              function timestamp() {
                const d = new Date();
                const time = [
                  pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds()),
                ].join(':');
                return [d.getDate(), months[d.getMonth()], time].join(' ');
              }
              exports.log = function () {
                console.log(
                  '%s - %s',
                  timestamp(),
                  exports.format.apply(exports, arguments)
                );
              };
              exports.inherits = require('inherits');
              exports._extend = function (origin, add) {
                if (!add || !isObject(add)) return origin;
                const keys = Object.keys(add);
                let i = keys.length;
                while (i--) {
                  origin[keys[i]] = add[keys[i]];
                }
                return origin;
              };
              function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              }
            }.call(this));
          }.call(
            this,
            require('_process'),
            typeof global !== 'undefined'
              ? global
              : typeof self !== 'undefined'
              ? self
              : typeof window !== 'undefined'
              ? window
              : {}
          ));
        },
        { './support/isBuffer': 59, _process: 53, inherits: 58 },
      ],
    },
    {},
    [3]
  );
  const Voice = bundle(3);
  if (typeof define === 'function' && define.amd) {
    define([], function () {
      return Voice;
    });
  } else {
    const Twilio = (root.Twilio = root.Twilio || {});
    Twilio.Call = Twilio.Call || Voice.Call;
    Twilio.Device = Twilio.Device || Voice.Device;
    Twilio.PStream = Twilio.PStream || Voice.PStream;
    Twilio.PreflightTest = Twilio.PreflightTest || Voice.PreflightTest;
    Twilio.Logger = Twilio.Logger || Voice.Logger;
  }
})(
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
    ? global
    : this
);
